module.exports = {

"[project]/node_modules/apollo-server-core/dist/cachePolicy.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.newCachePolicy = void 0;
const apollo_server_types_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-types/dist/index.js [app-route] (ecmascript)");
function newCachePolicy() {
    return {
        maxAge: undefined,
        scope: undefined,
        restrict (hint) {
            if (hint.maxAge !== undefined && (this.maxAge === undefined || hint.maxAge < this.maxAge)) {
                this.maxAge = hint.maxAge;
            }
            if (hint.scope !== undefined && this.scope !== apollo_server_types_1.CacheScope.Private) {
                this.scope = hint.scope;
            }
        },
        replace (hint) {
            if (hint.maxAge !== undefined) {
                this.maxAge = hint.maxAge;
            }
            if (hint.scope !== undefined) {
                this.scope = hint.scope;
            }
        },
        policyIfCacheable () {
            var _a;
            if (this.maxAge === undefined || this.maxAge === 0) {
                return null;
            }
            return {
                maxAge: this.maxAge,
                scope: (_a = this.scope) !== null && _a !== void 0 ? _a : apollo_server_types_1.CacheScope.Public
            };
        }
    };
}
exports.newCachePolicy = newCachePolicy; //# sourceMappingURL=cachePolicy.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/graphqlOptions.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resolveGraphqlOptions = void 0;
async function resolveGraphqlOptions(options, ...args) {
    if (typeof options === 'function') {
        return await options(...args);
    } else {
        return options;
    }
}
exports.resolveGraphqlOptions = resolveGraphqlOptions; //# sourceMappingURL=graphqlOptions.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/utils/schemaInstrumentation.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.whenResultIsFinished = exports.pluginsEnabledForSchemaResolvers = exports.enablePluginsForSchemaResolvers = exports.symbolUserFieldResolver = exports.symbolExecutionDispatcherWillResolveField = void 0;
const type_1 = __turbopack_context__.r("[project]/node_modules/graphql/type/index.js [app-route] (ecmascript)");
const execution_1 = __turbopack_context__.r("[project]/node_modules/graphql/execution/index.js [app-route] (ecmascript)");
exports.symbolExecutionDispatcherWillResolveField = Symbol('apolloServerExecutionDispatcherWillResolveField');
exports.symbolUserFieldResolver = Symbol('apolloServerUserFieldResolver');
const symbolPluginsEnabled = Symbol('apolloServerPluginsEnabled');
function enablePluginsForSchemaResolvers(schema) {
    if (pluginsEnabledForSchemaResolvers(schema)) {
        return schema;
    }
    Object.defineProperty(schema, symbolPluginsEnabled, {
        value: true
    });
    forEachField(schema, wrapField);
    return schema;
}
exports.enablePluginsForSchemaResolvers = enablePluginsForSchemaResolvers;
function pluginsEnabledForSchemaResolvers(schema) {
    return !!schema[symbolPluginsEnabled];
}
exports.pluginsEnabledForSchemaResolvers = pluginsEnabledForSchemaResolvers;
function wrapField(field) {
    const originalFieldResolve = field.resolve;
    field.resolve = (source, args, context, info)=>{
        const parentPath = info.path.prev;
        const willResolveField = context === null || context === void 0 ? void 0 : context[exports.symbolExecutionDispatcherWillResolveField];
        const userFieldResolver = context === null || context === void 0 ? void 0 : context[exports.symbolUserFieldResolver];
        const didResolveField = typeof willResolveField === 'function' && willResolveField({
            source,
            args,
            context,
            info
        });
        const resolveObject = info.parentType.resolveObject;
        let whenObjectResolved;
        if (parentPath && resolveObject) {
            if (!parentPath.__fields) {
                parentPath.__fields = {};
            }
            parentPath.__fields[info.fieldName] = info.fieldNodes;
            whenObjectResolved = parentPath.__whenObjectResolved;
            if (!whenObjectResolved) {
                whenObjectResolved = Promise.resolve().then(()=>{
                    return resolveObject(source, parentPath.__fields, context, info);
                });
                parentPath.__whenObjectResolved = whenObjectResolved;
            }
        }
        const fieldResolver = originalFieldResolve || userFieldResolver || execution_1.defaultFieldResolver;
        try {
            let result;
            if (whenObjectResolved) {
                result = whenObjectResolved.then((resolvedObject)=>{
                    return fieldResolver(resolvedObject, args, context, info);
                });
            } else {
                result = fieldResolver(source, args, context, info);
            }
            if (typeof didResolveField === 'function') {
                whenResultIsFinished(result, didResolveField);
            }
            return result;
        } catch (error) {
            if (typeof didResolveField === 'function') {
                didResolveField(error);
            }
            throw error;
        }
    };
}
function isPromise(x) {
    return x && typeof x.then === 'function';
}
function whenResultIsFinished(result, callback) {
    if (isPromise(result)) {
        result.then((r)=>callback(null, r), (err)=>callback(err));
    } else if (Array.isArray(result)) {
        if (result.some(isPromise)) {
            Promise.all(result).then((r)=>callback(null, r), (err)=>callback(err));
        } else {
            callback(null, result);
        }
    } else {
        callback(null, result);
    }
}
exports.whenResultIsFinished = whenResultIsFinished;
function forEachField(schema, fn) {
    const typeMap = schema.getTypeMap();
    Object.entries(typeMap).forEach(([typeName, type])=>{
        if (!(0, type_1.getNamedType)(type).name.startsWith('__') && type instanceof type_1.GraphQLObjectType) {
            const fields = type.getFields();
            Object.entries(fields).forEach(([fieldName, field])=>{
                fn(field, typeName, fieldName);
            });
        }
    });
} //# sourceMappingURL=schemaInstrumentation.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/utils/dispatcher.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Dispatcher = void 0;
class Dispatcher {
    constructor(targets){
        this.targets = targets;
    }
    callTargets(methodName, ...args) {
        return this.targets.map((target)=>{
            const method = target[methodName];
            if (typeof method === 'function') {
                return method.apply(target, args);
            }
        });
    }
    hasHook(methodName) {
        return this.targets.some((target)=>typeof target[methodName] === 'function');
    }
    async invokeHook(methodName, ...args) {
        return Promise.all(this.callTargets(methodName, ...args));
    }
    async invokeHooksUntilNonNull(methodName, ...args) {
        for (const target of this.targets){
            const method = target[methodName];
            if (typeof method !== 'function') {
                continue;
            }
            const value = await method.apply(target, args);
            if (value !== null) {
                return value;
            }
        }
        return null;
    }
    async invokeDidStartHook(methodName, ...args) {
        const hookReturnValues = await Promise.all(this.callTargets(methodName, ...args));
        const didEndHooks = hookReturnValues.filter((hook)=>!!hook);
        didEndHooks.reverse();
        return async (...args)=>{
            await Promise.all(didEndHooks.map((hook)=>hook(...args)));
        };
    }
    invokeSyncDidStartHook(methodName, ...args) {
        const didEndHooks = [];
        for (const target of this.targets){
            const method = target[methodName];
            if (typeof method === 'function') {
                const didEndHook = method.apply(target, args);
                if (didEndHook) {
                    didEndHooks.push(didEndHook);
                }
            }
        }
        didEndHooks.reverse();
        return (...args)=>{
            for (const didEndHook of didEndHooks){
                didEndHook(...args);
            }
        };
    }
}
exports.Dispatcher = Dispatcher; //# sourceMappingURL=dispatcher.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/utils/isNodeLike.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = typeof process === 'object' && process && process.release && process.versions && typeof process.versions.node === 'string'; //# sourceMappingURL=isNodeLike.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/utils/createSHA.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const isNodeLike_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/utils/isNodeLike.js [app-route] (ecmascript)"));
function default_1(kind) {
    if (isNodeLike_1.default) {
        return module.require('crypto').createHash(kind);
    }
    return __turbopack_context__.r("[project]/node_modules/sha.js/index.js [app-route] (ecmascript)")(kind);
}
exports.default = default_1; //# sourceMappingURL=createSHA.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/requestPipeline.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.processGraphQLRequest = exports.APQ_CACHE_PREFIX = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const schemaInstrumentation_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/utils/schemaInstrumentation.js [app-route] (ecmascript)");
const apollo_server_errors_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-errors/dist/index.js [app-route] (ecmascript)");
const dispatcher_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/utils/dispatcher.js [app-route] (ecmascript)");
const utils_keyvaluecache_1 = __turbopack_context__.r("[project]/node_modules/@apollo/utils.keyvaluecache/dist/index.js [app-route] (ecmascript)");
const createSHA_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/utils/createSHA.js [app-route] (ecmascript)"));
const runHttpQuery_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/runHttpQuery.js [app-route] (ecmascript)");
const apollo_server_env_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-env/dist/index.js [app-route] (ecmascript)");
exports.APQ_CACHE_PREFIX = 'apq:';
function computeQueryHash(query) {
    return (0, createSHA_1.default)('sha256').update(query).digest('hex');
}
function isBadUserInputGraphQLError(error) {
    var _a;
    return ((_a = error.nodes) === null || _a === void 0 ? void 0 : _a.length) === 1 && error.nodes[0].kind === graphql_1.Kind.VARIABLE_DEFINITION && (error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" got invalid value `) || error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" of required type `) || error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" of non-null type `));
}
async function processGraphQLRequest(config, requestContext) {
    var _a, _b;
    const logger = requestContext.logger || console;
    const metrics = requestContext.metrics = requestContext.metrics || Object.create(null);
    const dispatcher = await initializeRequestListenerDispatcher();
    await initializeDataSources();
    const request = requestContext.request;
    let { query, extensions } = request;
    let queryHash;
    let persistedQueryCache;
    metrics.persistedQueryHit = false;
    metrics.persistedQueryRegister = false;
    if (extensions === null || extensions === void 0 ? void 0 : extensions.persistedQuery) {
        if (!config.persistedQueries || !config.persistedQueries.cache) {
            return await sendErrorResponse(new apollo_server_errors_1.PersistedQueryNotSupportedError());
        } else if (extensions.persistedQuery.version !== 1) {
            return await sendErrorResponse(new graphql_1.GraphQLError('Unsupported persisted query version'));
        }
        persistedQueryCache = config.persistedQueries.cache;
        if (!(persistedQueryCache instanceof utils_keyvaluecache_1.PrefixingKeyValueCache)) {
            persistedQueryCache = new utils_keyvaluecache_1.PrefixingKeyValueCache(persistedQueryCache, exports.APQ_CACHE_PREFIX);
        }
        queryHash = extensions.persistedQuery.sha256Hash;
        if (query === undefined) {
            query = await persistedQueryCache.get(queryHash);
            if (query) {
                metrics.persistedQueryHit = true;
            } else {
                return await sendErrorResponse(new apollo_server_errors_1.PersistedQueryNotFoundError());
            }
        } else {
            const computedQueryHash = computeQueryHash(query);
            if (queryHash !== computedQueryHash) {
                return await sendErrorResponse(new graphql_1.GraphQLError('provided sha does not match query'));
            }
            metrics.persistedQueryRegister = true;
        }
    } else if (query) {
        queryHash = computeQueryHash(query);
    } else {
        return await sendErrorResponse(new graphql_1.GraphQLError('GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension.'));
    }
    requestContext.queryHash = queryHash;
    requestContext.source = query;
    await dispatcher.invokeHook('didResolveSource', requestContext);
    if (config.documentStore) {
        try {
            requestContext.document = await config.documentStore.get(queryHash);
        } catch (err) {
            logger.warn('An error occurred while attempting to read from the documentStore. ' + (err === null || err === void 0 ? void 0 : err.message) || err);
        }
    }
    if (!requestContext.document) {
        const parsingDidEnd = await dispatcher.invokeDidStartHook('parsingDidStart', requestContext);
        try {
            requestContext.document = parse(query, config.parseOptions);
            await parsingDidEnd();
        } catch (syntaxError) {
            await parsingDidEnd(syntaxError);
            return await sendErrorResponse(syntaxError, apollo_server_errors_1.SyntaxError);
        }
        if (config.dangerouslyDisableValidation !== true) {
            const validationDidEnd = await dispatcher.invokeDidStartHook('validationDidStart', requestContext);
            const validationErrors = validate(requestContext.document);
            if (validationErrors.length === 0) {
                await validationDidEnd();
            } else {
                await validationDidEnd(validationErrors);
                return await sendErrorResponse(validationErrors, apollo_server_errors_1.ValidationError);
            }
        }
        if (config.documentStore) {
            Promise.resolve(config.documentStore.set(queryHash, requestContext.document)).catch((err)=>logger.warn('Could not store validated document. ' + (err === null || err === void 0 ? void 0 : err.message) || err));
        }
    }
    const operation = (0, graphql_1.getOperationAST)(requestContext.document, request.operationName);
    requestContext.operation = operation || undefined;
    requestContext.operationName = ((_a = operation === null || operation === void 0 ? void 0 : operation.name) === null || _a === void 0 ? void 0 : _a.value) || null;
    try {
        await dispatcher.invokeHook('didResolveOperation', requestContext);
    } catch (err) {
        return await sendErrorResponse(err);
    }
    if (metrics.persistedQueryRegister && persistedQueryCache) {
        Promise.resolve(persistedQueryCache.set(queryHash, query, config.persistedQueries && typeof config.persistedQueries.ttl !== 'undefined' ? {
            ttl: config.persistedQueries.ttl
        } : Object.create(null))).catch(logger.warn);
    }
    let response = await dispatcher.invokeHooksUntilNonNull('responseForOperation', requestContext);
    if (response == null) {
        const executionListeners = [];
        (await dispatcher.invokeHook('executionDidStart', requestContext)).forEach((executionListener)=>{
            if (executionListener) {
                executionListeners.push(executionListener);
            }
        });
        executionListeners.reverse();
        const executionDispatcher = new dispatcher_1.Dispatcher(executionListeners);
        if (executionDispatcher.hasHook('willResolveField')) {
            const invokeWillResolveField = (...args)=>executionDispatcher.invokeSyncDidStartHook('willResolveField', ...args);
            Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolExecutionDispatcherWillResolveField, {
                value: invokeWillResolveField
            });
            if (config.fieldResolver) {
                Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolUserFieldResolver, {
                    value: config.fieldResolver
                });
            }
            (0, schemaInstrumentation_1.enablePluginsForSchemaResolvers)(config.schema);
        }
        try {
            const result = await execute(requestContext);
            const resultErrors = (_b = result.errors) === null || _b === void 0 ? void 0 : _b.map((e)=>{
                if (isBadUserInputGraphQLError(e)) {
                    return (0, apollo_server_errors_1.fromGraphQLError)(e, {
                        errorClass: apollo_server_errors_1.UserInputError
                    });
                }
                return e;
            });
            if (resultErrors) {
                await didEncounterErrors(resultErrors);
            }
            response = {
                ...result,
                errors: resultErrors ? formatErrors(resultErrors) : undefined
            };
            await executionDispatcher.invokeHook('executionDidEnd');
        } catch (executionError) {
            await executionDispatcher.invokeHook('executionDidEnd', executionError);
            return await sendErrorResponse(executionError);
        }
    }
    if (config.formatResponse) {
        const formattedResponse = config.formatResponse(response, requestContext);
        if (formattedResponse != null) {
            response = formattedResponse;
        }
    }
    return sendResponse(response);
    //TURBOPACK unreachable
    ;
    function parse(query, parseOptions) {
        return (0, graphql_1.parse)(query, parseOptions);
    }
    function validate(document) {
        let rules = graphql_1.specifiedRules;
        if (config.validationRules) {
            rules = rules.concat(config.validationRules);
        }
        return (0, graphql_1.validate)(config.schema, document, rules);
    }
    async function execute(requestContext) {
        const { request, document } = requestContext;
        const executionArgs = {
            schema: config.schema,
            document,
            rootValue: typeof config.rootValue === 'function' ? config.rootValue(document) : config.rootValue,
            contextValue: requestContext.context,
            variableValues: request.variables,
            operationName: request.operationName,
            fieldResolver: config.fieldResolver
        };
        if (config.executor) {
            return await config.executor(requestContext);
        } else {
            return await (0, graphql_1.execute)(executionArgs);
        }
    }
    async function sendResponse(response) {
        requestContext.response = {
            ...requestContext.response,
            errors: response.errors,
            data: response.data,
            extensions: response.extensions
        };
        if (response.http) {
            if (!requestContext.response.http) {
                requestContext.response.http = {
                    headers: new apollo_server_env_1.Headers()
                };
            }
            if (response.http.status) {
                requestContext.response.http.status = response.http.status;
            }
            for (const [name, value] of response.http.headers){
                requestContext.response.http.headers.set(name, value);
            }
        }
        await dispatcher.invokeHook('willSendResponse', requestContext);
        return requestContext.response;
    }
    async function didEncounterErrors(errors) {
        requestContext.errors = errors;
        return await dispatcher.invokeHook('didEncounterErrors', requestContext);
    }
    async function sendErrorResponse(errorOrErrors, errorClass) {
        const errors = Array.isArray(errorOrErrors) ? errorOrErrors : [
            errorOrErrors
        ];
        await didEncounterErrors(errors);
        const response = {
            errors: formatErrors(errors.map((err)=>err instanceof apollo_server_errors_1.ApolloError && !errorClass ? err : (0, apollo_server_errors_1.fromGraphQLError)(err, errorClass && {
                    errorClass
                })))
        };
        if (errors.every((err)=>err instanceof apollo_server_errors_1.PersistedQueryNotSupportedError || err instanceof apollo_server_errors_1.PersistedQueryNotFoundError)) {
            response.http = {
                status: 200,
                headers: new apollo_server_env_1.Headers({
                    'Cache-Control': 'private, no-cache, must-revalidate'
                })
            };
        } else if (errors.length === 1 && errors[0] instanceof runHttpQuery_1.HttpQueryError) {
            response.http = {
                status: errors[0].statusCode,
                headers: new apollo_server_env_1.Headers(errors[0].headers)
            };
        }
        return sendResponse(response);
    }
    function formatErrors(errors) {
        return (0, apollo_server_errors_1.formatApolloErrors)(errors, {
            formatter: config.formatError,
            debug: requestContext.debug
        });
    }
    async function initializeRequestListenerDispatcher() {
        const requestListeners = [];
        if (config.plugins) {
            for (const plugin of config.plugins){
                if (!plugin.requestDidStart) continue;
                const listener = await plugin.requestDidStart(requestContext);
                if (listener) {
                    requestListeners.push(listener);
                }
            }
        }
        return new dispatcher_1.Dispatcher(requestListeners);
    }
    async function initializeDataSources() {
        if (config.dataSources) {
            const context = requestContext.context;
            const dataSources = config.dataSources();
            const initializers = [];
            for (const dataSource of Object.values(dataSources)){
                if (dataSource.initialize) {
                    initializers.push(dataSource.initialize({
                        context,
                        cache: requestContext.cache
                    }));
                }
            }
            await Promise.all(initializers);
            if ('dataSources' in context) {
                throw new Error('Please use the dataSources config option instead of putting dataSources on the context yourself.');
            }
            context.dataSources = dataSources;
        }
    }
}
exports.processGraphQLRequest = processGraphQLRequest; //# sourceMappingURL=requestPipeline.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/runHttpQuery.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.cloneObject = exports.processHTTPRequest = exports.runHttpQuery = exports.throwHttpGraphQLError = exports.isHttpQueryError = exports.HttpQueryError = void 0;
const apollo_server_env_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-env/dist/index.js [app-route] (ecmascript)");
const apollo_server_errors_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-errors/dist/index.js [app-route] (ecmascript)");
const whatwg_mimetype_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/whatwg-mimetype/lib/mime-type.js [app-route] (ecmascript)"));
const cachePolicy_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/cachePolicy.js [app-route] (ecmascript)");
const graphqlOptions_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/graphqlOptions.js [app-route] (ecmascript)");
const requestPipeline_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/requestPipeline.js [app-route] (ecmascript)");
class HttpQueryError extends Error {
    constructor(statusCode, message, isGraphQLError = false, headers){
        super(message);
        this.name = 'HttpQueryError';
        this.statusCode = statusCode;
        this.isGraphQLError = isGraphQLError;
        this.headers = headers;
    }
}
exports.HttpQueryError = HttpQueryError;
function isHttpQueryError(e) {
    return (e === null || e === void 0 ? void 0 : e.name) === 'HttpQueryError';
}
exports.isHttpQueryError = isHttpQueryError;
function throwHttpGraphQLError(statusCode, errors, options, extensions, headers) {
    const allHeaders = {
        'Content-Type': 'application/json'
    };
    if (headers) {
        for (const [name, value] of headers){
            allHeaders[name] = value;
        }
    }
    const result = {
        errors: options ? (0, apollo_server_errors_1.formatApolloErrors)(errors, {
            debug: options.debug,
            formatter: options.formatError
        }) : errors
    };
    if (extensions) {
        result.extensions = extensions;
    }
    throw new HttpQueryError(statusCode, prettyJSONStringify(result), true, allHeaders);
}
exports.throwHttpGraphQLError = throwHttpGraphQLError;
const NODE_ENV = (_a = ("TURBOPACK compile-time value", "development")) !== null && _a !== void 0 ? _a : '';
const NON_PREFLIGHTED_CONTENT_TYPES = [
    'application/x-www-form-urlencoded',
    'multipart/form-data',
    'text/plain'
];
function preventCsrf(headers, csrfPreventionRequestHeaders) {
    const contentType = headers.get('content-type');
    if (contentType !== null) {
        const contentTypeParsed = whatwg_mimetype_1.default.parse(contentType);
        if (contentTypeParsed === null) {
            return;
        }
        if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {
            return;
        }
    }
    if (csrfPreventionRequestHeaders.some((header)=>{
        const value = headers.get(header);
        return value !== null && value.length > 0;
    })) {
        return;
    }
    throw new HttpQueryError(400, `This operation has been blocked as a potential Cross-Site Request Forgery ` + `(CSRF). Please either specify a 'content-type' header (with a type that ` + `is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(', ')}) or provide ` + `a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(', ')}\n`);
}
async function runHttpQuery(handlerArguments, request, csrfPreventionRequestHeaders) {
    function debugFromNodeEnv(nodeEnv = NODE_ENV) {
        return nodeEnv !== 'production' && nodeEnv !== 'test';
    }
    if (csrfPreventionRequestHeaders) {
        preventCsrf(request.request.headers, csrfPreventionRequestHeaders);
    }
    let options;
    try {
        options = await (0, graphqlOptions_1.resolveGraphqlOptions)(request.options, ...handlerArguments);
    } catch (e) {
        return throwHttpGraphQLError(500, [
            e
        ], {
            debug: debugFromNodeEnv()
        });
    }
    if (options.debug === undefined) {
        options.debug = debugFromNodeEnv(options.nodeEnv);
    }
    if (typeof options.context === 'function') {
        try {
            options.context();
        } catch (e) {
            e.message = `Context creation failed: ${e.message}`;
            if (e.extensions && e.extensions.code && e.extensions.code !== 'INTERNAL_SERVER_ERROR') {
                return throwHttpGraphQLError(400, [
                    e
                ], options);
            } else {
                return throwHttpGraphQLError(500, [
                    e
                ], options);
            }
        }
    }
    const config = {
        schema: options.schema,
        schemaHash: options.schemaHash,
        logger: options.logger,
        rootValue: options.rootValue,
        context: options.context || {},
        validationRules: options.validationRules,
        executor: options.executor,
        fieldResolver: options.fieldResolver,
        cache: options.cache,
        dataSources: options.dataSources,
        dangerouslyDisableValidation: options.dangerouslyDisableValidation,
        documentStore: options.documentStore,
        persistedQueries: options.persistedQueries,
        formatError: options.formatError,
        formatResponse: options.formatResponse,
        debug: options.debug,
        plugins: options.plugins || [],
        allowBatchedHttpRequests: options.allowBatchedHttpRequests
    };
    return processHTTPRequest(config, request);
}
exports.runHttpQuery = runHttpQuery;
async function processHTTPRequest(options, httpRequest) {
    var _a, _b;
    let requestPayload;
    switch(httpRequest.method){
        case 'POST':
            if (!httpRequest.query || typeof httpRequest.query === 'string' || Buffer.isBuffer(httpRequest.query) || Object.keys(httpRequest.query).length === 0) {
                throw new HttpQueryError(400, 'POST body missing, invalid Content-Type, or JSON object has no keys.');
            }
            requestPayload = httpRequest.query;
            break;
        case 'GET':
            if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {
                throw new HttpQueryError(400, 'GET query missing.');
            }
            requestPayload = httpRequest.query;
            break;
        default:
            throw new HttpQueryError(405, 'Apollo Server supports only GET/POST requests.', false, {
                Allow: 'GET, POST'
            });
    }
    options = {
        ...options,
        plugins: [
            checkOperationPlugin,
            ...options.plugins
        ]
    };
    function buildRequestContext(request, requestIsBatched) {
        const context = cloneObject(options.context);
        return {
            logger: options.logger || console,
            schema: options.schema,
            schemaHash: options.schemaHash,
            request,
            response: {
                http: {
                    headers: new apollo_server_env_1.Headers()
                }
            },
            context,
            cache: options.cache,
            debug: options.debug,
            metrics: {},
            overallCachePolicy: (0, cachePolicy_1.newCachePolicy)(),
            requestIsBatched
        };
    }
    const responseInit = {
        headers: {
            'Content-Type': 'application/json'
        }
    };
    let body;
    try {
        if (Array.isArray(requestPayload)) {
            if (options.allowBatchedHttpRequests === false) {
                return throwHttpGraphQLError(400, [
                    new Error('Operation batching disabled.')
                ], options);
            }
            const requests = requestPayload.map((requestParams)=>parseGraphQLRequest(httpRequest.request, requestParams));
            const responses = await Promise.all(requests.map(async (request)=>{
                try {
                    const requestContext = buildRequestContext(request, true);
                    const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);
                    if (response.http) {
                        for (const [name, value] of response.http.headers){
                            responseInit.headers[name] = value;
                        }
                        if (response.http.status) {
                            responseInit.status = response.http.status;
                        }
                    }
                    return response;
                } catch (error) {
                    return {
                        errors: (0, apollo_server_errors_1.formatApolloErrors)([
                            error
                        ], options)
                    };
                }
            }));
            body = prettyJSONStringify(responses.map(serializeGraphQLResponse));
        } else {
            const request = parseGraphQLRequest(httpRequest.request, requestPayload);
            const requestContext = buildRequestContext(request, false);
            const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);
            if (response.errors && typeof response.data === 'undefined') {
                return throwHttpGraphQLError(((_a = response.http) === null || _a === void 0 ? void 0 : _a.status) || 400, response.errors, undefined, response.extensions, (_b = response.http) === null || _b === void 0 ? void 0 : _b.headers);
            }
            if (response.http) {
                for (const [name, value] of response.http.headers){
                    responseInit.headers[name] = value;
                }
                if (response.http.status) {
                    responseInit.status = response.http.status;
                }
            }
            body = prettyJSONStringify(serializeGraphQLResponse(response));
        }
    } catch (error) {
        if (error instanceof HttpQueryError) {
            throw error;
        }
        return throwHttpGraphQLError(500, [
            error
        ], options);
    }
    responseInit.headers['Content-Length'] = Buffer.byteLength(body, 'utf8').toString();
    return {
        graphqlResponse: body,
        responseInit
    };
}
exports.processHTTPRequest = processHTTPRequest;
function parseGraphQLRequest(httpRequest, requestParams) {
    let queryString = requestParams.query;
    let extensions = requestParams.extensions;
    if (typeof extensions === 'string' && extensions !== '') {
        try {
            extensions = JSON.parse(extensions);
        } catch (error) {
            throw new HttpQueryError(400, 'Extensions are invalid JSON.');
        }
    }
    if (queryString && typeof queryString !== 'string') {
        if (queryString.kind === 'Document') {
            throw new HttpQueryError(400, "GraphQL queries must be strings. It looks like you're sending the " + 'internal graphql-js representation of a parsed query in your ' + 'request instead of a request in the GraphQL query language. You ' + 'can convert an AST to a string using the `print` function from ' + '`graphql`, or use a client like `apollo-client` which converts ' + 'the internal representation to a string for you.');
        } else {
            throw new HttpQueryError(400, 'GraphQL queries must be strings.');
        }
    }
    const operationName = requestParams.operationName;
    let variables = requestParams.variables;
    if (typeof variables === 'string' && variables !== '') {
        try {
            variables = JSON.parse(variables);
        } catch (error) {
            throw new HttpQueryError(400, 'Variables are invalid JSON.');
        }
    }
    return {
        query: queryString,
        operationName,
        variables,
        extensions,
        http: httpRequest
    };
}
const checkOperationPlugin = {
    async requestDidStart () {
        return {
            async didResolveOperation ({ request, operation }) {
                if (!request.http) return;
                if (request.http.method === 'GET' && operation.operation !== 'query') {
                    throw new HttpQueryError(405, `GET supports only query operation`, false, {
                        Allow: 'POST'
                    });
                }
            }
        };
    }
};
function serializeGraphQLResponse(response) {
    return {
        errors: response.errors,
        data: response.data,
        extensions: response.extensions
    };
}
function prettyJSONStringify(value) {
    return JSON.stringify(value) + '\n';
}
function cloneObject(object) {
    return Object.assign(Object.create(Object.getPrototypeOf(object)), object);
}
exports.cloneObject = cloneObject; //# sourceMappingURL=runHttpQuery.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/nodeHttpToRequest.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.convertNodeHttpToRequest = void 0;
const apollo_server_env_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-env/dist/index.js [app-route] (ecmascript)");
function convertNodeHttpToRequest(req) {
    const headers = new apollo_server_env_1.Headers();
    Object.keys(req.headers).forEach((key)=>{
        const values = req.headers[key];
        if (Array.isArray(values)) {
            values.forEach((value)=>headers.append(key, value));
        } else {
            headers.append(key, values);
        }
    });
    return new apollo_server_env_1.Request(req.url, {
        headers,
        method: req.method
    });
}
exports.convertNodeHttpToRequest = convertNodeHttpToRequest; //# sourceMappingURL=nodeHttpToRequest.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/utils/schemaHash.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateSchemaHash = void 0;
const language_1 = __turbopack_context__.r("[project]/node_modules/graphql/language/index.js [app-route] (ecmascript)");
const execution_1 = __turbopack_context__.r("[project]/node_modules/graphql/execution/index.js [app-route] (ecmascript)");
const utilities_1 = __turbopack_context__.r("[project]/node_modules/graphql/utilities/index.js [app-route] (ecmascript)");
const fast_json_stable_stringify_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/fast-json-stable-stringify/index.js [app-route] (ecmascript)"));
const createSHA_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/utils/createSHA.js [app-route] (ecmascript)"));
function generateSchemaHash(schema) {
    const introspectionQuery = (0, utilities_1.getIntrospectionQuery)();
    const document = (0, language_1.parse)(introspectionQuery);
    const result = (0, execution_1.execute)({
        schema,
        document
    });
    if (result && typeof result.then === 'function') {
        throw new Error([
            'The introspection query is resolving asynchronously; execution of an introspection query is not expected to return a `Promise`.',
            '',
            'Wrapped type resolvers should maintain the existing execution dynamics of the resolvers they wrap (i.e. async vs sync) or introspection types should be excluded from wrapping by checking them with `graphql/type`s, `isIntrospectionType` predicate function prior to wrapping.'
        ].join('\n'));
    }
    if (!result || !result.data || !result.data.__schema) {
        throw new Error('Unable to generate server introspection document.');
    }
    const introspectionSchema = result.data.__schema;
    const stringifiedSchema = (0, fast_json_stable_stringify_1.default)(introspectionSchema);
    return (0, createSHA_1.default)('sha512').update(stringifiedSchema).digest('hex');
}
exports.generateSchemaHash = generateSchemaHash; //# sourceMappingURL=schemaHash.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/determineApolloConfig.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.determineApolloConfig = void 0;
const createSHA_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/utils/createSHA.js [app-route] (ecmascript)"));
function determineApolloConfig(input, logger) {
    var _a, _b, _c;
    const apolloConfig = {};
    const { APOLLO_KEY, APOLLO_GRAPH_REF, APOLLO_GRAPH_ID, APOLLO_GRAPH_VARIANT } = process.env;
    if (input === null || input === void 0 ? void 0 : input.key) {
        apolloConfig.key = input.key.trim();
    } else if (APOLLO_KEY) {
        apolloConfig.key = APOLLO_KEY.trim();
    }
    if (((_a = input === null || input === void 0 ? void 0 : input.key) !== null && _a !== void 0 ? _a : APOLLO_KEY) !== apolloConfig.key) {
        logger.warn('The provided API key has unexpected leading or trailing whitespace. ' + 'Apollo Server will trim the key value before use.');
    }
    if (apolloConfig.key) {
        assertValidHeaderValue(apolloConfig.key);
    }
    if (apolloConfig.key) {
        apolloConfig.keyHash = (0, createSHA_1.default)('sha512').update(apolloConfig.key).digest('hex');
    }
    if (input === null || input === void 0 ? void 0 : input.graphRef) {
        apolloConfig.graphRef = input.graphRef;
    } else if (APOLLO_GRAPH_REF) {
        apolloConfig.graphRef = APOLLO_GRAPH_REF;
    }
    const graphId = (_b = input === null || input === void 0 ? void 0 : input.graphId) !== null && _b !== void 0 ? _b : APOLLO_GRAPH_ID;
    const graphVariant = (_c = input === null || input === void 0 ? void 0 : input.graphVariant) !== null && _c !== void 0 ? _c : APOLLO_GRAPH_VARIANT;
    if (apolloConfig.graphRef) {
        if (graphId) {
            throw new Error('Cannot specify both graph ref and graph ID. Please use ' + '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph ID.');
        }
        if (graphVariant) {
            throw new Error('Cannot specify both graph ref and graph variant. Please use ' + '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph variant.');
        }
    } else if (graphId) {
        apolloConfig.graphRef = graphVariant ? `${graphId}@${graphVariant}` : graphId;
    }
    return apolloConfig;
}
exports.determineApolloConfig = determineApolloConfig;
function assertValidHeaderValue(value) {
    const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
    if (invalidHeaderCharRegex.test(value)) {
        const invalidChars = value.match(invalidHeaderCharRegex);
        throw new Error(`The API key provided to Apollo Server contains characters which are invalid as HTTP header values. The following characters found in the key are invalid: ${invalidChars.join(', ')}. Valid header values may only contain ASCII visible characters. If you think there is an issue with your key, please contact Apollo support.`);
    }
} //# sourceMappingURL=determineApolloConfig.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/operationDerivedDataCache.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.operationDerivedDataCacheKey = exports.createOperationDerivedDataCache = void 0;
const lru_cache_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/lru-cache/index.js [app-route] (ecmascript)"));
function createOperationDerivedDataCache({ logger }) {
    let lastWarn;
    let lastDisposals = 0;
    return new lru_cache_1.default({
        length (obj) {
            return Buffer.byteLength(JSON.stringify(obj), 'utf8');
        },
        max: Math.pow(2, 20) * 10,
        dispose () {
            lastDisposals++;
            if (!lastWarn || new Date().getTime() - lastWarn.getTime() > 60000) {
                lastWarn = new Date();
                logger.warn([
                    'This server is processing a high number of unique operations.  ',
                    `A total of ${lastDisposals} records have been `,
                    'ejected from the ApolloServerPluginUsageReporting signature cache in the past ',
                    'interval.  If you see this warning frequently, please open an ',
                    'issue on the Apollo Server repository.'
                ].join(''));
                lastDisposals = 0;
            }
        }
    });
}
exports.createOperationDerivedDataCache = createOperationDerivedDataCache;
function operationDerivedDataCacheKey(queryHash, operationName) {
    return `${queryHash}${operationName && ':' + operationName}`;
}
exports.operationDerivedDataCacheKey = operationDerivedDataCacheKey; //# sourceMappingURL=operationDerivedDataCache.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/traceTreeBuilder.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dateToProtoTimestamp = exports.TraceTreeBuilder = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const apollo_reporting_protobuf_1 = __turbopack_context__.r("[project]/node_modules/apollo-reporting-protobuf/generated/index.js [app-route] (ecmascript)");
function internalError(message) {
    return new Error(`[internal apollo-server error] ${message}`);
}
class TraceTreeBuilder {
    constructor(options){
        this.rootNode = new apollo_reporting_protobuf_1.Trace.Node();
        this.logger = console;
        this.trace = new apollo_reporting_protobuf_1.Trace({
            root: this.rootNode,
            fieldExecutionWeight: 1
        });
        this.stopped = false;
        this.nodes = new Map([
            [
                responsePathAsString(),
                this.rootNode
            ]
        ]);
        this.rewriteError = options.rewriteError;
        if (options.logger) this.logger = options.logger;
    }
    startTiming() {
        if (this.startHrTime) {
            throw internalError('startTiming called twice!');
        }
        if (this.stopped) {
            throw internalError('startTiming called after stopTiming!');
        }
        this.trace.startTime = dateToProtoTimestamp(new Date());
        this.startHrTime = process.hrtime();
    }
    stopTiming() {
        if (!this.startHrTime) {
            throw internalError('stopTiming called before startTiming!');
        }
        if (this.stopped) {
            throw internalError('stopTiming called twice!');
        }
        this.trace.durationNs = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        this.trace.endTime = dateToProtoTimestamp(new Date());
        this.stopped = true;
    }
    willResolveField(info) {
        if (!this.startHrTime) {
            throw internalError('willResolveField called before startTiming!');
        }
        if (this.stopped) {
            return ()=>{};
        }
        const path = info.path;
        const node = this.newNode(path);
        node.type = info.returnType.toString();
        node.parentType = info.parentType.toString();
        node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        if (typeof path.key === 'string' && path.key !== info.fieldName) {
            node.originalFieldName = info.fieldName;
        }
        return ()=>{
            node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        };
    }
    didEncounterErrors(errors) {
        errors.forEach((err)=>{
            var _a;
            if ((_a = err.extensions) === null || _a === void 0 ? void 0 : _a.serviceName) {
                return;
            }
            const errorForReporting = this.rewriteAndNormalizeError(err);
            if (errorForReporting === null) {
                return;
            }
            this.addProtobufError(errorForReporting.path, errorToProtobufError(errorForReporting));
        });
    }
    addProtobufError(path, error) {
        if (!this.startHrTime) {
            throw internalError('addProtobufError called before startTiming!');
        }
        if (this.stopped) {
            throw internalError('addProtobufError called after stopTiming!');
        }
        let node = this.rootNode;
        if (Array.isArray(path)) {
            const specificNode = this.nodes.get(path.join('.'));
            if (specificNode) {
                node = specificNode;
            } else {
                this.logger.warn(`Could not find node with path ${path.join('.')}; defaulting to put errors on root node.`);
            }
        }
        node.error.push(error);
    }
    newNode(path) {
        const node = new apollo_reporting_protobuf_1.Trace.Node();
        const id = path.key;
        if (typeof id === 'number') {
            node.index = id;
        } else {
            node.responseName = id;
        }
        this.nodes.set(responsePathAsString(path), node);
        const parentNode = this.ensureParentNode(path);
        parentNode.child.push(node);
        return node;
    }
    ensureParentNode(path) {
        const parentPath = responsePathAsString(path.prev);
        const parentNode = this.nodes.get(parentPath);
        if (parentNode) {
            return parentNode;
        }
        return this.newNode(path.prev);
    }
    rewriteAndNormalizeError(err) {
        if (this.rewriteError) {
            const clonedError = Object.assign(Object.create(Object.getPrototypeOf(err)), err);
            const rewrittenError = this.rewriteError(clonedError);
            if (rewrittenError === null) {
                return null;
            }
            if (!(rewrittenError instanceof graphql_1.GraphQLError)) {
                return err;
            }
            return new graphql_1.GraphQLError(rewrittenError.message, err.nodes, err.source, err.positions, err.path, err.originalError, rewrittenError.extensions || err.extensions);
        }
        return err;
    }
}
exports.TraceTreeBuilder = TraceTreeBuilder;
function durationHrTimeToNanos(hrtime) {
    return hrtime[0] * 1e9 + hrtime[1];
}
function responsePathAsString(p) {
    if (p === undefined) {
        return '';
    }
    let res = String(p.key);
    while((p = p.prev) !== undefined){
        res = `${p.key}.${res}`;
    }
    return res;
}
function errorToProtobufError(error) {
    return new apollo_reporting_protobuf_1.Trace.Error({
        message: error.message,
        location: (error.locations || []).map(({ line, column })=>new apollo_reporting_protobuf_1.Trace.Location({
                line,
                column
            })),
        json: JSON.stringify(error)
    });
}
function dateToProtoTimestamp(date) {
    const totalMillis = +date;
    const millis = totalMillis % 1000;
    return new apollo_reporting_protobuf_1.google.protobuf.Timestamp({
        seconds: (totalMillis - millis) / 1000,
        nanos: millis * 1e6
    });
}
exports.dateToProtoTimestamp = dateToProtoTimestamp; //# sourceMappingURL=traceTreeBuilder.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/traceDetails.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeTraceDetails = void 0;
const apollo_reporting_protobuf_1 = __turbopack_context__.r("[project]/node_modules/apollo-reporting-protobuf/generated/index.js [app-route] (ecmascript)");
function makeTraceDetails(variables, sendVariableValues, operationString) {
    const details = new apollo_reporting_protobuf_1.Trace.Details();
    const variablesToRecord = (()=>{
        if (sendVariableValues && 'transform' in sendVariableValues) {
            const originalKeys = Object.keys(variables);
            try {
                const modifiedVariables = sendVariableValues.transform({
                    variables: variables,
                    operationString: operationString
                });
                return cleanModifiedVariables(originalKeys, modifiedVariables);
            } catch (e) {
                return handleVariableValueTransformError(originalKeys);
            }
        } else {
            return variables;
        }
    })();
    Object.keys(variablesToRecord).forEach((name)=>{
        if (!sendVariableValues || 'none' in sendVariableValues && sendVariableValues.none || 'all' in sendVariableValues && !sendVariableValues.all || 'exceptNames' in sendVariableValues && sendVariableValues.exceptNames.includes(name) || 'onlyNames' in sendVariableValues && !sendVariableValues.onlyNames.includes(name)) {
            details.variablesJson[name] = '';
        } else {
            try {
                details.variablesJson[name] = typeof variablesToRecord[name] === 'undefined' ? '' : JSON.stringify(variablesToRecord[name]);
            } catch (e) {
                details.variablesJson[name] = JSON.stringify('[Unable to convert value to JSON]');
            }
        }
    });
    return details;
}
exports.makeTraceDetails = makeTraceDetails;
function handleVariableValueTransformError(variableNames) {
    const modifiedVariables = Object.create(null);
    variableNames.forEach((name)=>{
        modifiedVariables[name] = '[PREDICATE_FUNCTION_ERROR]';
    });
    return modifiedVariables;
}
function cleanModifiedVariables(originalKeys, modifiedVariables) {
    const cleanedVariables = Object.create(null);
    originalKeys.forEach((name)=>{
        cleanedVariables[name] = modifiedVariables[name];
    });
    return cleanedVariables;
} //# sourceMappingURL=traceDetails.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/gql.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.gql = void 0;
const graphql_tag_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/graphql-tag/lib/index.js [app-route] (ecmascript)"));
exports.gql = graphql_tag_1.default; //# sourceMappingURL=gql.js.map
}}),
"[project]/node_modules/apollo-server-core/package.json (json)": ((__turbopack_context__) => {

__turbopack_context__.v(JSON.parse("{\"name\":\"apollo-server-core\",\"version\":\"3.13.0\",\"description\":\"Core engine for Apollo GraphQL server\",\"main\":\"dist/index.js\",\"types\":\"dist/index.d.ts\",\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/apollographql/apollo-server\",\"directory\":\"packages/apollo-server-core\"},\"keywords\":[\"GraphQL\",\"Apollo\",\"Server\",\"Javascript\"],\"author\":\"Apollo <packages@apollographql.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/apollographql/apollo-server/issues\"},\"homepage\":\"https://github.com/apollographql/apollo-server#readme\",\"engines\":{\"node\":\">=12.0\"},\"dependencies\":{\"@apollo/utils.keyvaluecache\":\"^1.0.1\",\"@apollo/utils.logger\":\"^1.0.0\",\"@apollo/utils.usagereporting\":\"^1.0.0\",\"@apollographql/apollo-tools\":\"^0.5.3\",\"@apollographql/graphql-playground-html\":\"1.6.29\",\"@graphql-tools/mock\":\"^8.1.2\",\"@graphql-tools/schema\":\"^8.0.0\",\"@josephg/resolvable\":\"^1.0.0\",\"apollo-datasource\":\"^3.3.2\",\"apollo-reporting-protobuf\":\"^3.4.0\",\"apollo-server-env\":\"^4.2.1\",\"apollo-server-errors\":\"^3.3.1\",\"apollo-server-plugin-base\":\"^3.7.2\",\"apollo-server-types\":\"^3.8.0\",\"async-retry\":\"^1.2.1\",\"fast-json-stable-stringify\":\"^2.1.0\",\"graphql-tag\":\"^2.11.0\",\"loglevel\":\"^1.6.8\",\"lru-cache\":\"^6.0.0\",\"node-abort-controller\":\"^3.0.1\",\"sha.js\":\"^2.4.11\",\"uuid\":\"^9.0.0\",\"whatwg-mimetype\":\"^3.0.0\"},\"peerDependencies\":{\"graphql\":\"^15.3.0 || ^16.0.0\"},\"gitHead\":\"f93284e853efd6da46d91ae40da47a2dd15b61fe\"}"));}),
"[project]/node_modules/apollo-server-core/dist/plugin/schemaReporting/schemaReporter.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SchemaReporter = exports.schemaReportGql = void 0;
const gql_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/gql.js [app-route] (ecmascript)");
const apollo_server_env_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-env/dist/index.js [app-route] (ecmascript)");
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
exports.schemaReportGql = (0, graphql_1.print)((0, gql_1.gql)`
  mutation SchemaReport($report: SchemaReport!, $coreSchema: String) {
    reportSchema(report: $report, coreSchema: $coreSchema) {
      __typename
      ... on ReportSchemaError {
        message
        code
      }
      ... on ReportSchemaResponse {
        inSeconds
        withCoreSchema
      }
    }
  }
`);
class SchemaReporter {
    constructor(options){
        var _a;
        this.headers = new apollo_server_env_1.Headers();
        this.headers.set('Content-Type', 'application/json');
        this.headers.set('x-api-key', options.apiKey);
        this.headers.set('apollographql-client-name', 'ApolloServerPluginSchemaReporting');
        this.headers.set('apollographql-client-version', __turbopack_context__.r("[project]/node_modules/apollo-server-core/package.json (json)").version);
        this.endpointUrl = options.endpointUrl || 'https://schema-reporting.api.apollographql.com/api/graphql';
        this.schemaReport = options.schemaReport;
        this.coreSchema = options.coreSchema;
        this.isStopped = false;
        this.logger = options.logger;
        this.initialReportingDelayInMs = options.initialReportingDelayInMs;
        this.fallbackReportingDelayInMs = options.fallbackReportingDelayInMs;
        this.fetcher = (_a = options.fetcher) !== null && _a !== void 0 ? _a : apollo_server_env_1.fetch;
    }
    stopped() {
        return this.isStopped;
    }
    start() {
        this.pollTimer = setTimeout(()=>this.sendOneReportAndScheduleNext(false), this.initialReportingDelayInMs);
    }
    stop() {
        this.isStopped = true;
        if (this.pollTimer) {
            clearTimeout(this.pollTimer);
            this.pollTimer = undefined;
        }
    }
    async sendOneReportAndScheduleNext(sendNextWithCoreSchema) {
        this.pollTimer = undefined;
        if (this.stopped()) return;
        try {
            const result = await this.reportSchema(sendNextWithCoreSchema);
            if (!result) {
                return;
            }
            if (!this.stopped()) {
                this.pollTimer = setTimeout(()=>this.sendOneReportAndScheduleNext(result.withCoreSchema), result.inSeconds * 1000);
            }
            return;
        } catch (error) {
            this.logger.error(`Error reporting server info to Apollo during schema reporting: ${error}`);
            if (!this.stopped()) {
                this.pollTimer = setTimeout(()=>this.sendOneReportAndScheduleNext(false), this.fallbackReportingDelayInMs);
            }
        }
    }
    async reportSchema(withCoreSchema) {
        const { data, errors } = await this.apolloQuery({
            report: this.schemaReport,
            coreSchema: withCoreSchema ? this.coreSchema : null
        });
        if (errors) {
            throw new Error(errors.map((x)=>x.message).join('\n'));
        }
        function msgForUnexpectedResponse(data) {
            return [
                'Unexpected response shape from Apollo when',
                'reporting schema. If this continues, please reach',
                'out to support@apollographql.com.',
                'Received response:',
                JSON.stringify(data)
            ].join(' ');
        }
        if (!data || !data.reportSchema) {
            throw new Error(msgForUnexpectedResponse(data));
        }
        if (data.reportSchema.__typename === 'ReportSchemaResponse') {
            return data.reportSchema;
        } else if (data.reportSchema.__typename === 'ReportSchemaError') {
            this.logger.error([
                'Received input validation error from Apollo:',
                data.reportSchema.message,
                'Stopping reporting. Please fix the input errors.'
            ].join(' '));
            this.stop();
            return null;
        }
        throw new Error(msgForUnexpectedResponse(data));
    }
    async apolloQuery(variables) {
        const request = {
            query: exports.schemaReportGql,
            variables
        };
        const httpRequest = new apollo_server_env_1.Request(this.endpointUrl, {
            method: 'POST',
            headers: this.headers,
            body: JSON.stringify(request)
        });
        const httpResponse = await this.fetcher(httpRequest);
        if (!httpResponse.ok) {
            throw new Error([
                `An unexpected HTTP status code (${httpResponse.status}) was`,
                'encountered during schema reporting.'
            ].join(' '));
        }
        try {
            return await httpResponse.json();
        } catch (error) {
            throw new Error([
                "Couldn't report schema to Apollo.",
                'Parsing response as JSON failed.',
                'If this continues please reach out to support@apollographql.com',
                error
            ].join(' '));
        }
    }
}
exports.SchemaReporter = SchemaReporter; //# sourceMappingURL=schemaReporter.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/schemaIsFederated.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.schemaIsFederated = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
function schemaIsFederated(schema) {
    const serviceType = schema.getType('_Service');
    if (!(0, graphql_1.isObjectType)(serviceType)) {
        return false;
    }
    const sdlField = serviceType.getFields().sdl;
    if (!sdlField) {
        return false;
    }
    const sdlFieldType = sdlField.type;
    if (!(0, graphql_1.isScalarType)(sdlFieldType)) {
        return false;
    }
    return sdlFieldType.name == 'String';
}
exports.schemaIsFederated = schemaIsFederated; //# sourceMappingURL=schemaIsFederated.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/schemaReporting/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.computeCoreSchemaHash = exports.ApolloServerPluginSchemaReporting = void 0;
const os_1 = __importDefault(__turbopack_context__.r("[externals]/os [external] (os, cjs)"));
const uuid_1 = __turbopack_context__.r("[project]/node_modules/uuid/dist/esm-node/index.js [app-route] (ecmascript)");
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const schemaReporter_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/schemaReporting/schemaReporter.js [app-route] (ecmascript)");
const createSHA_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/utils/createSHA.js [app-route] (ecmascript)"));
const schemaIsFederated_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/schemaIsFederated.js [app-route] (ecmascript)");
function ApolloServerPluginSchemaReporting({ initialDelayMaxMs, overrideReportedSchema, endpointUrl, fetcher } = Object.create(null)) {
    const bootId = (0, uuid_1.v4)();
    return {
        __internal_plugin_id__ () {
            return 'SchemaReporting';
        },
        async serverWillStart ({ apollo, schema, logger }) {
            const { key, graphRef } = apollo;
            if (!key) {
                throw Error('To use ApolloServerPluginSchemaReporting, you must provide an Apollo API ' + 'key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})`');
            }
            if (!graphRef) {
                throw Error('To use ApolloServerPluginSchemaReporting, you must provide your graph ref (eg, ' + "'my-graph-id@my-graph-variant'). Try setting the APOLLO_GRAPH_REF environment " + 'variable or passing `new ApolloServer({apollo: {graphRef}})`.');
            }
            if (overrideReportedSchema) {
                try {
                    const validationErrors = (0, graphql_1.validateSchema)((0, graphql_1.buildSchema)(overrideReportedSchema, {
                        noLocation: true
                    }));
                    if (validationErrors.length) {
                        throw new Error(validationErrors.map((error)=>error.message).join('\n'));
                    }
                } catch (err) {
                    throw new Error('The schema provided to overrideReportedSchema failed to parse or ' + `validate: ${err.message}`);
                }
            }
            if ((0, schemaIsFederated_1.schemaIsFederated)(schema)) {
                throw Error([
                    'Schema reporting is not yet compatible with federated services.',
                    "If you're interested in using schema reporting with federated",
                    'services, please contact Apollo support. To set up managed federation, see',
                    'https://go.apollo.dev/s/managed-federation'
                ].join(' '));
            }
            if (endpointUrl !== undefined) {
                logger.info(`Apollo schema reporting: schema reporting URL override: ${endpointUrl}`);
            }
            const baseSchemaReport = {
                bootId,
                graphRef,
                platform: process.env.APOLLO_SERVER_PLATFORM || 'local',
                runtimeVersion: `node ${process.version}`,
                userVersion: process.env.APOLLO_SERVER_USER_VERSION,
                serverId: process.env.APOLLO_SERVER_ID || process.env.HOSTNAME || os_1.default.hostname(),
                libraryVersion: `apollo-server-core@${__turbopack_context__.r("[project]/node_modules/apollo-server-core/package.json (json)").version}`
            };
            let currentSchemaReporter;
            return {
                schemaDidLoadOrUpdate ({ apiSchema, coreSupergraphSdl }) {
                    var _a;
                    if (overrideReportedSchema !== undefined) {
                        if (currentSchemaReporter) {
                            return;
                        } else {
                            logger.info('Apollo schema reporting: schema to report has been overridden');
                        }
                    }
                    const coreSchema = (_a = overrideReportedSchema !== null && overrideReportedSchema !== void 0 ? overrideReportedSchema : coreSupergraphSdl) !== null && _a !== void 0 ? _a : (0, graphql_1.printSchema)(apiSchema);
                    const coreSchemaHash = computeCoreSchemaHash(coreSchema);
                    const schemaReport = {
                        ...baseSchemaReport,
                        coreSchemaHash
                    };
                    currentSchemaReporter === null || currentSchemaReporter === void 0 ? void 0 : currentSchemaReporter.stop();
                    currentSchemaReporter = new schemaReporter_1.SchemaReporter({
                        schemaReport,
                        coreSchema,
                        apiKey: key,
                        endpointUrl,
                        logger,
                        initialReportingDelayInMs: Math.floor(Math.random() * (initialDelayMaxMs !== null && initialDelayMaxMs !== void 0 ? initialDelayMaxMs : 10000)),
                        fallbackReportingDelayInMs: 20000,
                        fetcher
                    });
                    currentSchemaReporter.start();
                    logger.info('Apollo schema reporting: reporting a new schema to Studio! See your graph at ' + `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/ with server info ${JSON.stringify(schemaReport)}`);
                },
                async serverWillStop () {
                    currentSchemaReporter === null || currentSchemaReporter === void 0 ? void 0 : currentSchemaReporter.stop();
                }
            };
        }
    };
}
exports.ApolloServerPluginSchemaReporting = ApolloServerPluginSchemaReporting;
function computeCoreSchemaHash(schema) {
    return (0, createSHA_1.default)('sha256').update(schema).digest('hex');
}
exports.computeCoreSchemaHash = computeCoreSchemaHash; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/durationHistogram.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DurationHistogram = void 0;
class DurationHistogram {
    constructor(options){
        const initSize = (options === null || options === void 0 ? void 0 : options.initSize) || 74;
        const buckets = options === null || options === void 0 ? void 0 : options.buckets;
        const arrayInitSize = Math.max((buckets === null || buckets === void 0 ? void 0 : buckets.length) || 0, initSize);
        this.buckets = Array(arrayInitSize).fill(0);
        if (buckets) {
            buckets.forEach((val, index)=>this.buckets[index] = val);
        }
    }
    toArray() {
        let bufferedZeroes = 0;
        const outputArray = [];
        for (const value of this.buckets){
            if (value === 0) {
                bufferedZeroes++;
            } else {
                if (bufferedZeroes === 1) {
                    outputArray.push(0);
                } else if (bufferedZeroes !== 0) {
                    outputArray.push(-bufferedZeroes);
                }
                outputArray.push(Math.floor(value));
                bufferedZeroes = 0;
            }
        }
        return outputArray;
    }
    static durationToBucket(durationNs) {
        const log = Math.log(durationNs / 1000.0);
        const unboundedBucket = Math.ceil(log / DurationHistogram.EXPONENT_LOG);
        return unboundedBucket <= 0 || Number.isNaN(unboundedBucket) ? 0 : unboundedBucket >= DurationHistogram.BUCKET_COUNT ? DurationHistogram.BUCKET_COUNT - 1 : unboundedBucket;
    }
    incrementDuration(durationNs, value = 1) {
        this.incrementBucket(DurationHistogram.durationToBucket(durationNs), value);
        return this;
    }
    incrementBucket(bucket, value = 1) {
        if (bucket >= DurationHistogram.BUCKET_COUNT) {
            throw Error('Bucket is out of bounds of the buckets array');
        }
        if (bucket >= this.buckets.length) {
            const oldLength = this.buckets.length;
            this.buckets.length = bucket + 1;
            this.buckets.fill(0, oldLength);
        }
        this.buckets[bucket] += value;
    }
    combine(otherHistogram) {
        for(let i = 0; i < otherHistogram.buckets.length; i++){
            this.incrementBucket(i, otherHistogram.buckets[i]);
        }
    }
}
exports.DurationHistogram = DurationHistogram;
DurationHistogram.BUCKET_COUNT = 384;
DurationHistogram.EXPONENT_LOG = Math.log(1.1); //# sourceMappingURL=durationHistogram.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/iterateOverTrace.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.iterateOverTrace = void 0;
function iterateOverTrace(trace, f, includePath) {
    const rootPath = includePath ? new RootCollectingPathsResponseNamePath() : notCollectingPathsResponseNamePath;
    if (trace.root) {
        if (iterateOverTraceNode(trace.root, rootPath, f)) return;
    }
    if (trace.queryPlan) {
        if (iterateOverQueryPlan(trace.queryPlan, rootPath, f)) return;
    }
}
exports.iterateOverTrace = iterateOverTrace;
function iterateOverQueryPlan(node, rootPath, f) {
    var _a, _b, _c, _d, _e;
    if (!node) return false;
    if (((_b = (_a = node.fetch) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.root) && node.fetch.serviceName) {
        return iterateOverTraceNode(node.fetch.trace.root, rootPath.child(`service:${node.fetch.serviceName}`), f);
    }
    if ((_c = node.flatten) === null || _c === void 0 ? void 0 : _c.node) {
        return iterateOverQueryPlan(node.flatten.node, rootPath, f);
    }
    if ((_d = node.parallel) === null || _d === void 0 ? void 0 : _d.nodes) {
        return node.parallel.nodes.some((node)=>iterateOverQueryPlan(node, rootPath, f));
    }
    if ((_e = node.sequence) === null || _e === void 0 ? void 0 : _e.nodes) {
        return node.sequence.nodes.some((node)=>iterateOverQueryPlan(node, rootPath, f));
    }
    return false;
}
function iterateOverTraceNode(node, path, f) {
    var _a, _b;
    if (f(node, path)) {
        return true;
    }
    return (_b = (_a = node.child) === null || _a === void 0 ? void 0 : _a.some((child)=>{
        const childPath = child.responseName ? path.child(child.responseName) : path;
        return iterateOverTraceNode(child, childPath, f);
    })) !== null && _b !== void 0 ? _b : false;
}
const notCollectingPathsResponseNamePath = {
    toArray () {
        throw Error('not collecting paths!');
    },
    child () {
        return this;
    }
};
class RootCollectingPathsResponseNamePath {
    toArray() {
        return [];
    }
    child(responseName) {
        return new ChildCollectingPathsResponseNamePath(responseName, this);
    }
}
class ChildCollectingPathsResponseNamePath {
    constructor(responseName, prev){
        this.responseName = responseName;
        this.prev = prev;
    }
    toArray() {
        const out = [];
        let curr = this;
        while(curr instanceof ChildCollectingPathsResponseNamePath){
            out.push(curr.responseName);
            curr = curr.prev;
        }
        return out.reverse();
    }
    child(responseName) {
        return new ChildCollectingPathsResponseNamePath(responseName, this);
    }
} //# sourceMappingURL=iterateOverTrace.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/stats.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OurContextualizedStats = exports.OurReport = exports.SizeEstimator = void 0;
const durationHistogram_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/durationHistogram.js [app-route] (ecmascript)");
const apollo_reporting_protobuf_1 = __turbopack_context__.r("[project]/node_modules/apollo-reporting-protobuf/generated/index.js [app-route] (ecmascript)");
const iterateOverTrace_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/iterateOverTrace.js [app-route] (ecmascript)");
class SizeEstimator {
    constructor(){
        this.bytes = 0;
    }
}
exports.SizeEstimator = SizeEstimator;
class OurReport {
    constructor(header){
        this.header = header;
        this.tracesPreAggregated = false;
        this.tracesPerQuery = Object.create(null);
        this.endTime = null;
        this.operationCount = 0;
        this.sizeEstimator = new SizeEstimator();
    }
    ensureCountsAreIntegers() {
        for (const tracesAndStats of Object.values(this.tracesPerQuery)){
            tracesAndStats.ensureCountsAreIntegers();
        }
    }
    addTrace({ statsReportKey, trace, asTrace, includeTracesContributingToStats, referencedFieldsByType }) {
        const tracesAndStats = this.getTracesAndStats({
            statsReportKey,
            referencedFieldsByType
        });
        if (asTrace) {
            const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();
            tracesAndStats.trace.push(encodedTrace);
            this.sizeEstimator.bytes += 2 + encodedTrace.length;
        } else {
            tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);
            if (includeTracesContributingToStats) {
                const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();
                tracesAndStats.internalTracesContributingToStats.push(encodedTrace);
                this.sizeEstimator.bytes += 2 + encodedTrace.length;
            }
        }
    }
    getTracesAndStats({ statsReportKey, referencedFieldsByType }) {
        const existing = this.tracesPerQuery[statsReportKey];
        if (existing) {
            return existing;
        }
        this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);
        for (const [typeName, referencedFieldsForType] of Object.entries(referencedFieldsByType)){
            this.sizeEstimator.bytes += 2 + 2;
            if (referencedFieldsForType.isInterface) {
                this.sizeEstimator.bytes += 2;
            }
            this.sizeEstimator.bytes += estimatedBytesForString(typeName);
            for (const fieldName of referencedFieldsForType.fieldNames){
                this.sizeEstimator.bytes += estimatedBytesForString(fieldName);
            }
        }
        return this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(referencedFieldsByType);
    }
}
exports.OurReport = OurReport;
class OurTracesAndStats {
    constructor(referencedFieldsByType){
        this.referencedFieldsByType = referencedFieldsByType;
        this.trace = [];
        this.statsWithContext = new StatsByContext();
        this.internalTracesContributingToStats = [];
    }
    ensureCountsAreIntegers() {
        this.statsWithContext.ensureCountsAreIntegers();
    }
}
class StatsByContext {
    constructor(){
        this.map = Object.create(null);
    }
    toArray() {
        return Object.values(this.map);
    }
    ensureCountsAreIntegers() {
        for (const contextualizedStats of Object.values(this.map)){
            contextualizedStats.ensureCountsAreIntegers();
        }
    }
    addTrace(trace, sizeEstimator) {
        this.getContextualizedStats(trace, sizeEstimator).addTrace(trace, sizeEstimator);
    }
    getContextualizedStats(trace, sizeEstimator) {
        const statsContext = {
            clientName: trace.clientName,
            clientVersion: trace.clientVersion
        };
        const statsContextKey = JSON.stringify(statsContext);
        const existing = this.map[statsContextKey];
        if (existing) {
            return existing;
        }
        sizeEstimator.bytes += 20 + estimatedBytesForString(trace.clientName) + estimatedBytesForString(trace.clientVersion);
        const contextualizedStats = new OurContextualizedStats(statsContext);
        this.map[statsContextKey] = contextualizedStats;
        return contextualizedStats;
    }
}
class OurContextualizedStats {
    constructor(context){
        this.context = context;
        this.queryLatencyStats = new OurQueryLatencyStats();
        this.perTypeStat = Object.create(null);
    }
    ensureCountsAreIntegers() {
        for (const typeStat of Object.values(this.perTypeStat)){
            typeStat.ensureCountsAreIntegers();
        }
    }
    addTrace(trace, sizeEstimator) {
        var _a;
        const { fieldExecutionWeight } = trace;
        if (!fieldExecutionWeight) {
            this.queryLatencyStats.requestsWithoutFieldInstrumentation++;
        }
        this.queryLatencyStats.requestCount++;
        if (trace.fullQueryCacheHit) {
            this.queryLatencyStats.cacheLatencyCount.incrementDuration(trace.durationNs);
            this.queryLatencyStats.cacheHits++;
        } else {
            this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);
        }
        if (!trace.fullQueryCacheHit && ((_a = trace.cachePolicy) === null || _a === void 0 ? void 0 : _a.maxAgeNs) != null) {
            switch(trace.cachePolicy.scope){
                case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE:
                    this.queryLatencyStats.privateCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);
                    break;
                case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC:
                    this.queryLatencyStats.publicCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);
                    break;
            }
        }
        if (trace.persistedQueryHit) {
            this.queryLatencyStats.persistedQueryHits++;
        }
        if (trace.persistedQueryRegister) {
            this.queryLatencyStats.persistedQueryMisses++;
        }
        if (trace.forbiddenOperation) {
            this.queryLatencyStats.forbiddenOperationCount++;
        }
        if (trace.registeredOperation) {
            this.queryLatencyStats.registeredOperationCount++;
        }
        let hasError = false;
        const traceNodeStats = (node, path)=>{
            var _a, _b, _c, _d, _e;
            if ((_a = node.error) === null || _a === void 0 ? void 0 : _a.length) {
                hasError = true;
                let currPathErrorStats = this.queryLatencyStats.rootErrorStats;
                path.toArray().forEach((subPath)=>{
                    currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);
                });
                currPathErrorStats.requestsWithErrorsCount += 1;
                currPathErrorStats.errorsCount += node.error.length;
            }
            if (fieldExecutionWeight) {
                const fieldName = node.originalFieldName || node.responseName;
                if (node.parentType && fieldName && node.type && node.endTime != null && node.startTime != null && node.endTime >= node.startTime) {
                    const typeStat = this.getTypeStat(node.parentType, sizeEstimator);
                    const fieldStat = typeStat.getFieldStat(fieldName, node.type, sizeEstimator);
                    fieldStat.errorsCount += (_c = (_b = node.error) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
                    fieldStat.observedExecutionCount++;
                    fieldStat.estimatedExecutionCount += fieldExecutionWeight;
                    fieldStat.requestsWithErrorsCount += ((_e = (_d = node.error) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) > 0 ? 1 : 0;
                    fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime, fieldExecutionWeight);
                }
            }
            return false;
        };
        (0, iterateOverTrace_1.iterateOverTrace)(trace, traceNodeStats, true);
        if (hasError) {
            this.queryLatencyStats.requestsWithErrorsCount++;
        }
    }
    getTypeStat(parentType, sizeEstimator) {
        const existing = this.perTypeStat[parentType];
        if (existing) {
            return existing;
        }
        sizeEstimator.bytes += estimatedBytesForString(parentType);
        const typeStat = new OurTypeStat();
        this.perTypeStat[parentType] = typeStat;
        return typeStat;
    }
}
exports.OurContextualizedStats = OurContextualizedStats;
class OurQueryLatencyStats {
    constructor(){
        this.latencyCount = new durationHistogram_1.DurationHistogram();
        this.requestCount = 0;
        this.requestsWithoutFieldInstrumentation = 0;
        this.cacheHits = 0;
        this.persistedQueryHits = 0;
        this.persistedQueryMisses = 0;
        this.cacheLatencyCount = new durationHistogram_1.DurationHistogram();
        this.rootErrorStats = new OurPathErrorStats();
        this.requestsWithErrorsCount = 0;
        this.publicCacheTtlCount = new durationHistogram_1.DurationHistogram();
        this.privateCacheTtlCount = new durationHistogram_1.DurationHistogram();
        this.registeredOperationCount = 0;
        this.forbiddenOperationCount = 0;
    }
}
class OurPathErrorStats {
    constructor(){
        this.children = Object.create(null);
        this.errorsCount = 0;
        this.requestsWithErrorsCount = 0;
    }
    getChild(subPath, sizeEstimator) {
        const existing = this.children[subPath];
        if (existing) {
            return existing;
        }
        const child = new OurPathErrorStats();
        this.children[subPath] = child;
        sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;
        return child;
    }
}
class OurTypeStat {
    constructor(){
        this.perFieldStat = Object.create(null);
    }
    getFieldStat(fieldName, returnType, sizeEstimator) {
        const existing = this.perFieldStat[fieldName];
        if (existing) {
            return existing;
        }
        sizeEstimator.bytes += estimatedBytesForString(fieldName) + estimatedBytesForString(returnType) + 10;
        const fieldStat = new OurFieldStat(returnType);
        this.perFieldStat[fieldName] = fieldStat;
        return fieldStat;
    }
    ensureCountsAreIntegers() {
        for (const fieldStat of Object.values(this.perFieldStat)){
            fieldStat.ensureCountsAreIntegers();
        }
    }
}
class OurFieldStat {
    constructor(returnType){
        this.returnType = returnType;
        this.errorsCount = 0;
        this.observedExecutionCount = 0;
        this.estimatedExecutionCount = 0;
        this.requestsWithErrorsCount = 0;
        this.latencyCount = new durationHistogram_1.DurationHistogram();
    }
    ensureCountsAreIntegers() {
        this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);
    }
}
function estimatedBytesForString(s) {
    return 2 + Buffer.byteLength(s);
} //# sourceMappingURL=stats.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/defaultSendOperationsAsTrace.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defaultSendOperationsAsTrace = void 0;
const lru_cache_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/lru-cache/index.js [app-route] (ecmascript)"));
const iterateOverTrace_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/iterateOverTrace.js [app-route] (ecmascript)");
const durationHistogram_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/durationHistogram.js [app-route] (ecmascript)");
function defaultSendOperationsAsTrace() {
    const cache = new lru_cache_1.default({
        max: Math.pow(2, 20),
        length: (_val, key)=>{
            return key && Buffer.byteLength(key) || 0;
        }
    });
    return (trace, statsReportKey)=>{
        var _a;
        const endTimeSeconds = (_a = trace.endTime) === null || _a === void 0 ? void 0 : _a.seconds;
        if (endTimeSeconds == null) {
            throw Error('programming error: endTime not set on trace');
        }
        const hasErrors = traceHasErrors(trace);
        const cacheKey = JSON.stringify([
            statsReportKey,
            durationHistogram_1.DurationHistogram.durationToBucket(trace.durationNs),
            Math.floor(endTimeSeconds / 60),
            hasErrors ? Math.floor(endTimeSeconds / 5) : ''
        ]);
        if (cache.get(cacheKey)) {
            return false;
        }
        cache.set(cacheKey, true);
        return true;
    };
}
exports.defaultSendOperationsAsTrace = defaultSendOperationsAsTrace;
function traceHasErrors(trace) {
    let hasErrors = false;
    function traceNodeStats(node) {
        var _a, _b;
        if (((_b = (_a = node.error) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0) {
            hasErrors = true;
        }
        return hasErrors;
    }
    (0, iterateOverTrace_1.iterateOverTrace)(trace, traceNodeStats, false);
    return hasErrors;
} //# sourceMappingURL=defaultSendOperationsAsTrace.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/plugin.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApolloServerPluginUsageReportingDisabled = exports.makeHTTPRequestHeaders = exports.ApolloServerPluginUsageReporting = void 0;
const os_1 = __importDefault(__turbopack_context__.r("[externals]/os [external] (os, cjs)"));
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const zlib_1 = __turbopack_context__.r("[externals]/zlib [external] (zlib, cjs)");
const async_retry_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/async-retry/lib/index.js [app-route] (ecmascript)"));
const apollo_reporting_protobuf_1 = __turbopack_context__.r("[project]/node_modules/apollo-reporting-protobuf/generated/index.js [app-route] (ecmascript)");
const apollo_server_env_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-env/dist/index.js [app-route] (ecmascript)");
const node_abort_controller_1 = __turbopack_context__.r("[project]/node_modules/node-abort-controller/index.js [app-route] (ecmascript)");
const apollo_server_types_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-types/dist/index.js [app-route] (ecmascript)");
const operationDerivedDataCache_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/operationDerivedDataCache.js [app-route] (ecmascript)");
const utils_usagereporting_1 = __turbopack_context__.r("[project]/node_modules/@apollo/utils.usagereporting/dist/index.js [app-route] (ecmascript)");
const traceTreeBuilder_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/traceTreeBuilder.js [app-route] (ecmascript)");
const traceDetails_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/traceDetails.js [app-route] (ecmascript)");
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const schemaReporting_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/schemaReporting/index.js [app-route] (ecmascript)");
const stats_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/stats.js [app-route] (ecmascript)");
const defaultSendOperationsAsTrace_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/defaultSendOperationsAsTrace.js [app-route] (ecmascript)");
const utils_usagereporting_2 = __turbopack_context__.r("[project]/node_modules/@apollo/utils.usagereporting/dist/index.js [app-route] (ecmascript)");
const gzipPromise = (0, util_1.promisify)(zlib_1.gzip);
const reportHeaderDefaults = {
    hostname: os_1.default.hostname(),
    agentVersion: `apollo-server-core@${__turbopack_context__.r("[project]/node_modules/apollo-server-core/package.json (json)").version}`,
    runtimeVersion: `node ${process.version}`,
    uname: `${os_1.default.platform()}, ${os_1.default.type()}, ${os_1.default.release()}, ${os_1.default.arch()})`
};
function ApolloServerPluginUsageReporting(options = Object.create(null)) {
    const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;
    const fieldLevelInstrumentation = typeof fieldLevelInstrumentationOption === 'number' ? async ()=>Math.random() < fieldLevelInstrumentationOption ? 1 / fieldLevelInstrumentationOption : 0 : fieldLevelInstrumentationOption ? fieldLevelInstrumentationOption : async ()=>true;
    let requestDidStartHandler;
    return {
        __internal_plugin_id__ () {
            return 'UsageReporting';
        },
        async requestDidStart (requestContext) {
            if (!requestDidStartHandler) {
                throw Error('The usage reporting plugin has been asked to handle a request before the ' + 'server has started. See https://github.com/apollographql/apollo-server/issues/4588 ' + 'for more details.');
            }
            return requestDidStartHandler(requestContext);
        },
        async serverWillStart ({ logger: serverLogger, apollo, serverlessFramework }) {
            var _a, _b, _c, _d;
            const logger = (_a = options.logger) !== null && _a !== void 0 ? _a : serverLogger;
            const { key, graphRef } = apollo;
            if (!(key && graphRef)) {
                throw new Error("You've enabled usage reporting via ApolloServerPluginUsageReporting, " + 'but you also need to provide your Apollo API key and graph ref, via ' + 'the APOLLO_KEY/APOLLO_GRAPH_REF environment ' + 'variables or via `new ApolloServer({apollo: {key, graphRef})`.');
            }
            logger.info('Apollo usage reporting starting! See your graph at ' + `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`);
            const sendReportsImmediately = (_b = options.sendReportsImmediately) !== null && _b !== void 0 ? _b : serverlessFramework;
            let operationDerivedDataCache = null;
            const reportByExecutableSchemaId = new Map();
            const getReportWhichMustBeUsedImmediately = (executableSchemaId)=>{
                const existing = reportByExecutableSchemaId.get(executableSchemaId);
                if (existing) {
                    return existing;
                }
                const report = new stats_1.OurReport(new apollo_reporting_protobuf_1.ReportHeader({
                    ...reportHeaderDefaults,
                    executableSchemaId,
                    graphRef
                }));
                reportByExecutableSchemaId.set(executableSchemaId, report);
                return report;
            };
            const getAndDeleteReport = (executableSchemaId)=>{
                const report = reportByExecutableSchemaId.get(executableSchemaId);
                if (report) {
                    reportByExecutableSchemaId.delete(executableSchemaId);
                    return report;
                }
                return null;
            };
            const overriddenExecutableSchemaId = options.overrideReportedSchema ? (0, schemaReporting_1.computeCoreSchemaHash)(options.overrideReportedSchema) : undefined;
            let lastSeenExecutableSchemaToId;
            let reportTimer;
            if (!sendReportsImmediately) {
                reportTimer = setInterval(()=>sendAllReportsAndReportErrors(), options.reportIntervalMs || 10 * 1000);
            }
            let graphMightSupportTraces = true;
            const sendOperationAsTrace = (_c = options.experimental_sendOperationAsTrace) !== null && _c !== void 0 ? _c : (0, defaultSendOperationsAsTrace_1.defaultSendOperationsAsTrace)();
            const includeTracesContributingToStats = (_d = options.internal_includeTracesContributingToStats) !== null && _d !== void 0 ? _d : false;
            let stopped = false;
            function executableSchemaIdForSchema(schema) {
                if ((lastSeenExecutableSchemaToId === null || lastSeenExecutableSchemaToId === void 0 ? void 0 : lastSeenExecutableSchemaToId.executableSchema) === schema) {
                    return lastSeenExecutableSchemaToId.executableSchemaId;
                }
                const id = (0, schemaReporting_1.computeCoreSchemaHash)((0, graphql_1.printSchema)(schema));
                lastSeenExecutableSchemaToId = {
                    executableSchema: schema,
                    executableSchemaId: id
                };
                return id;
            }
            async function sendAllReportsAndReportErrors() {
                await Promise.all([
                    ...reportByExecutableSchemaId.keys()
                ].map((executableSchemaId)=>sendReportAndReportErrors(executableSchemaId)));
            }
            async function sendReportAndReportErrors(executableSchemaId) {
                return sendReport(executableSchemaId).catch((err)=>{
                    if (options.reportErrorFunction) {
                        options.reportErrorFunction(err);
                    } else {
                        logger.error(err.message);
                    }
                });
            }
            const sendReport = async (executableSchemaId)=>{
                var _a, _b;
                let report = getAndDeleteReport(executableSchemaId);
                if (!report || Object.keys(report.tracesPerQuery).length === 0 && report.operationCount === 0) {
                    return;
                }
                report.endTime = (0, traceTreeBuilder_1.dateToProtoTimestamp)(new Date());
                report.ensureCountsAreIntegers();
                const protobufError = apollo_reporting_protobuf_1.Report.verify(report);
                if (protobufError) {
                    throw new Error(`Error verifying report: ${protobufError}`);
                }
                let message = apollo_reporting_protobuf_1.Report.encode(report).finish();
                report = null;
                if (options.debugPrintReports) {
                    const decodedReport = apollo_reporting_protobuf_1.Report.decode(message);
                    logger.warn(`Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`);
                }
                const compressed = await gzipPromise(message);
                message = null;
                const fetcher = (_a = options.fetcher) !== null && _a !== void 0 ? _a : apollo_server_env_1.fetch;
                const response = await (0, async_retry_1.default)(async ()=>{
                    var _a;
                    const controller = new node_abort_controller_1.AbortController();
                    const abortTimeout = setTimeout(()=>{
                        controller.abort();
                    }, (_a = options.requestTimeoutMs) !== null && _a !== void 0 ? _a : 30000);
                    let curResponse;
                    try {
                        const requestInit = {
                            method: 'POST',
                            headers: {
                                'user-agent': 'ApolloServerPluginUsageReporting',
                                'x-api-key': key,
                                'content-encoding': 'gzip',
                                accept: 'application/json'
                            },
                            body: compressed,
                            agent: options.requestAgent
                        };
                        requestInit.signal = controller.signal;
                        curResponse = await fetcher((options.endpointUrl || 'https://usage-reporting.api.apollographql.com') + '/api/ingress/traces', requestInit);
                    } finally{
                        clearTimeout(abortTimeout);
                    }
                    if (curResponse.status >= 500 && curResponse.status < 600) {
                        throw new Error(`HTTP status ${curResponse.status}, ${await curResponse.text() || '(no body)'}`);
                    } else {
                        return curResponse;
                    }
                }, {
                    retries: (options.maxAttempts || 5) - 1,
                    minTimeout: options.minimumRetryDelayMs || 100,
                    factor: 2
                }).catch((err)=>{
                    throw new Error(`Error sending report to Apollo servers: ${err.message}`);
                });
                if (response.status < 200 || response.status >= 300) {
                    throw new Error(`Error sending report to Apollo servers: HTTP status ${response.status}, ${await response.text() || '(no body)'}`);
                }
                if (graphMightSupportTraces && response.status === 200 && ((_b = response.headers.get('content-type')) === null || _b === void 0 ? void 0 : _b.match(/^\s*application\/json\s*(?:;|$)/i))) {
                    const body = await response.text();
                    let parsedBody;
                    try {
                        parsedBody = JSON.parse(body);
                    } catch (e) {
                        throw new Error(`Error parsing response from Apollo servers: ${e}`);
                    }
                    if (parsedBody.tracesIgnored === true) {
                        logger.debug("This graph's organization does not have access to traces; sending all " + 'subsequent operations as traces.');
                        graphMightSupportTraces = false;
                    }
                }
                if (options.debugPrintReports) {
                    logger.warn(`Apollo usage report: status ${response.status}`);
                }
            };
            requestDidStartHandler = ({ logger: requestLogger, metrics, schema, request: { http, variables } })=>{
                var _a;
                const logger = (_a = requestLogger !== null && requestLogger !== void 0 ? requestLogger : options.logger) !== null && _a !== void 0 ? _a : serverLogger;
                const treeBuilder = new traceTreeBuilder_1.TraceTreeBuilder({
                    rewriteError: options.rewriteError,
                    logger
                });
                treeBuilder.startTiming();
                metrics.startHrTime = treeBuilder.startHrTime;
                let graphqlValidationFailure = false;
                let graphqlUnknownOperationName = false;
                let includeOperationInUsageReporting = null;
                if (http) {
                    treeBuilder.trace.http = new apollo_reporting_protobuf_1.Trace.HTTP({
                        method: apollo_reporting_protobuf_1.Trace.HTTP.Method[http.method] || apollo_reporting_protobuf_1.Trace.HTTP.Method.UNKNOWN
                    });
                    if (options.sendHeaders) {
                        makeHTTPRequestHeaders(treeBuilder.trace.http, http.headers, options.sendHeaders);
                    }
                }
                async function maybeCallIncludeRequestHook(requestContext) {
                    if (includeOperationInUsageReporting !== null) return;
                    if (typeof options.includeRequest !== 'function') {
                        includeOperationInUsageReporting = true;
                        return;
                    }
                    includeOperationInUsageReporting = await options.includeRequest(requestContext);
                    if (typeof includeOperationInUsageReporting !== 'boolean') {
                        logger.warn("The 'includeRequest' async predicate function must return a boolean value.");
                        includeOperationInUsageReporting = true;
                    }
                }
                let didResolveSource = false;
                return {
                    async didResolveSource (requestContext) {
                        didResolveSource = true;
                        if (metrics.persistedQueryHit) {
                            treeBuilder.trace.persistedQueryHit = true;
                        }
                        if (metrics.persistedQueryRegister) {
                            treeBuilder.trace.persistedQueryRegister = true;
                        }
                        if (variables) {
                            treeBuilder.trace.details = (0, traceDetails_1.makeTraceDetails)(variables, options.sendVariableValues, requestContext.source);
                        }
                        const clientInfo = (options.generateClientInfo || defaultGenerateClientInfo)(requestContext);
                        if (clientInfo) {
                            const { clientName, clientVersion } = clientInfo;
                            treeBuilder.trace.clientVersion = clientVersion || '';
                            treeBuilder.trace.clientName = clientName || '';
                        }
                    },
                    async validationDidStart () {
                        return async (validationErrors)=>{
                            graphqlValidationFailure = validationErrors ? validationErrors.length !== 0 : false;
                        };
                    },
                    async didResolveOperation (requestContext) {
                        graphqlUnknownOperationName = requestContext.operation === undefined;
                        await maybeCallIncludeRequestHook(requestContext);
                        if (includeOperationInUsageReporting && !graphqlUnknownOperationName) {
                            if (metrics.captureTraces === undefined) {
                                const rawWeight = await fieldLevelInstrumentation(requestContext);
                                treeBuilder.trace.fieldExecutionWeight = typeof rawWeight === 'number' ? rawWeight : rawWeight ? 1 : 0;
                                metrics.captureTraces = !!treeBuilder.trace.fieldExecutionWeight;
                            }
                        }
                    },
                    async executionDidStart () {
                        if (!metrics.captureTraces) return;
                        return {
                            willResolveField ({ info }) {
                                return treeBuilder.willResolveField(info);
                            }
                        };
                    },
                    async willSendResponse (requestContext) {
                        if (!didResolveSource) return;
                        if (requestContext.errors) {
                            treeBuilder.didEncounterErrors(requestContext.errors);
                        }
                        const resolvedOperation = !!requestContext.operation;
                        await maybeCallIncludeRequestHook(requestContext);
                        treeBuilder.stopTiming();
                        const executableSchemaId = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== void 0 ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);
                        if (includeOperationInUsageReporting === false) {
                            if (resolvedOperation) getReportWhichMustBeUsedImmediately(executableSchemaId).operationCount++;
                            return;
                        }
                        treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;
                        treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;
                        treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;
                        const policyIfCacheable = requestContext.overallCachePolicy.policyIfCacheable();
                        if (policyIfCacheable) {
                            treeBuilder.trace.cachePolicy = new apollo_reporting_protobuf_1.Trace.CachePolicy({
                                scope: policyIfCacheable.scope === apollo_server_types_1.CacheScope.Private ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE : policyIfCacheable.scope === apollo_server_types_1.CacheScope.Public ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC : apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.UNKNOWN,
                                maxAgeNs: policyIfCacheable.maxAge * 1e9
                            });
                        }
                        if (metrics.queryPlanTrace) {
                            treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
                        }
                        addTrace().catch(logger.error);
                        async function addTrace() {
                            if (stopped) {
                                return;
                            }
                            await new Promise((res)=>setImmediate(res));
                            const executableSchemaId = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== void 0 ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);
                            const { trace } = treeBuilder;
                            let statsReportKey = undefined;
                            let referencedFieldsByType;
                            if (!requestContext.document) {
                                statsReportKey = `## GraphQLParseFailure\n`;
                            } else if (graphqlValidationFailure) {
                                statsReportKey = `## GraphQLValidationFailure\n`;
                            } else if (graphqlUnknownOperationName) {
                                statsReportKey = `## GraphQLUnknownOperationName\n`;
                            }
                            const isExecutable = statsReportKey === undefined;
                            if (statsReportKey) {
                                if (options.sendUnexecutableOperationDocuments) {
                                    trace.unexecutedOperationBody = requestContext.source;
                                    trace.unexecutedOperationName = requestContext.request.operationName || '';
                                }
                                referencedFieldsByType = Object.create(null);
                            } else {
                                const operationDerivedData = getOperationDerivedData();
                                statsReportKey = `# ${requestContext.operationName || '-'}\n${operationDerivedData.signature}`;
                                referencedFieldsByType = operationDerivedData.referencedFieldsByType;
                            }
                            const protobufError = apollo_reporting_protobuf_1.Trace.verify(trace);
                            if (protobufError) {
                                throw new Error(`Error encoding trace: ${protobufError}`);
                            }
                            if (resolvedOperation) {
                                getReportWhichMustBeUsedImmediately(executableSchemaId).operationCount++;
                            }
                            getReportWhichMustBeUsedImmediately(executableSchemaId).addTrace({
                                statsReportKey,
                                trace,
                                asTrace: graphMightSupportTraces && (!isExecutable || !!metrics.captureTraces) && sendOperationAsTrace(trace, statsReportKey),
                                includeTracesContributingToStats,
                                referencedFieldsByType
                            });
                            if (sendReportsImmediately || getReportWhichMustBeUsedImmediately(executableSchemaId).sizeEstimator.bytes >= (options.maxUncompressedReportSize || 4 * 1024 * 1024)) {
                                await sendReportAndReportErrors(executableSchemaId);
                            }
                        }
                        function getOperationDerivedData() {
                            var _a;
                            if (!requestContext.document) {
                                throw new Error('No document?');
                            }
                            const cacheKey = (0, operationDerivedDataCache_1.operationDerivedDataCacheKey)(requestContext.queryHash, requestContext.operationName || '');
                            if (!operationDerivedDataCache || operationDerivedDataCache.forSchema !== schema) {
                                operationDerivedDataCache = {
                                    forSchema: schema,
                                    cache: (0, operationDerivedDataCache_1.createOperationDerivedDataCache)({
                                        logger
                                    })
                                };
                            }
                            const cachedOperationDerivedData = operationDerivedDataCache.cache.get(cacheKey);
                            if (cachedOperationDerivedData) {
                                return cachedOperationDerivedData;
                            }
                            const generatedSignature = (options.calculateSignature || utils_usagereporting_1.usageReportingSignature)(requestContext.document, requestContext.operationName || '');
                            const generatedOperationDerivedData = {
                                signature: generatedSignature,
                                referencedFieldsByType: (0, utils_usagereporting_2.calculateReferencedFieldsByType)({
                                    document: requestContext.document,
                                    schema,
                                    resolvedOperationName: (_a = requestContext.operationName) !== null && _a !== void 0 ? _a : null
                                })
                            };
                            operationDerivedDataCache.cache.set(cacheKey, generatedOperationDerivedData);
                            return generatedOperationDerivedData;
                        }
                    }
                };
            };
            return {
                async serverWillStop () {
                    if (reportTimer) {
                        clearInterval(reportTimer);
                        reportTimer = undefined;
                    }
                    stopped = true;
                    await sendAllReportsAndReportErrors();
                }
            };
        }
    };
}
exports.ApolloServerPluginUsageReporting = ApolloServerPluginUsageReporting;
function makeHTTPRequestHeaders(http, headers, sendHeaders) {
    if (!sendHeaders || 'none' in sendHeaders && sendHeaders.none || 'all' in sendHeaders && !sendHeaders.all) {
        return;
    }
    for (const [key, value] of headers){
        const lowerCaseKey = key.toLowerCase();
        if ('exceptNames' in sendHeaders && sendHeaders.exceptNames.some((exceptHeader)=>{
            return exceptHeader.toLowerCase() === lowerCaseKey;
        }) || 'onlyNames' in sendHeaders && !sendHeaders.onlyNames.some((header)=>{
            return header.toLowerCase() === lowerCaseKey;
        })) {
            continue;
        }
        switch(key){
            case 'authorization':
            case 'cookie':
            case 'set-cookie':
                break;
            default:
                http.requestHeaders[key] = new apollo_reporting_protobuf_1.Trace.HTTP.Values({
                    value: [
                        value
                    ]
                });
        }
    }
}
exports.makeHTTPRequestHeaders = makeHTTPRequestHeaders;
function defaultGenerateClientInfo({ request }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const clientNameHeaderKey = 'apollographql-client-name';
    const clientVersionHeaderKey = 'apollographql-client-version';
    if (((_b = (_a = request.http) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b.get(clientNameHeaderKey)) || ((_d = (_c = request.http) === null || _c === void 0 ? void 0 : _c.headers) === null || _d === void 0 ? void 0 : _d.get(clientVersionHeaderKey))) {
        return {
            clientName: (_f = (_e = request.http) === null || _e === void 0 ? void 0 : _e.headers) === null || _f === void 0 ? void 0 : _f.get(clientNameHeaderKey),
            clientVersion: (_h = (_g = request.http) === null || _g === void 0 ? void 0 : _g.headers) === null || _h === void 0 ? void 0 : _h.get(clientVersionHeaderKey)
        };
    } else if ((_j = request.extensions) === null || _j === void 0 ? void 0 : _j.clientInfo) {
        return request.extensions.clientInfo;
    } else {
        return {};
    }
}
function ApolloServerPluginUsageReportingDisabled() {
    return {
        __internal_plugin_id__ () {
            return 'UsageReporting';
        }
    };
}
exports.ApolloServerPluginUsageReportingDisabled = ApolloServerPluginUsageReportingDisabled; //# sourceMappingURL=plugin.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/options.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=options.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApolloServerPluginUsageReportingDisabled = exports.ApolloServerPluginUsageReporting = void 0;
var plugin_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/plugin.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ApolloServerPluginUsageReporting", {
    enumerable: true,
    get: function() {
        return plugin_1.ApolloServerPluginUsageReporting;
    }
});
Object.defineProperty(exports, "ApolloServerPluginUsageReportingDisabled", {
    enumerable: true,
    get: function() {
        return plugin_1.ApolloServerPluginUsageReportingDisabled;
    }
});
var options_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/options.js [app-route] (ecmascript)"); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/inlineTrace/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApolloServerPluginInlineTraceDisabled = exports.ApolloServerPluginInlineTrace = void 0;
const apollo_reporting_protobuf_1 = __turbopack_context__.r("[project]/node_modules/apollo-reporting-protobuf/generated/index.js [app-route] (ecmascript)");
const traceTreeBuilder_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/traceTreeBuilder.js [app-route] (ecmascript)");
const schemaIsFederated_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/schemaIsFederated.js [app-route] (ecmascript)");
function ApolloServerPluginInlineTrace(options = Object.create(null)) {
    let enabled = options.__onlyIfSchemaIsFederated ? null : true;
    return {
        __internal_plugin_id__ () {
            return 'InlineTrace';
        },
        async serverWillStart ({ schema, logger }) {
            if (enabled === null) {
                enabled = (0, schemaIsFederated_1.schemaIsFederated)(schema);
                if (enabled) {
                    logger.info('Enabling inline tracing for this federated service. To disable, use ' + 'ApolloServerPluginInlineTraceDisabled.');
                }
            }
        },
        async requestDidStart ({ request: { http }, metrics }) {
            if (!enabled) {
                return;
            }
            const treeBuilder = new traceTreeBuilder_1.TraceTreeBuilder({
                rewriteError: options.rewriteError
            });
            if ((http === null || http === void 0 ? void 0 : http.headers.get('apollo-federation-include-trace')) !== 'ftv1') {
                return;
            }
            if (metrics.captureTraces === false) {
                return;
            }
            metrics.captureTraces = true;
            treeBuilder.startTiming();
            return {
                async executionDidStart () {
                    return {
                        willResolveField ({ info }) {
                            return treeBuilder.willResolveField(info);
                        }
                    };
                },
                async didEncounterErrors ({ errors }) {
                    treeBuilder.didEncounterErrors(errors);
                },
                async willSendResponse ({ response }) {
                    treeBuilder.stopTiming();
                    if (metrics.queryPlanTrace) {
                        treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
                    }
                    const encodedUint8Array = apollo_reporting_protobuf_1.Trace.encode(treeBuilder.trace).finish();
                    const encodedBuffer = Buffer.from(encodedUint8Array, encodedUint8Array.byteOffset, encodedUint8Array.byteLength);
                    const extensions = response.extensions || (response.extensions = Object.create(null));
                    if (typeof extensions.ftv1 !== 'undefined') {
                        throw new Error('The `ftv1` extension was already present.');
                    }
                    extensions.ftv1 = encodedBuffer.toString('base64');
                }
            };
        }
    };
}
exports.ApolloServerPluginInlineTrace = ApolloServerPluginInlineTrace;
function ApolloServerPluginInlineTraceDisabled() {
    return {
        __internal_plugin_id__ () {
            return 'InlineTrace';
        }
    };
}
exports.ApolloServerPluginInlineTraceDisabled = ApolloServerPluginInlineTraceDisabled; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/cacheControl/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApolloServerPluginCacheControlDisabled = exports.ApolloServerPluginCacheControl = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const cachePolicy_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/cachePolicy.js [app-route] (ecmascript)");
const lru_cache_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/lru-cache/index.js [app-route] (ecmascript)"));
function ApolloServerPluginCacheControl(options = Object.create(null)) {
    const typeAnnotationCache = new lru_cache_1.default();
    const fieldAnnotationCache = new lru_cache_1.default();
    function memoizedCacheAnnotationFromType(t) {
        const existing = typeAnnotationCache.get(t);
        if (existing) {
            return existing;
        }
        const annotation = cacheAnnotationFromType(t);
        typeAnnotationCache.set(t, annotation);
        return annotation;
    }
    function memoizedCacheAnnotationFromField(field) {
        const existing = fieldAnnotationCache.get(field);
        if (existing) {
            return existing;
        }
        const annotation = cacheAnnotationFromField(field);
        fieldAnnotationCache.set(field, annotation);
        return annotation;
    }
    return {
        __internal_plugin_id__ () {
            return 'CacheControl';
        },
        async serverWillStart ({ schema }) {
            typeAnnotationCache.max = Object.values(schema.getTypeMap()).filter(graphql_1.isCompositeType).length;
            fieldAnnotationCache.max = Object.values(schema.getTypeMap()).filter(graphql_1.isObjectType).flatMap((t)=>Object.values(t.getFields())).length + Object.values(schema.getTypeMap()).filter(graphql_1.isInterfaceType).flatMap((t)=>Object.values(t.getFields())).length;
            return undefined;
        },
        async requestDidStart (requestContext) {
            var _a, _b;
            const defaultMaxAge = (_a = options.defaultMaxAge) !== null && _a !== void 0 ? _a : 0;
            const calculateHttpHeaders = (_b = options.calculateHttpHeaders) !== null && _b !== void 0 ? _b : true;
            const { __testing__cacheHints } = options;
            return {
                async executionDidStart () {
                    if (isRestricted(requestContext.overallCachePolicy)) {
                        const fakeFieldPolicy = (0, cachePolicy_1.newCachePolicy)();
                        return {
                            willResolveField ({ info }) {
                                info.cacheControl = {
                                    setCacheHint: (dynamicHint)=>{
                                        fakeFieldPolicy.replace(dynamicHint);
                                    },
                                    cacheHint: fakeFieldPolicy,
                                    cacheHintFromType: memoizedCacheAnnotationFromType
                                };
                            }
                        };
                    }
                    return {
                        willResolveField ({ info }) {
                            const fieldPolicy = (0, cachePolicy_1.newCachePolicy)();
                            let inheritMaxAge = false;
                            const targetType = (0, graphql_1.getNamedType)(info.returnType);
                            if ((0, graphql_1.isCompositeType)(targetType)) {
                                const typeAnnotation = memoizedCacheAnnotationFromType(targetType);
                                fieldPolicy.replace(typeAnnotation);
                                inheritMaxAge = !!typeAnnotation.inheritMaxAge;
                            }
                            const fieldAnnotation = memoizedCacheAnnotationFromField(info.parentType.getFields()[info.fieldName]);
                            if (fieldAnnotation.inheritMaxAge && fieldPolicy.maxAge === undefined) {
                                inheritMaxAge = true;
                                if (fieldAnnotation.scope) {
                                    fieldPolicy.replace({
                                        scope: fieldAnnotation.scope
                                    });
                                }
                            } else {
                                fieldPolicy.replace(fieldAnnotation);
                            }
                            info.cacheControl = {
                                setCacheHint: (dynamicHint)=>{
                                    fieldPolicy.replace(dynamicHint);
                                },
                                cacheHint: fieldPolicy,
                                cacheHintFromType: memoizedCacheAnnotationFromType
                            };
                            return ()=>{
                                if (fieldPolicy.maxAge === undefined && ((0, graphql_1.isCompositeType)(targetType) && !inheritMaxAge || !info.path.prev)) {
                                    fieldPolicy.restrict({
                                        maxAge: defaultMaxAge
                                    });
                                }
                                if (__testing__cacheHints && isRestricted(fieldPolicy)) {
                                    const path = (0, graphql_1.responsePathAsArray)(info.path).join('.');
                                    if (__testing__cacheHints.has(path)) {
                                        throw Error("shouldn't happen: addHint should only be called once per path");
                                    }
                                    __testing__cacheHints.set(path, {
                                        maxAge: fieldPolicy.maxAge,
                                        scope: fieldPolicy.scope
                                    });
                                }
                                requestContext.overallCachePolicy.restrict(fieldPolicy);
                            };
                        }
                    };
                },
                async willSendResponse (requestContext) {
                    const { response, overallCachePolicy, requestIsBatched } = requestContext;
                    const policyIfCacheable = overallCachePolicy.policyIfCacheable();
                    if (calculateHttpHeaders && policyIfCacheable && !response.errors && response.http && !requestIsBatched) {
                        response.http.headers.set('Cache-Control', `max-age=${policyIfCacheable.maxAge}, ${policyIfCacheable.scope.toLowerCase()}`);
                    }
                }
            };
        }
    };
}
exports.ApolloServerPluginCacheControl = ApolloServerPluginCacheControl;
function cacheAnnotationFromDirectives(directives) {
    var _a, _b, _c;
    if (!directives) return undefined;
    const cacheControlDirective = directives.find((directive)=>directive.name.value === 'cacheControl');
    if (!cacheControlDirective) return undefined;
    if (!cacheControlDirective.arguments) return undefined;
    const maxAgeArgument = cacheControlDirective.arguments.find((argument)=>argument.name.value === 'maxAge');
    const scopeArgument = cacheControlDirective.arguments.find((argument)=>argument.name.value === 'scope');
    const inheritMaxAgeArgument = cacheControlDirective.arguments.find((argument)=>argument.name.value === 'inheritMaxAge');
    const scope = ((_a = scopeArgument === null || scopeArgument === void 0 ? void 0 : scopeArgument.value) === null || _a === void 0 ? void 0 : _a.kind) === 'EnumValue' ? scopeArgument.value.value : undefined;
    if (((_b = inheritMaxAgeArgument === null || inheritMaxAgeArgument === void 0 ? void 0 : inheritMaxAgeArgument.value) === null || _b === void 0 ? void 0 : _b.kind) === 'BooleanValue' && inheritMaxAgeArgument.value.value) {
        return {
            inheritMaxAge: true,
            scope
        };
    }
    return {
        maxAge: ((_c = maxAgeArgument === null || maxAgeArgument === void 0 ? void 0 : maxAgeArgument.value) === null || _c === void 0 ? void 0 : _c.kind) === 'IntValue' ? parseInt(maxAgeArgument.value.value) : undefined,
        scope
    };
}
function cacheAnnotationFromType(t) {
    if (t.astNode) {
        const hint = cacheAnnotationFromDirectives(t.astNode.directives);
        if (hint) {
            return hint;
        }
    }
    if (t.extensionASTNodes) {
        for (const node of t.extensionASTNodes){
            const hint = cacheAnnotationFromDirectives(node.directives);
            if (hint) {
                return hint;
            }
        }
    }
    return {};
}
function cacheAnnotationFromField(field) {
    if (field.astNode) {
        const hint = cacheAnnotationFromDirectives(field.astNode.directives);
        if (hint) {
            return hint;
        }
    }
    return {};
}
function isRestricted(hint) {
    return hint.maxAge !== undefined || hint.scope !== undefined;
}
function ApolloServerPluginCacheControlDisabled() {
    return {
        __internal_plugin_id__ () {
            return 'CacheControl';
        }
    };
}
exports.ApolloServerPluginCacheControlDisabled = ApolloServerPluginCacheControlDisabled; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/drainHttpServer/stoppable.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Stopper = void 0;
const https_1 = __importDefault(__turbopack_context__.r("[externals]/https [external] (https, cjs)"));
class Stopper {
    constructor(server){
        this.server = server;
        this.requestCountPerSocket = new Map();
        this.stopped = false;
        server.on(server instanceof https_1.default.Server ? 'secureConnection' : 'connection', (socket)=>{
            this.requestCountPerSocket.set(socket, 0);
            socket.once('close', ()=>this.requestCountPerSocket.delete(socket));
        });
        server.on('request', (req, res)=>{
            var _a;
            this.requestCountPerSocket.set(req.socket, ((_a = this.requestCountPerSocket.get(req.socket)) !== null && _a !== void 0 ? _a : 0) + 1);
            res.once('finish', ()=>{
                var _a;
                const pending = ((_a = this.requestCountPerSocket.get(req.socket)) !== null && _a !== void 0 ? _a : 0) - 1;
                this.requestCountPerSocket.set(req.socket, pending);
                if (this.stopped && pending === 0) {
                    req.socket.end();
                }
            });
        });
    }
    async stop(stopGracePeriodMillis = Infinity) {
        let gracefully = true;
        await new Promise((resolve)=>setImmediate(resolve));
        this.stopped = true;
        let timeout = null;
        if (stopGracePeriodMillis < Infinity) {
            timeout = setTimeout(()=>{
                gracefully = false;
                this.requestCountPerSocket.forEach((_, socket)=>socket.end());
                setImmediate(()=>{
                    this.requestCountPerSocket.forEach((_, socket)=>socket.destroy());
                });
            }, stopGracePeriodMillis);
        }
        const closePromise = new Promise((resolve)=>this.server.close(()=>{
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                resolve();
            }));
        this.requestCountPerSocket.forEach((requests, socket)=>{
            if (requests === 0) socket.end();
        });
        await closePromise;
        return gracefully;
    }
}
exports.Stopper = Stopper; //# sourceMappingURL=stoppable.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/drainHttpServer/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApolloServerPluginDrainHttpServer = void 0;
const stoppable_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/drainHttpServer/stoppable.js [app-route] (ecmascript)");
function ApolloServerPluginDrainHttpServer(options) {
    const stopper = new stoppable_1.Stopper(options.httpServer);
    return {
        async serverWillStart () {
            return {
                async drainServer () {
                    var _a;
                    await stopper.stop((_a = options.stopGracePeriodMillis) !== null && _a !== void 0 ? _a : 10000);
                }
            };
        }
    };
}
exports.ApolloServerPluginDrainHttpServer = ApolloServerPluginDrainHttpServer; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/landingPage/default/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getEmbeddedSandboxHTML = exports.getEmbeddedExplorerHTML = exports.ApolloServerPluginLandingPageProductionDefault = exports.ApolloServerPluginLandingPageLocalDefault = void 0;
function ApolloServerPluginLandingPageLocalDefault(options = {}) {
    const { version, __internal_apolloStudioEnv__, ...rest } = options;
    return ApolloServerPluginLandingPageDefault(version, {
        isProd: false,
        apolloStudioEnv: __internal_apolloStudioEnv__,
        ...rest
    });
}
exports.ApolloServerPluginLandingPageLocalDefault = ApolloServerPluginLandingPageLocalDefault;
function ApolloServerPluginLandingPageProductionDefault(options = {}) {
    const { version, __internal_apolloStudioEnv__, ...rest } = options;
    return ApolloServerPluginLandingPageDefault(version, {
        isProd: true,
        apolloStudioEnv: __internal_apolloStudioEnv__,
        ...rest
    });
}
exports.ApolloServerPluginLandingPageProductionDefault = ApolloServerPluginLandingPageProductionDefault;
function encodeConfig(config) {
    return JSON.stringify(encodeURIComponent(JSON.stringify(config)));
}
function getConfigStringForHtml(config) {
    return JSON.stringify(config).replace('<', '\\u003c').replace('>', '\\u003e').replace('&', '\\u0026').replace("'", '\\u0027');
}
const getEmbeddedExplorerHTML = (version, config)=>{
    const productionLandingPageConfigOrDefault = {
        displayOptions: {},
        persistExplorerState: false,
        ...typeof config.embed === 'boolean' ? {} : config.embed
    };
    const embeddedExplorerParams = {
        ...config,
        target: '#embeddableExplorer',
        initialState: {
            ...config,
            displayOptions: {
                ...productionLandingPageConfigOrDefault.displayOptions
            }
        },
        persistExplorerState: productionLandingPageConfigOrDefault.persistExplorerState
    };
    return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Explorer cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableExplorer"
></div>
<script src="https://embeddable-explorer.cdn.apollographql.com/${version}/embeddable-explorer.umd.production.min.js"></script>
<script>
  var endpointUrl = window.location.href;
  var embeddedExplorerConfig = ${getConfigStringForHtml(embeddedExplorerParams)};
  new window.EmbeddedExplorer({
    ...embeddedExplorerConfig,
    endpointUrl,
  });
</script>
`;
};
exports.getEmbeddedExplorerHTML = getEmbeddedExplorerHTML;
const getEmbeddedSandboxHTML = (version, config)=>{
    var _a, _b, _c, _d;
    return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Sandbox cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableSandbox"
></div>
<script src="https://embeddable-sandbox.cdn.apollographql.com/${version}/embeddable-sandbox.umd.production.min.js"></script>
<script>
  var initialEndpoint = window.location.href;
  new window.EmbeddedSandbox({
    target: '#embeddableSandbox',
    initialEndpoint,
    includeCookies: ${(_a = config.includeCookies) !== null && _a !== void 0 ? _a : 'false'},
    initialState: ${getConfigStringForHtml({
        document: (_b = config.document) !== null && _b !== void 0 ? _b : undefined,
        variables: (_c = config.variables) !== null && _c !== void 0 ? _c : undefined,
        headers: (_d = config.headers) !== null && _d !== void 0 ? _d : undefined
    })},
  });
</script>
`;
};
exports.getEmbeddedSandboxHTML = getEmbeddedSandboxHTML;
const getNonEmbeddedLandingPageHTML = (version, config)=>{
    const encodedConfig = encodeConfig(config);
    return `
 <div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>The full landing page cannot be loaded; it appears that you might be offline.</p>
</div>
<script>window.landingPage = ${encodedConfig};</script>
<script src="https://apollo-server-landing-page.cdn.apollographql.com/${version}/static/js/main.js"></script>`;
};
function ApolloServerPluginLandingPageDefault(maybeVersion, config) {
    const version = maybeVersion !== null && maybeVersion !== void 0 ? maybeVersion : '_latest';
    return {
        __internal_installed_implicitly__: false,
        async serverWillStart () {
            return {
                async renderLandingPage () {
                    const html = `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link
      rel="icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/assets/favicon.png"
    />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap"
      rel="stylesheet"
    />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Apollo server landing page" />
    <link
      rel="apple-touch-icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/assets/favicon.png"
    />
    <link
      rel="manifest"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/manifest.json"
    />
    <title>Apollo Server</title>
  </head>
  <body style="margin: 0; overflow-x: hidden; overflow-y: hidden">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="react-root">
      <style>
        .fallback {
          opacity: 0;
          animation: fadeIn 1s 1s;
          animation-iteration-count: 1;
          animation-fill-mode: forwards;
          padding: 1em;
        }
        @keyframes fadeIn {
          0% {opacity:0;}
          100% {opacity:1; }
        }
      </style>
    ${config.embed ? 'graphRef' in config && config.graphRef ? (0, exports.getEmbeddedExplorerHTML)(version, config) : (0, exports.getEmbeddedSandboxHTML)(version, config) : getNonEmbeddedLandingPageHTML(version, config)}
    </div>
  </body>
</html>
          `;
                    return {
                        html
                    };
                }
            };
        }
    };
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/landingPage/graphqlPlayground/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApolloServerPluginLandingPageGraphQLPlayground = void 0;
const graphql_playground_html_1 = __turbopack_context__.r("[project]/node_modules/@apollographql/graphql-playground-html/dist/index.js [app-route] (ecmascript)");
const defaultPlaygroundVersion = '1.7.42';
function ApolloServerPluginLandingPageGraphQLPlayground(options = Object.create(null)) {
    return {
        async serverWillStart () {
            return {
                async renderLandingPage () {
                    return {
                        html: (0, graphql_playground_html_1.renderPlaygroundPage)({
                            version: defaultPlaygroundVersion,
                            ...options
                        })
                    };
                }
            };
        }
    };
}
exports.ApolloServerPluginLandingPageGraphQLPlayground = ApolloServerPluginLandingPageGraphQLPlayground; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/plugin/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApolloServerPluginLandingPageGraphQLPlayground = exports.ApolloServerPluginLandingPageProductionDefault = exports.ApolloServerPluginLandingPageLocalDefault = exports.ApolloServerPluginLandingPageDisabled = exports.ApolloServerPluginDrainHttpServer = exports.ApolloServerPluginCacheControlDisabled = exports.ApolloServerPluginCacheControl = exports.ApolloServerPluginInlineTraceDisabled = exports.ApolloServerPluginInlineTrace = exports.ApolloServerPluginSchemaReporting = exports.ApolloServerPluginUsageReportingDisabled = exports.ApolloServerPluginUsageReporting = void 0;
function ApolloServerPluginUsageReporting(options = Object.create(null)) {
    return __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/index.js [app-route] (ecmascript)").ApolloServerPluginUsageReporting(options);
}
exports.ApolloServerPluginUsageReporting = ApolloServerPluginUsageReporting;
function ApolloServerPluginUsageReportingDisabled() {
    return __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/usageReporting/index.js [app-route] (ecmascript)").ApolloServerPluginUsageReportingDisabled();
}
exports.ApolloServerPluginUsageReportingDisabled = ApolloServerPluginUsageReportingDisabled;
function ApolloServerPluginSchemaReporting(options = Object.create(null)) {
    return __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/schemaReporting/index.js [app-route] (ecmascript)").ApolloServerPluginSchemaReporting(options);
}
exports.ApolloServerPluginSchemaReporting = ApolloServerPluginSchemaReporting;
function ApolloServerPluginInlineTrace(options = Object.create(null)) {
    return __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/inlineTrace/index.js [app-route] (ecmascript)").ApolloServerPluginInlineTrace(options);
}
exports.ApolloServerPluginInlineTrace = ApolloServerPluginInlineTrace;
function ApolloServerPluginInlineTraceDisabled() {
    return __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/inlineTrace/index.js [app-route] (ecmascript)").ApolloServerPluginInlineTraceDisabled();
}
exports.ApolloServerPluginInlineTraceDisabled = ApolloServerPluginInlineTraceDisabled;
function ApolloServerPluginCacheControl(options = Object.create(null)) {
    return __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/cacheControl/index.js [app-route] (ecmascript)").ApolloServerPluginCacheControl(options);
}
exports.ApolloServerPluginCacheControl = ApolloServerPluginCacheControl;
function ApolloServerPluginCacheControlDisabled() {
    return __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/cacheControl/index.js [app-route] (ecmascript)").ApolloServerPluginCacheControlDisabled();
}
exports.ApolloServerPluginCacheControlDisabled = ApolloServerPluginCacheControlDisabled;
function ApolloServerPluginDrainHttpServer(options) {
    return __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/drainHttpServer/index.js [app-route] (ecmascript)").ApolloServerPluginDrainHttpServer(options);
}
exports.ApolloServerPluginDrainHttpServer = ApolloServerPluginDrainHttpServer;
function ApolloServerPluginLandingPageDisabled() {
    const plugin = {
        __internal_plugin_id__ () {
            return 'LandingPageDisabled';
        }
    };
    return plugin;
}
exports.ApolloServerPluginLandingPageDisabled = ApolloServerPluginLandingPageDisabled;
function ApolloServerPluginLandingPageLocalDefault(options) {
    return __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/landingPage/default/index.js [app-route] (ecmascript)").ApolloServerPluginLandingPageLocalDefault(options);
}
exports.ApolloServerPluginLandingPageLocalDefault = ApolloServerPluginLandingPageLocalDefault;
function ApolloServerPluginLandingPageProductionDefault(options) {
    return __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/landingPage/default/index.js [app-route] (ecmascript)").ApolloServerPluginLandingPageProductionDefault(options);
}
exports.ApolloServerPluginLandingPageProductionDefault = ApolloServerPluginLandingPageProductionDefault;
function ApolloServerPluginLandingPageGraphQLPlayground(options = Object.create(null)) {
    return __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/landingPage/graphqlPlayground/index.js [app-route] (ecmascript)").ApolloServerPluginLandingPageGraphQLPlayground(options);
}
exports.ApolloServerPluginLandingPageGraphQLPlayground = ApolloServerPluginLandingPageGraphQLPlayground; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/internalPlugin.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pluginIsInternal = void 0;
function pluginIsInternal(plugin) {
    return '__internal_plugin_id__' in plugin;
}
exports.pluginIsInternal = pluginIsInternal; //# sourceMappingURL=internalPlugin.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/utils/schemaManager.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GatewayIsTooOldError = exports.SchemaManager = void 0;
class SchemaManager {
    constructor(options){
        this.onSchemaLoadOrUpdateListeners = new Set();
        this.isStopped = false;
        this.logger = options.logger;
        this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;
        if ('gateway' in options) {
            this.modeSpecificState = {
                mode: 'gateway',
                gateway: options.gateway,
                apolloConfig: options.apolloConfig
            };
        } else {
            this.modeSpecificState = {
                mode: 'schema',
                apiSchema: options.apiSchema,
                schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema)
            };
        }
    }
    async start() {
        if (this.modeSpecificState.mode === 'gateway') {
            const gateway = this.modeSpecificState.gateway;
            if (gateway.onSchemaLoadOrUpdate) {
                this.modeSpecificState.unsubscribeFromGateway = gateway.onSchemaLoadOrUpdate((schemaContext)=>{
                    this.processSchemaLoadOrUpdateEvent(schemaContext);
                });
            } else if (gateway.onSchemaChange) {
                this.modeSpecificState.unsubscribeFromGateway = gateway.onSchemaChange((apiSchema)=>{
                    this.processSchemaLoadOrUpdateEvent({
                        apiSchema
                    });
                });
            } else {
                throw new Error("Unexpectedly couldn't find onSchemaChange or onSchemaLoadOrUpdate on gateway");
            }
            const config = await this.modeSpecificState.gateway.load({
                apollo: this.modeSpecificState.apolloConfig
            });
            if (!this.schemaDerivedData) {
                this.processSchemaLoadOrUpdateEvent({
                    apiSchema: config.schema
                });
            }
            return config.executor;
        } else {
            this.processSchemaLoadOrUpdateEvent({
                apiSchema: this.modeSpecificState.apiSchema
            }, this.modeSpecificState.schemaDerivedData);
            return null;
        }
    }
    onSchemaLoadOrUpdate(callback) {
        if (this.modeSpecificState.mode === 'gateway' && !this.modeSpecificState.gateway.onSchemaLoadOrUpdate) {
            throw new GatewayIsTooOldError([
                `Your gateway is too old to register a 'onSchemaLoadOrUpdate' listener.`,
                `Please update your version of @apollo/gateway to at least 0.35.0.`
            ].join(' '));
        } else {
            if (!this.schemaContext) {
                throw new Error('You must call start() before onSchemaLoadOrUpdate()');
            }
            if (!this.isStopped) {
                try {
                    callback(this.schemaContext);
                } catch (e) {
                    throw new Error(`An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${e.message}`);
                }
            }
            this.onSchemaLoadOrUpdateListeners.add(callback);
        }
        return ()=>{
            this.onSchemaLoadOrUpdateListeners.delete(callback);
        };
    }
    getSchemaDerivedData() {
        if (!this.schemaDerivedData) {
            throw new Error('You must call start() before getSchemaDerivedData()');
        }
        return this.schemaDerivedData;
    }
    async stop() {
        var _a, _b, _c, _d;
        this.isStopped = true;
        if (this.modeSpecificState.mode === 'gateway') {
            (_b = (_a = this.modeSpecificState).unsubscribeFromGateway) === null || _b === void 0 ? void 0 : _b.call(_a);
            await ((_d = (_c = this.modeSpecificState.gateway).stop) === null || _d === void 0 ? void 0 : _d.call(_c));
        }
    }
    processSchemaLoadOrUpdateEvent(schemaContext, schemaDerivedData) {
        if (!this.isStopped) {
            this.schemaDerivedData = schemaDerivedData !== null && schemaDerivedData !== void 0 ? schemaDerivedData : this.schemaDerivedDataProvider(schemaContext.apiSchema);
            this.schemaContext = schemaContext;
            this.onSchemaLoadOrUpdateListeners.forEach((listener)=>{
                try {
                    listener(schemaContext);
                } catch (e) {
                    this.logger.error("An error was thrown from an 'onSchemaLoadOrUpdate' listener");
                    this.logger.error(e);
                }
            });
        }
    }
}
exports.SchemaManager = SchemaManager;
class GatewayIsTooOldError extends Error {
    constructor(message){
        super(message);
    }
}
exports.GatewayIsTooOldError = GatewayIsTooOldError; //# sourceMappingURL=schemaManager.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/utils/UnboundedCache.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UnboundedCache = void 0;
class UnboundedCache {
    constructor(cache = new Map()){
        this.cache = cache;
    }
    async get(key) {
        const entry = this.cache.get(key);
        if (!entry) return undefined;
        if (entry.deadline && entry.deadline <= Date.now()) {
            await this.delete(key);
            return undefined;
        }
        return entry.value;
    }
    async set(key, value, { ttl } = {
        ttl: null
    }) {
        this.cache.set(key, {
            value,
            deadline: ttl ? Date.now() + ttl * 1000 : null
        });
    }
    async delete(key) {
        this.cache.delete(key);
    }
}
exports.UnboundedCache = UnboundedCache; //# sourceMappingURL=UnboundedCache.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/ApolloServer.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isImplicitlyInstallablePlugin = exports.ApolloServerBase = void 0;
const mock_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/index.js [app-route] (ecmascript)");
const schema_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/cjs/index.js [app-route] (ecmascript)");
const loglevel_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/loglevel/lib/loglevel.js [app-route] (ecmascript)"));
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const resolvable_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@josephg/resolvable/index.js [app-route] (ecmascript)"));
const utils_keyvaluecache_1 = __turbopack_context__.r("[project]/node_modules/@apollo/utils.keyvaluecache/dist/index.js [app-route] (ecmascript)");
const schemaHash_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/utils/schemaHash.js [app-route] (ecmascript)");
const requestPipeline_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/requestPipeline.js [app-route] (ecmascript)");
const apollo_server_env_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-env/dist/index.js [app-route] (ecmascript)");
const apollo_tools_1 = __turbopack_context__.r("[project]/node_modules/@apollographql/apollo-tools/lib/index.js [app-route] (ecmascript)");
const runHttpQuery_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/runHttpQuery.js [app-route] (ecmascript)");
const isNodeLike_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/utils/isNodeLike.js [app-route] (ecmascript)"));
const determineApolloConfig_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/determineApolloConfig.js [app-route] (ecmascript)");
const plugin_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/index.js [app-route] (ecmascript)");
const internalPlugin_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/internalPlugin.js [app-route] (ecmascript)");
const cachePolicy_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/cachePolicy.js [app-route] (ecmascript)");
const schemaManager_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/utils/schemaManager.js [app-route] (ecmascript)");
const uuid = __importStar(__turbopack_context__.r("[project]/node_modules/uuid/dist/esm-node/index.js [app-route] (ecmascript)"));
const UnboundedCache_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/utils/UnboundedCache.js [app-route] (ecmascript)");
const NoIntrospection = (context)=>({
        Field (node) {
            if (node.name.value === '__schema' || node.name.value === '__type') {
                context.reportError(new graphql_1.GraphQLError('GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production', [
                    node
                ]));
            }
        }
    });
class UnreachableCaseError extends Error {
    constructor(val){
        super(`Unreachable case: ${val}`);
    }
}
const recommendedCsrfPreventionRequestHeaders = [
    'x-apollo-operation-name',
    'apollo-require-preflight'
];
class ApolloServerBase {
    constructor(config){
        var _a, _b;
        this.graphqlPath = '/graphql';
        this.requestOptions = Object.create(null);
        this.plugins = [];
        this.toDispose = new Set();
        this.toDisposeLast = new Set();
        this.drainServers = null;
        this.landingPage = null;
        if (!config) throw new Error('ApolloServer requires options.');
        this.config = {
            ...config,
            nodeEnv: (_a = config.nodeEnv) !== null && _a !== void 0 ? _a : ("TURBOPACK compile-time value", "development")
        };
        const { context, resolvers, schema, modules, typeDefs, parseOptions = {}, introspection, plugins, gateway, apollo, stopOnTerminationSignals, mocks, mockEntireSchema, documentStore, csrfPrevention, ...requestOptions } = this.config;
        if (config.logger) {
            this.logger = config.logger;
        } else {
            const loglevelLogger = loglevel_1.default.getLogger('apollo-server');
            if (this.config.debug === true) {
                loglevelLogger.setLevel(loglevel_1.default.levels.DEBUG);
            } else {
                loglevelLogger.setLevel(loglevel_1.default.levels.INFO);
            }
            this.logger = loglevelLogger;
        }
        this.apolloConfig = (0, determineApolloConfig_1.determineApolloConfig)(apollo, this.logger);
        if (gateway && (modules || schema || typeDefs || resolvers)) {
            throw new Error('Cannot define both `gateway` and any of: `modules`, `schema`, `typeDefs`, or `resolvers`');
        }
        this.parseOptions = parseOptions;
        this.context = context;
        this.csrfPreventionRequestHeaders = csrfPrevention === true ? recommendedCsrfPreventionRequestHeaders : csrfPrevention === false ? null : csrfPrevention === undefined ? null : (_b = csrfPrevention.requestHeaders) !== null && _b !== void 0 ? _b : recommendedCsrfPreventionRequestHeaders;
        const isDev = this.config.nodeEnv !== 'production';
        this.stopOnTerminationSignals = typeof stopOnTerminationSignals === 'boolean' ? stopOnTerminationSignals : isNodeLike_1.default && this.config.nodeEnv !== 'test' && !this.serverlessFramework();
        if (typeof introspection === 'boolean' && !introspection || introspection === undefined && !isDev) {
            const noIntro = [
                NoIntrospection
            ];
            requestOptions.validationRules = requestOptions.validationRules ? requestOptions.validationRules.concat(noIntro) : noIntro;
        }
        if (requestOptions.cache === 'bounded') {
            requestOptions.cache = new utils_keyvaluecache_1.InMemoryLRUCache();
        }
        if (!requestOptions.cache) {
            requestOptions.cache = new UnboundedCache_1.UnboundedCache();
            if (!isDev && (requestOptions.persistedQueries === undefined || requestOptions.persistedQueries && !requestOptions.persistedQueries.cache)) {
                this.logger.warn('Persisted queries are enabled and are using an unbounded cache. Your server' + ' is vulnerable to denial of service attacks via memory exhaustion. ' + 'Set `cache: "bounded"` or `persistedQueries: false` in your ApolloServer ' + 'constructor, or see https://go.apollo.dev/s/cache-backends for other alternatives.');
            }
        }
        if (requestOptions.persistedQueries !== false) {
            const { cache: apqCache = requestOptions.cache, ...apqOtherOptions } = requestOptions.persistedQueries || Object.create(null);
            requestOptions.persistedQueries = {
                cache: new utils_keyvaluecache_1.PrefixingKeyValueCache(apqCache, requestPipeline_1.APQ_CACHE_PREFIX),
                ...apqOtherOptions
            };
        } else {
            delete requestOptions.persistedQueries;
        }
        this.requestOptions = requestOptions;
        this.ensurePluginInstantiation(plugins, isDev);
        if (gateway) {
            this.state = {
                phase: 'initialized',
                schemaManager: new schemaManager_1.SchemaManager({
                    gateway,
                    apolloConfig: this.apolloConfig,
                    schemaDerivedDataProvider: (schema)=>this.generateSchemaDerivedData(schema),
                    logger: this.logger
                })
            };
        } else {
            this.state = {
                phase: 'initialized',
                schemaManager: new schemaManager_1.SchemaManager({
                    apiSchema: this.maybeAddMocksToConstructedSchema(this.constructSchema()),
                    schemaDerivedDataProvider: (schema)=>this.generateSchemaDerivedData(schema),
                    logger: this.logger
                })
            };
        }
        if (this.serverlessFramework()) {
            this._start().catch((e)=>this.logStartupError(e));
        }
    }
    async start() {
        if (this.serverlessFramework()) {
            throw new Error('When using an ApolloServer subclass from a serverless framework ' + "package, you don't need to call start(); just call createHandler().");
        }
        return await this._start();
    }
    async _start() {
        var _a;
        if (this.state.phase !== 'initialized') {
            throw new Error(`called start() with surprising state ${this.state.phase}`);
        }
        const schemaManager = this.state.schemaManager;
        const barrier = (0, resolvable_1.default)();
        this.state = {
            phase: 'starting',
            barrier,
            schemaManager
        };
        try {
            const executor = await schemaManager.start();
            this.toDispose.add(async ()=>{
                await schemaManager.stop();
            });
            if (executor) {
                this.requestOptions.executor = executor;
            }
            const schemaDerivedData = schemaManager.getSchemaDerivedData();
            const service = {
                logger: this.logger,
                schema: schemaDerivedData.schema,
                schemaHash: schemaDerivedData.schemaHash,
                apollo: this.apolloConfig,
                serverlessFramework: this.serverlessFramework()
            };
            if ((_a = this.requestOptions.persistedQueries) === null || _a === void 0 ? void 0 : _a.cache) {
                service.persistedQueries = {
                    cache: this.requestOptions.persistedQueries.cache
                };
            }
            const taggedServerListeners = (await Promise.all(this.plugins.map(async (plugin)=>({
                    serverListener: plugin.serverWillStart && await plugin.serverWillStart(service),
                    installedImplicitly: isImplicitlyInstallablePlugin(plugin) && plugin.__internal_installed_implicitly__
                })))).filter((maybeTaggedServerListener)=>typeof maybeTaggedServerListener.serverListener === 'object');
            taggedServerListeners.forEach(({ serverListener: { schemaDidLoadOrUpdate } })=>{
                if (schemaDidLoadOrUpdate) {
                    try {
                        schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);
                    } catch (e) {
                        if (e instanceof schemaManager_1.GatewayIsTooOldError) {
                            throw new Error([
                                `One of your plugins uses the 'schemaDidLoadOrUpdate' hook,`,
                                `but your gateway version is too old to support this hook.`,
                                `Please update your version of @apollo/gateway to at least 0.35.0.`
                            ].join(' '));
                        }
                        throw e;
                    }
                }
            });
            const serverWillStops = taggedServerListeners.flatMap((l)=>l.serverListener.serverWillStop ? [
                    l.serverListener.serverWillStop
                ] : []);
            if (serverWillStops.length) {
                this.toDispose.add(async ()=>{
                    await Promise.all(serverWillStops.map((serverWillStop)=>serverWillStop()));
                });
            }
            const drainServerCallbacks = taggedServerListeners.flatMap((l)=>l.serverListener.drainServer ? [
                    l.serverListener.drainServer
                ] : []);
            if (drainServerCallbacks.length) {
                this.drainServers = async ()=>{
                    await Promise.all(drainServerCallbacks.map((drainServer)=>drainServer()));
                };
            }
            let taggedServerListenersWithRenderLandingPage = taggedServerListeners.filter((l)=>l.serverListener.renderLandingPage);
            if (taggedServerListenersWithRenderLandingPage.length > 1) {
                taggedServerListenersWithRenderLandingPage = taggedServerListenersWithRenderLandingPage.filter((l)=>!l.installedImplicitly);
            }
            if (taggedServerListenersWithRenderLandingPage.length > 1) {
                throw Error('Only one plugin can implement renderLandingPage.');
            } else if (taggedServerListenersWithRenderLandingPage.length) {
                this.landingPage = await taggedServerListenersWithRenderLandingPage[0].serverListener.renderLandingPage();
            } else {
                this.landingPage = null;
            }
            this.state = {
                phase: 'started',
                schemaManager
            };
            this.maybeRegisterTerminationSignalHandlers([
                'SIGINT',
                'SIGTERM'
            ]);
        } catch (error) {
            this.state = {
                phase: 'failed to start',
                error: error
            };
            throw error;
        } finally{
            barrier.resolve();
        }
    }
    maybeRegisterTerminationSignalHandlers(signals) {
        if (!this.stopOnTerminationSignals) {
            return;
        }
        let receivedSignal = false;
        const signalHandler = async (signal)=>{
            if (receivedSignal) {
                return;
            }
            receivedSignal = true;
            try {
                await this.stop();
            } catch (e) {
                this.logger.error(`stop() threw during ${signal} shutdown`);
                this.logger.error(e);
                process.exit(1);
            }
            process.kill(process.pid, signal);
        };
        signals.forEach((signal)=>{
            process.on(signal, signalHandler);
            this.toDisposeLast.add(async ()=>{
                process.removeListener(signal, signalHandler);
            });
        });
    }
    async _ensureStarted() {
        while(true){
            switch(this.state.phase){
                case 'initialized':
                    throw new Error('You need to call `server.start()` before using your Apollo Server.');
                case 'starting':
                    await this.state.barrier;
                    break;
                case 'failed to start':
                    this.logStartupError(this.state.error);
                    throw new Error('This data graph is missing a valid configuration. More details may be available in the server logs.');
                case 'started':
                case 'draining':
                    return this.state.schemaManager.getSchemaDerivedData();
                case 'stopping':
                    throw new Error('Cannot execute GraphQL operations while the server is stopping.');
                case 'stopped':
                    throw new Error('Cannot execute GraphQL operations after the server has stopped.');
                default:
                    throw new UnreachableCaseError(this.state);
            }
        }
    }
    async ensureStarted() {
        await this._ensureStarted();
    }
    assertStarted(methodName) {
        if (this.state.phase !== 'started' && this.state.phase !== 'draining') {
            throw new Error('You must `await server.start()` before calling `server.' + methodName + '()`');
        }
    }
    logStartupError(err) {
        this.logger.error('An error occurred during Apollo Server startup. All GraphQL requests ' + 'will now fail. The startup error was: ' + ((err === null || err === void 0 ? void 0 : err.message) || err));
    }
    constructSchema() {
        const { schema, modules, typeDefs, resolvers, parseOptions } = this.config;
        if (schema) {
            return schema;
        }
        if (modules) {
            const { schema, errors } = (0, apollo_tools_1.buildServiceDefinition)(modules);
            if (errors && errors.length > 0) {
                throw new Error(errors.map((error)=>error.message).join('\n\n'));
            }
            return schema;
        }
        if (!typeDefs) {
            throw Error('Apollo Server requires either an existing schema, modules or typeDefs');
        }
        const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [
            typeDefs
        ];
        return (0, schema_1.makeExecutableSchema)({
            typeDefs: augmentedTypeDefs,
            resolvers,
            parseOptions
        });
    }
    maybeAddMocksToConstructedSchema(schema) {
        const { mocks, mockEntireSchema } = this.config;
        if (mocks === false) {
            return schema;
        }
        if (!mocks && typeof mockEntireSchema === 'undefined') {
            return schema;
        }
        return (0, mock_1.addMocksToSchema)({
            schema,
            mocks: mocks === true || typeof mocks === 'undefined' ? {} : mocks,
            preserveResolvers: typeof mockEntireSchema === 'undefined' ? false : !mockEntireSchema
        });
    }
    generateSchemaDerivedData(schema) {
        const schemaHash = (0, schemaHash_1.generateSchemaHash)(schema);
        return {
            schema,
            schemaHash,
            documentStore: this.config.documentStore === undefined ? new utils_keyvaluecache_1.InMemoryLRUCache() : this.config.documentStore === null ? null : new utils_keyvaluecache_1.PrefixingKeyValueCache(this.config.documentStore, `${uuid.v4()}:`)
        };
    }
    async stop() {
        var _a;
        switch(this.state.phase){
            case 'initialized':
            case 'starting':
            case 'failed to start':
                throw Error('apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded');
            case 'stopped':
                if (this.state.stopError) {
                    throw this.state.stopError;
                }
                return;
            case 'stopping':
            case 'draining':
                {
                    await this.state.barrier;
                    const state = this.state;
                    if (state.phase !== 'stopped') {
                        throw Error(`Surprising post-stopping state ${state.phase}`);
                    }
                    if (state.stopError) {
                        throw state.stopError;
                    }
                    return;
                }
            case 'started':
                break;
            default:
                throw new UnreachableCaseError(this.state);
        }
        const barrier = (0, resolvable_1.default)();
        this.state = {
            phase: 'draining',
            schemaManager: this.state.schemaManager,
            barrier
        };
        try {
            await ((_a = this.drainServers) === null || _a === void 0 ? void 0 : _a.call(this));
            this.state = {
                phase: 'stopping',
                barrier
            };
            await Promise.all([
                ...this.toDispose
            ].map((dispose)=>dispose()));
            await Promise.all([
                ...this.toDisposeLast
            ].map((dispose)=>dispose()));
        } catch (stopError) {
            this.state = {
                phase: 'stopped',
                stopError: stopError
            };
            barrier.resolve();
            throw stopError;
        }
        this.state = {
            phase: 'stopped',
            stopError: null
        };
    }
    serverlessFramework() {
        return false;
    }
    ensurePluginInstantiation(userPlugins = [], isDev) {
        this.plugins = userPlugins.map((plugin)=>{
            if (typeof plugin === 'function') {
                return plugin();
            }
            return plugin;
        });
        const alreadyHavePluginWithInternalId = (id)=>this.plugins.some((p)=>(0, internalPlugin_1.pluginIsInternal)(p) && p.__internal_plugin_id__() === id);
        {
            if (!alreadyHavePluginWithInternalId('CacheControl')) {
                this.plugins.push((0, plugin_1.ApolloServerPluginCacheControl)());
            }
        }
        {
            const alreadyHavePlugin = alreadyHavePluginWithInternalId('UsageReporting');
            if (!alreadyHavePlugin && this.apolloConfig.key) {
                if (this.apolloConfig.graphRef) {
                    this.plugins.unshift((0, plugin_1.ApolloServerPluginUsageReporting)());
                } else {
                    this.logger.warn('You have specified an Apollo key but have not specified a graph ref; usage ' + 'reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` ' + 'environment variable to `your-graph-id@your-graph-variant`. To disable this ' + 'warning, install `ApolloServerPluginUsageReportingDisabled`.');
                }
            }
        }
        {
            const alreadyHavePlugin = alreadyHavePluginWithInternalId('SchemaReporting');
            const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === 'true';
            if (!alreadyHavePlugin && enabledViaEnvVar) {
                if (this.apolloConfig.key) {
                    const options = {};
                    this.plugins.push((0, plugin_1.ApolloServerPluginSchemaReporting)(options));
                } else {
                    throw new Error("You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING " + 'environment variable to true, but you also need to provide your ' + 'Apollo API key, via the APOLLO_KEY environment ' + 'variable or via `new ApolloServer({apollo: {key})');
                }
            }
        }
        {
            const alreadyHavePlugin = alreadyHavePluginWithInternalId('InlineTrace');
            if (!alreadyHavePlugin) {
                this.plugins.push((0, plugin_1.ApolloServerPluginInlineTrace)({
                    __onlyIfSchemaIsFederated: true
                }));
            }
        }
        const alreadyHavePlugin = alreadyHavePluginWithInternalId('LandingPageDisabled');
        if (!alreadyHavePlugin) {
            const plugin = isDev ? (0, plugin_1.ApolloServerPluginLandingPageLocalDefault)() : (0, plugin_1.ApolloServerPluginLandingPageProductionDefault)();
            if (!isImplicitlyInstallablePlugin(plugin)) {
                throw Error('default landing page plugin should be implicitly installable?');
            }
            plugin.__internal_installed_implicitly__ = true;
            this.plugins.push(plugin);
        }
    }
    async graphQLServerOptions(integrationContextArgument) {
        const { schema, schemaHash, documentStore } = await this._ensureStarted();
        let context = this.context ? this.context : {};
        try {
            context = typeof this.context === 'function' ? await this.context(integrationContextArgument || {}) : context;
        } catch (error) {
            context = ()=>{
                throw error;
            };
        }
        return {
            schema,
            schemaHash,
            logger: this.logger,
            plugins: this.plugins,
            documentStore,
            dangerouslyDisableValidation: this.config.dangerouslyDisableValidation,
            context,
            parseOptions: this.parseOptions,
            ...this.requestOptions
        };
    }
    async executeOperation(request, integrationContextArgument) {
        if (this.state.phase === 'initialized') {
            await this._start();
        }
        const options = await this.graphQLServerOptions(integrationContextArgument);
        if (typeof options.context === 'function') {
            options.context = options.context();
        } else if (typeof options.context === 'object') {
            options.context = (0, runHttpQuery_1.cloneObject)(options.context);
        }
        const requestCtx = {
            logger: this.logger,
            schema: options.schema,
            schemaHash: options.schemaHash,
            request: {
                ...request,
                query: request.query && typeof request.query !== 'string' ? (0, graphql_1.print)(request.query) : request.query
            },
            context: options.context || Object.create(null),
            cache: options.cache,
            metrics: {},
            response: {
                http: {
                    headers: new apollo_server_env_1.Headers()
                }
            },
            debug: options.debug,
            overallCachePolicy: (0, cachePolicy_1.newCachePolicy)(),
            requestIsBatched: false
        };
        return (0, requestPipeline_1.processGraphQLRequest)(options, requestCtx);
    }
    getLandingPage() {
        this.assertStarted('getLandingPage');
        return this.landingPage;
    }
}
exports.ApolloServerBase = ApolloServerBase;
function isImplicitlyInstallablePlugin(p) {
    return '__internal_installed_implicitly__' in p;
}
exports.isImplicitlyInstallablePlugin = isImplicitlyInstallablePlugin; //# sourceMappingURL=ApolloServer.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/types.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/apollo-server-core/dist/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApolloServerBase = exports.convertNodeHttpToRequest = exports.formatApolloErrors = exports.UserInputError = exports.ForbiddenError = exports.AuthenticationError = exports.ValidationError = exports.SyntaxError = exports.toApolloError = exports.ApolloError = exports.resolveGraphqlOptions = exports.isHttpQueryError = exports.HttpQueryError = exports.runHttpQuery = void 0;
var runHttpQuery_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/runHttpQuery.js [app-route] (ecmascript)");
Object.defineProperty(exports, "runHttpQuery", {
    enumerable: true,
    get: function() {
        return runHttpQuery_1.runHttpQuery;
    }
});
Object.defineProperty(exports, "HttpQueryError", {
    enumerable: true,
    get: function() {
        return runHttpQuery_1.HttpQueryError;
    }
});
Object.defineProperty(exports, "isHttpQueryError", {
    enumerable: true,
    get: function() {
        return runHttpQuery_1.isHttpQueryError;
    }
});
var graphqlOptions_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/graphqlOptions.js [app-route] (ecmascript)");
Object.defineProperty(exports, "resolveGraphqlOptions", {
    enumerable: true,
    get: function() {
        return graphqlOptions_1.resolveGraphqlOptions;
    }
});
var apollo_server_errors_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-errors/dist/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ApolloError", {
    enumerable: true,
    get: function() {
        return apollo_server_errors_1.ApolloError;
    }
});
Object.defineProperty(exports, "toApolloError", {
    enumerable: true,
    get: function() {
        return apollo_server_errors_1.toApolloError;
    }
});
Object.defineProperty(exports, "SyntaxError", {
    enumerable: true,
    get: function() {
        return apollo_server_errors_1.SyntaxError;
    }
});
Object.defineProperty(exports, "ValidationError", {
    enumerable: true,
    get: function() {
        return apollo_server_errors_1.ValidationError;
    }
});
Object.defineProperty(exports, "AuthenticationError", {
    enumerable: true,
    get: function() {
        return apollo_server_errors_1.AuthenticationError;
    }
});
Object.defineProperty(exports, "ForbiddenError", {
    enumerable: true,
    get: function() {
        return apollo_server_errors_1.ForbiddenError;
    }
});
Object.defineProperty(exports, "UserInputError", {
    enumerable: true,
    get: function() {
        return apollo_server_errors_1.UserInputError;
    }
});
Object.defineProperty(exports, "formatApolloErrors", {
    enumerable: true,
    get: function() {
        return apollo_server_errors_1.formatApolloErrors;
    }
});
var nodeHttpToRequest_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/nodeHttpToRequest.js [app-route] (ecmascript)");
Object.defineProperty(exports, "convertNodeHttpToRequest", {
    enumerable: true,
    get: function() {
        return nodeHttpToRequest_1.convertNodeHttpToRequest;
    }
});
var ApolloServer_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/ApolloServer.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ApolloServerBase", {
    enumerable: true,
    get: function() {
        return ApolloServer_1.ApolloServerBase;
    }
});
__exportStar(__turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/types.js [app-route] (ecmascript)"), exports);
var apollo_server_types_1 = __turbopack_context__.r("[project]/node_modules/apollo-server-types/dist/index.js [app-route] (ecmascript)");
__exportStar(__turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/gql.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/apollo-server-core/dist/plugin/index.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),

};

//# sourceMappingURL=node_modules_apollo-server-core_bc7cc1c2._.js.map