{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isExecutableDefinitionNode } from \"../../language/predicates.mjs\";\n\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n */\nexport function ExecutableDefinitionsRule(context) {\n  return {\n    Document: function Document(node) {\n      for (var _i2 = 0, _node$definitions2 = node.definitions; _i2 < _node$definitions2.length; _i2++) {\n        var definition = _node$definitions2[_i2];\n\n        if (!isExecutableDefinitionNode(definition)) {\n          var defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? 'schema' : '\"' + definition.name.value + '\"';\n          context.reportError(new GraphQLError(\"The \".concat(defName, \" definition is not executable.\"), definition));\n        }\n      }\n\n      return false;\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAQO,SAAS,0BAA0B,OAAO;IAC/C,OAAO;QACL,UAAU,SAAS,SAAS,IAAI;YAC9B,IAAK,IAAI,MAAM,GAAG,qBAAqB,KAAK,WAAW,EAAE,MAAM,mBAAmB,MAAM,EAAE,MAAO;gBAC/F,IAAI,aAAa,kBAAkB,CAAC,IAAI;gBAExC,IAAI,CAAC,CAAA,GAAA,oJAAA,CAAA,6BAA0B,AAAD,EAAE,aAAa;oBAC3C,IAAI,UAAU,WAAW,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,iBAAiB,IAAI,WAAW,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,gBAAgB,GAAG,WAAW,MAAM,WAAW,IAAI,CAAC,KAAK,GAAG;oBACjJ,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,OAAO,MAAM,CAAC,SAAS,mCAAmC;gBACjG;YACF;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 32, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n */\nexport function UniqueOperationNamesRule(context) {\n  var knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      var operationName = node.name;\n\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(new GraphQLError(\"There can be only one operation named \\\"\".concat(operationName.value, \"\\\".\"), [knownOperationNames[operationName.value], operationName]));\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition() {\n      return false;\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,yBAAyB,OAAO;IAC9C,IAAI,sBAAsB,OAAO,MAAM,CAAC;IACxC,OAAO;QACL,qBAAqB,SAAS,oBAAoB,IAAI;YACpD,IAAI,gBAAgB,KAAK,IAAI;YAE7B,IAAI,eAAe;gBACjB,IAAI,mBAAmB,CAAC,cAAc,KAAK,CAAC,EAAE;oBAC5C,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,2CAA2C,MAAM,CAAC,cAAc,KAAK,EAAE,QAAQ;wBAAC,mBAAmB,CAAC,cAAc,KAAK,CAAC;wBAAE;qBAAc;gBAC/K,OAAO;oBACL,mBAAmB,CAAC,cAAc,KAAK,CAAC,GAAG;gBAC7C;YACF;YAEA,OAAO;QACT;QACA,oBAAoB,SAAS;YAC3B,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\n\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n */\nexport function LoneAnonymousOperationRule(context) {\n  var operationCount = 0;\n  return {\n    Document: function Document(node) {\n      operationCount = node.definitions.filter(function (definition) {\n        return definition.kind === Kind.OPERATION_DEFINITION;\n      }).length;\n    },\n    OperationDefinition: function OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(new GraphQLError('This anonymous operation must be the only defined operation.', node));\n      }\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAQO,SAAS,2BAA2B,OAAO;IAChD,IAAI,iBAAiB;IACrB,OAAO;QACL,UAAU,SAAS,SAAS,IAAI;YAC9B,iBAAiB,KAAK,WAAW,CAAC,MAAM,CAAC,SAAU,UAAU;gBAC3D,OAAO,WAAW,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,oBAAoB;YACtD,GAAG,MAAM;QACX;QACA,qBAAqB,SAAS,oBAAoB,IAAI;YACpD,IAAI,CAAC,KAAK,IAAI,IAAI,iBAAiB,GAAG;gBACpC,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,gEAAgE;YACvG;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Subscriptions must only include one field.\n *\n * A GraphQL subscription is valid only if it contains a single root field.\n */\nexport function SingleFieldSubscriptionsRule(context) {\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      if (node.operation === 'subscription') {\n        if (node.selectionSet.selections.length !== 1) {\n          context.reportError(new GraphQLError(node.name ? \"Subscription \\\"\".concat(node.name.value, \"\\\" must select only one top level field.\") : 'Anonymous Subscription must select only one top level field.', node.selectionSet.selections.slice(1)));\n        }\n      }\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,6BAA6B,OAAO;IAClD,OAAO;QACL,qBAAqB,SAAS,oBAAoB,IAAI;YACpD,IAAI,KAAK,SAAS,KAAK,gBAAgB;gBACrC,IAAI,KAAK,YAAY,CAAC,UAAU,CAAC,MAAM,KAAK,GAAG;oBAC7C,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,KAAK,IAAI,GAAG,kBAAkB,MAAM,CAAC,KAAK,IAAI,CAAC,KAAK,EAAE,8CAA8C,gEAAgE,KAAK,YAAY,CAAC,UAAU,CAAC,KAAK,CAAC;gBAC9O;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs"],"sourcesContent":["import didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedScalarTypes } from \"../../type/scalars.mjs\";\nimport { introspectionTypes } from \"../../type/introspection.mjs\";\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\nexport function KnownTypeNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\n        var isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && isStandardTypeName(typeName)) {\n          return;\n        }\n\n        var suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(\"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes), node));\n      }\n    }\n  };\n}\nvar standardTypeNames = [].concat(specifiedScalarTypes, introspectionTypes).map(function (type) {\n  return type.name;\n});\n\nfunction isStandardTypeName(typeName) {\n  return standardTypeNames.indexOf(typeName) !== -1;\n}\n\nfunction isSDLNode(value) {\n  return !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAQO,SAAS,mBAAmB,OAAO;IACxC,IAAI,SAAS,QAAQ,SAAS;IAC9B,IAAI,mBAAmB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACpE,IAAI,eAAe,OAAO,MAAM,CAAC;IAEjC,IAAK,IAAI,MAAM,GAAG,yBAAyB,QAAQ,WAAW,GAAG,WAAW,EAAE,MAAM,uBAAuB,MAAM,EAAE,MAAO;QACxH,IAAI,MAAM,sBAAsB,CAAC,IAAI;QAErC,IAAI,CAAA,GAAA,oJAAA,CAAA,uBAAoB,AAAD,EAAE,MAAM;YAC7B,YAAY,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG;QACjC;IACF;IAEA,IAAI,YAAY,OAAO,IAAI,CAAC,kBAAkB,MAAM,CAAC,OAAO,IAAI,CAAC;IACjE,OAAO;QACL,WAAW,SAAS,UAAU,IAAI,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,SAAS;YAC3D,IAAI,WAAW,KAAK,IAAI,CAAC,KAAK;YAE9B,IAAI,CAAC,gBAAgB,CAAC,SAAS,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE;gBAC1D,IAAI;gBAEJ,IAAI,iBAAiB,CAAC,cAAc,SAAS,CAAC,EAAE,MAAM,QAAQ,gBAAgB,KAAK,IAAI,cAAc;gBACrG,IAAI,QAAQ,kBAAkB,QAAQ,UAAU;gBAEhD,IAAI,SAAS,mBAAmB,WAAW;oBACzC;gBACF;gBAEA,IAAI,iBAAiB,CAAA,GAAA,uJAAA,CAAA,UAAc,AAAD,EAAE,UAAU,QAAQ,kBAAkB,MAAM,CAAC,aAAa;gBAC5F,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,kBAAkB,MAAM,CAAC,UAAU,SAAS,CAAA,GAAA,mJAAA,CAAA,UAAU,AAAD,EAAE,iBAAiB;YAC/G;QACF;IACF;AACF;AACA,IAAI,oBAAoB,EAAE,CAAC,MAAM,CAAC,6IAAA,CAAA,uBAAoB,EAAE,mJAAA,CAAA,qBAAkB,EAAE,GAAG,CAAC,SAAU,IAAI;IAC5F,OAAO,KAAK,IAAI;AAClB;AAEA,SAAS,mBAAmB,QAAQ;IAClC,OAAO,kBAAkB,OAAO,CAAC,cAAc,CAAC;AAClD;AAEA,SAAS,UAAU,KAAK;IACtB,OAAO,CAAC,MAAM,OAAO,CAAC,UAAU,CAAC,CAAA,GAAA,oJAAA,CAAA,6BAA0B,AAAD,EAAE,UAAU,CAAA,GAAA,oJAAA,CAAA,4BAAyB,AAAD,EAAE,MAAM;AACxG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 164, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { isCompositeType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n */\nexport function FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        var type = typeFromAST(context.getSchema(), typeCondition);\n\n        if (type && !isCompositeType(type)) {\n          var typeStr = print(typeCondition);\n          context.reportError(new GraphQLError(\"Fragment cannot condition on non composite type \\\"\".concat(typeStr, \"\\\".\"), typeCondition));\n        }\n      }\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var type = typeFromAST(context.getSchema(), node.typeCondition);\n\n      if (type && !isCompositeType(type)) {\n        var typeStr = print(node.typeCondition);\n        context.reportError(new GraphQLError(\"Fragment \\\"\".concat(node.name.value, \"\\\" cannot condition on non composite type \\\"\").concat(typeStr, \"\\\".\"), node.typeCondition));\n      }\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AASO,SAAS,8BAA8B,OAAO;IACnD,OAAO;QACL,gBAAgB,SAAS,eAAe,IAAI;YAC1C,IAAI,gBAAgB,KAAK,aAAa;YAEtC,IAAI,eAAe;gBACjB,IAAI,OAAO,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,SAAS,IAAI;gBAE5C,IAAI,QAAQ,CAAC,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD,EAAE,OAAO;oBAClC,IAAI,UAAU,CAAA,GAAA,iJAAA,CAAA,QAAK,AAAD,EAAE;oBACpB,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,qDAAqD,MAAM,CAAC,SAAS,QAAQ;gBACpH;YACF;QACF;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,IAAI,OAAO,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,SAAS,IAAI,KAAK,aAAa;YAE9D,IAAI,QAAQ,CAAC,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD,EAAE,OAAO;gBAClC,IAAI,UAAU,CAAA,GAAA,iJAAA,CAAA,QAAK,AAAD,EAAE,KAAK,aAAa;gBACtC,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,cAAc,MAAM,CAAC,KAAK,IAAI,CAAC,KAAK,EAAE,gDAAgD,MAAM,CAAC,SAAS,QAAQ,KAAK,aAAa;YACvK;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { isInputType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\n\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n */\nexport function VariablesAreInputTypesRule(context) {\n  return {\n    VariableDefinition: function VariableDefinition(node) {\n      var type = typeFromAST(context.getSchema(), node.type);\n\n      if (type && !isInputType(type)) {\n        var variableName = node.variable.name.value;\n        var typeName = print(node.type);\n        context.reportError(new GraphQLError(\"Variable \\\"$\".concat(variableName, \"\\\" cannot be non-input type \\\"\").concat(typeName, \"\\\".\"), node.type));\n      }\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AAQO,SAAS,2BAA2B,OAAO;IAChD,OAAO;QACL,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,IAAI,OAAO,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,SAAS,IAAI,KAAK,IAAI;YAErD,IAAI,QAAQ,CAAC,CAAA,GAAA,gJAAA,CAAA,cAAW,AAAD,EAAE,OAAO;gBAC9B,IAAI,eAAe,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK;gBAC3C,IAAI,WAAW,CAAA,GAAA,iJAAA,CAAA,QAAK,AAAD,EAAE,KAAK,IAAI;gBAC9B,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,eAAe,MAAM,CAAC,cAAc,kCAAkC,MAAM,CAAC,UAAU,QAAQ,KAAK,IAAI;YAC/I;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 227, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ScalarLeafsRule.mjs"],"sourcesContent":["import inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { getNamedType, isLeafType } from \"../../type/definition.mjs\";\n\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\nexport function ScalarLeafsRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getType();\n      var selectionSet = node.selectionSet;\n\n      if (type) {\n        if (isLeafType(getNamedType(type))) {\n          if (selectionSet) {\n            var fieldName = node.name.value;\n            var typeStr = inspect(type);\n            context.reportError(new GraphQLError(\"Field \\\"\".concat(fieldName, \"\\\" must not have a selection since type \\\"\").concat(typeStr, \"\\\" has no subfields.\"), selectionSet));\n          }\n        } else if (!selectionSet) {\n          var _fieldName = node.name.value;\n\n          var _typeStr = inspect(type);\n\n          context.reportError(new GraphQLError(\"Field \\\"\".concat(_fieldName, \"\\\" of type \\\"\").concat(_typeStr, \"\\\" must have a selection of subfields. Did you mean \\\"\").concat(_fieldName, \" { ... }\\\"?\"), node));\n        }\n      }\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAQO,SAAS,gBAAgB,OAAO;IACrC,OAAO;QACL,OAAO,SAAS,MAAM,IAAI;YACxB,IAAI,OAAO,QAAQ,OAAO;YAC1B,IAAI,eAAe,KAAK,YAAY;YAEpC,IAAI,MAAM;gBACR,IAAI,CAAA,GAAA,gJAAA,CAAA,aAAU,AAAD,EAAE,CAAA,GAAA,gJAAA,CAAA,eAAY,AAAD,EAAE,QAAQ;oBAClC,IAAI,cAAc;wBAChB,IAAI,YAAY,KAAK,IAAI,CAAC,KAAK;wBAC/B,IAAI,UAAU,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;wBACtB,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,WAAW,MAAM,CAAC,WAAW,8CAA8C,MAAM,CAAC,SAAS,yBAAyB;oBAC3J;gBACF,OAAO,IAAI,CAAC,cAAc;oBACxB,IAAI,aAAa,KAAK,IAAI,CAAC,KAAK;oBAEhC,IAAI,WAAW,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;oBAEvB,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,WAAW,MAAM,CAAC,YAAY,iBAAiB,MAAM,CAAC,UAAU,0DAA0D,MAAM,CAAC,YAAY,gBAAgB;gBACpM;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 261, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs"],"sourcesContent":["import arrayFrom from \"../../polyfills/arrayFrom.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isObjectType, isInterfaceType, isAbstractType } from \"../../type/definition.mjs\";\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestion = didYouMean('to use an inline fragment on', getSuggestedTypeNames(schema, type, fieldName)); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n\n          context.reportError(new GraphQLError(\"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type.name, \"\\\".\") + suggestion, node));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  var suggestedTypes = new Set();\n  var usageCount = Object.create(null);\n\n  for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {\n    var possibleType = _schema$getPossibleTy2[_i2];\n\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {\n      var _usageCount$possibleI;\n\n      var possibleInterface = _possibleType$getInte2[_i4];\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;\n    }\n  }\n\n  return arrayFrom(suggestedTypes).sort(function (typeA, typeB) {\n    // Suggest both interface and object types based on how common they are.\n    var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n    if (usageCountDiff !== 0) {\n      return usageCountDiff;\n    } // Suggest super types first followed by subtypes\n\n\n    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n      return -1;\n    }\n\n    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n      return 1;\n    }\n\n    return typeA.name.localeCompare(typeB.name);\n  }).map(function (x) {\n    return x.name;\n  });\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 353, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n */\nexport function UniqueFragmentNamesRule(context) {\n  var knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var fragmentName = node.name.value;\n\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(new GraphQLError(\"There can be only one fragment named \\\"\".concat(fragmentName, \"\\\".\"), [knownFragmentNames[fragmentName], node.name]));\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,wBAAwB,OAAO;IAC7C,IAAI,qBAAqB,OAAO,MAAM,CAAC;IACvC,OAAO;QACL,qBAAqB,SAAS;YAC5B,OAAO;QACT;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,IAAI,eAAe,KAAK,IAAI,CAAC,KAAK;YAElC,IAAI,kBAAkB,CAAC,aAAa,EAAE;gBACpC,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,0CAA0C,MAAM,CAAC,cAAc,QAAQ;oBAAC,kBAAkB,CAAC,aAAa;oBAAE,KAAK,IAAI;iBAAC;YAC3J,OAAO;gBACL,kBAAkB,CAAC,aAAa,GAAG,KAAK,IAAI;YAC9C;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 382, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n */\nexport function KnownFragmentNamesRule(context) {\n  return {\n    FragmentSpread: function FragmentSpread(node) {\n      var fragmentName = node.name.value;\n      var fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        context.reportError(new GraphQLError(\"Unknown fragment \\\"\".concat(fragmentName, \"\\\".\"), node.name));\n      }\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAQO,SAAS,uBAAuB,OAAO;IAC5C,OAAO;QACL,gBAAgB,SAAS,eAAe,IAAI;YAC1C,IAAI,eAAe,KAAK,IAAI,CAAC,KAAK;YAClC,IAAI,WAAW,QAAQ,WAAW,CAAC;YAEnC,IAAI,CAAC,UAAU;gBACb,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,sBAAsB,MAAM,CAAC,cAAc,QAAQ,KAAK,IAAI;YACnG;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 402, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n */\nexport function NoUnusedFragmentsRule(context) {\n  var operationDefs = [];\n  var fragmentDefs = [];\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n    Document: {\n      leave: function leave() {\n        var fragmentNameUsed = Object.create(null);\n\n        for (var _i2 = 0; _i2 < operationDefs.length; _i2++) {\n          var operation = operationDefs[_i2];\n\n          for (var _i4 = 0, _context$getRecursive2 = context.getRecursivelyReferencedFragments(operation); _i4 < _context$getRecursive2.length; _i4++) {\n            var fragment = _context$getRecursive2[_i4];\n            fragmentNameUsed[fragment.name.value] = true;\n          }\n        }\n\n        for (var _i6 = 0; _i6 < fragmentDefs.length; _i6++) {\n          var fragmentDef = fragmentDefs[_i6];\n          var fragName = fragmentDef.name.value;\n\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(new GraphQLError(\"Fragment \\\"\".concat(fragName, \"\\\" is never used.\"), fragmentDef));\n          }\n        }\n      }\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAQO,SAAS,sBAAsB,OAAO;IAC3C,IAAI,gBAAgB,EAAE;IACtB,IAAI,eAAe,EAAE;IACrB,OAAO;QACL,qBAAqB,SAAS,oBAAoB,IAAI;YACpD,cAAc,IAAI,CAAC;YACnB,OAAO;QACT;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,aAAa,IAAI,CAAC;YAClB,OAAO;QACT;QACA,UAAU;YACR,OAAO,SAAS;gBACd,IAAI,mBAAmB,OAAO,MAAM,CAAC;gBAErC,IAAK,IAAI,MAAM,GAAG,MAAM,cAAc,MAAM,EAAE,MAAO;oBACnD,IAAI,YAAY,aAAa,CAAC,IAAI;oBAElC,IAAK,IAAI,MAAM,GAAG,yBAAyB,QAAQ,iCAAiC,CAAC,YAAY,MAAM,uBAAuB,MAAM,EAAE,MAAO;wBAC3I,IAAI,WAAW,sBAAsB,CAAC,IAAI;wBAC1C,gBAAgB,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,GAAG;oBAC1C;gBACF;gBAEA,IAAK,IAAI,MAAM,GAAG,MAAM,aAAa,MAAM,EAAE,MAAO;oBAClD,IAAI,cAAc,YAAY,CAAC,IAAI;oBACnC,IAAI,WAAW,YAAY,IAAI,CAAC,KAAK;oBAErC,IAAI,gBAAgB,CAAC,SAAS,KAAK,MAAM;wBACvC,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,cAAc,MAAM,CAAC,UAAU,sBAAsB;oBAC5F;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 444, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs"],"sourcesContent":["import inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isCompositeType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\nimport { doTypesOverlap } from \"../../utilities/typeComparators.mjs\";\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        var parentTypeStr = inspect(parentType);\n        var fragTypeStr = inspect(fragType);\n        context.reportError(new GraphQLError(\"Fragment cannot be spread here as objects of type \\\"\".concat(parentTypeStr, \"\\\" can never be of type \\\"\").concat(fragTypeStr, \"\\\".\"), node));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        var parentTypeStr = inspect(parentType);\n        var fragTypeStr = inspect(fragType);\n        context.reportError(new GraphQLError(\"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of type \\\"\").concat(parentTypeStr, \"\\\" can never be of type \\\"\").concat(fragTypeStr, \"\\\".\"), node));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;;;;;AASO,SAAS,4BAA4B,OAAO;IACjD,OAAO;QACL,gBAAgB,SAAS,eAAe,IAAI;YAC1C,IAAI,WAAW,QAAQ,OAAO;YAC9B,IAAI,aAAa,QAAQ,aAAa;YAEtC,IAAI,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD,EAAE,aAAa,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD,EAAE,eAAe,CAAC,CAAA,GAAA,0JAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ,SAAS,IAAI,UAAU,aAAa;gBAC1H,IAAI,gBAAgB,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;gBAC5B,IAAI,cAAc,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;gBAC1B,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,uDAAuD,MAAM,CAAC,eAAe,8BAA8B,MAAM,CAAC,aAAa,QAAQ;YAC9K;QACF;QACA,gBAAgB,SAAS,eAAe,IAAI;YAC1C,IAAI,WAAW,KAAK,IAAI,CAAC,KAAK;YAC9B,IAAI,WAAW,gBAAgB,SAAS;YACxC,IAAI,aAAa,QAAQ,aAAa;YAEtC,IAAI,YAAY,cAAc,CAAC,CAAA,GAAA,0JAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ,SAAS,IAAI,UAAU,aAAa;gBACxF,IAAI,gBAAgB,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;gBAC5B,IAAI,cAAc,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;gBAC1B,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,cAAc,MAAM,CAAC,UAAU,kDAAkD,MAAM,CAAC,eAAe,8BAA8B,MAAM,CAAC,aAAa,QAAQ;YACxM;QACF;IACF;AACF;AAEA,SAAS,gBAAgB,OAAO,EAAE,IAAI;IACpC,IAAI,OAAO,QAAQ,WAAW,CAAC;IAE/B,IAAI,MAAM;QACR,IAAI,OAAO,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,SAAS,IAAI,KAAK,aAAa;QAE9D,IAAI,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD,EAAE,OAAO;YACzB,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 493, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var _i2 = 0; _i2 < spreadNodes.length; _i2++) {\n      var spreadNode = spreadNodes[_i2];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        var spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        var viaPath = cyclePath.slice(0, -1).map(function (s) {\n          return '\"' + s.name.value + '\"';\n        }).join(', ');\n        context.reportError(new GraphQLError(\"Cannot spread fragment \\\"\".concat(spreadName, \"\\\" within itself\") + (viaPath !== '' ? \" via \".concat(viaPath, \".\") : '.'), cyclePath));\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n"],"names":[],"mappings":";;;AAAA;;AACO,SAAS,qBAAqB,OAAO;IAC1C,8EAA8E;IAC9E,gCAAgC;IAChC,IAAI,eAAe,OAAO,MAAM,CAAC,OAAO,uDAAuD;IAE/F,IAAI,aAAa,EAAE,EAAE,8BAA8B;IAEnD,IAAI,wBAAwB,OAAO,MAAM,CAAC;IAC1C,OAAO;QACL,qBAAqB,SAAS;YAC5B,OAAO;QACT;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,qBAAqB;YACrB,OAAO;QACT;IACF,GAAG,mDAAmD;;;IACtD,wEAAwE;IACxE,yCAAyC;IAEzC,SAAS,qBAAqB,QAAQ;QACpC,IAAI,YAAY,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,EAAE;YACrC;QACF;QAEA,IAAI,eAAe,SAAS,IAAI,CAAC,KAAK;QACtC,YAAY,CAAC,aAAa,GAAG;QAC7B,IAAI,cAAc,QAAQ,kBAAkB,CAAC,SAAS,YAAY;QAElE,IAAI,YAAY,MAAM,KAAK,GAAG;YAC5B;QACF;QAEA,qBAAqB,CAAC,aAAa,GAAG,WAAW,MAAM;QAEvD,IAAK,IAAI,MAAM,GAAG,MAAM,YAAY,MAAM,EAAE,MAAO;YACjD,IAAI,aAAa,WAAW,CAAC,IAAI;YACjC,IAAI,aAAa,WAAW,IAAI,CAAC,KAAK;YACtC,IAAI,aAAa,qBAAqB,CAAC,WAAW;YAClD,WAAW,IAAI,CAAC;YAEhB,IAAI,eAAe,WAAW;gBAC5B,IAAI,iBAAiB,QAAQ,WAAW,CAAC;gBAEzC,IAAI,gBAAgB;oBAClB,qBAAqB;gBACvB;YACF,OAAO;gBACL,IAAI,YAAY,WAAW,KAAK,CAAC;gBACjC,IAAI,UAAU,UAAU,KAAK,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,SAAU,CAAC;oBAClD,OAAO,MAAM,EAAE,IAAI,CAAC,KAAK,GAAG;gBAC9B,GAAG,IAAI,CAAC;gBACR,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,4BAA4B,MAAM,CAAC,YAAY,sBAAsB,CAAC,YAAY,KAAK,QAAQ,MAAM,CAAC,SAAS,OAAO,GAAG,GAAG;YACnK;YAEA,WAAW,GAAG;QAChB;QAEA,qBAAqB,CAAC,aAAa,GAAG;IACxC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 554, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique variable names\n *\n * A GraphQL operation is only valid if all its variables are uniquely named.\n */\nexport function UniqueVariableNamesRule(context) {\n  var knownVariableNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      knownVariableNames = Object.create(null);\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      var variableName = node.variable.name.value;\n\n      if (knownVariableNames[variableName]) {\n        context.reportError(new GraphQLError(\"There can be only one variable named \\\"$\".concat(variableName, \"\\\".\"), [knownVariableNames[variableName], node.variable.name]));\n      } else {\n        knownVariableNames[variableName] = node.variable.name;\n      }\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,wBAAwB,OAAO;IAC7C,IAAI,qBAAqB,OAAO,MAAM,CAAC;IACvC,OAAO;QACL,qBAAqB,SAAS;YAC5B,qBAAqB,OAAO,MAAM,CAAC;QACrC;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,IAAI,eAAe,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK;YAE3C,IAAI,kBAAkB,CAAC,aAAa,EAAE;gBACpC,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,2CAA2C,MAAM,CAAC,cAAc,QAAQ;oBAAC,kBAAkB,CAAC,aAAa;oBAAE,KAAK,QAAQ,CAAC,IAAI;iBAAC;YACrK,OAAO;gBACL,kBAAkB,CAAC,aAAa,GAAG,KAAK,QAAQ,CAAC,IAAI;YACvD;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 582, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n */\nexport function NoUndefinedVariablesRule(context) {\n  var variableNameDefined = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        variableNameDefined = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          var varName = node.name.value;\n\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(new GraphQLError(operation.name ? \"Variable \\\"$\".concat(varName, \"\\\" is not defined by operation \\\"\").concat(operation.name.value, \"\\\".\") : \"Variable \\\"$\".concat(varName, \"\\\" is not defined.\"), [node, operation]));\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAQO,SAAS,yBAAyB,OAAO;IAC9C,IAAI,sBAAsB,OAAO,MAAM,CAAC;IACxC,OAAO;QACL,qBAAqB;YACnB,OAAO,SAAS;gBACd,sBAAsB,OAAO,MAAM,CAAC;YACtC;YACA,OAAO,SAAS,MAAM,SAAS;gBAC7B,IAAI,SAAS,QAAQ,0BAA0B,CAAC;gBAEhD,IAAK,IAAI,MAAM,GAAG,MAAM,OAAO,MAAM,EAAE,MAAO;oBAC5C,IAAI,QAAQ,MAAM,CAAC,IAAI;oBACvB,IAAI,OAAO,MAAM,IAAI;oBACrB,IAAI,UAAU,KAAK,IAAI,CAAC,KAAK;oBAE7B,IAAI,mBAAmB,CAAC,QAAQ,KAAK,MAAM;wBACzC,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,UAAU,IAAI,GAAG,eAAe,MAAM,CAAC,SAAS,qCAAqC,MAAM,CAAC,UAAU,IAAI,CAAC,KAAK,EAAE,SAAS,eAAe,MAAM,CAAC,SAAS,uBAAuB;4BAAC;4BAAM;yBAAU;oBACzO;gBACF;YACF;QACF;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,mBAAmB,CAAC,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG;QAClD;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 618, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n */\nexport function NoUnusedVariablesRule(context) {\n  var variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        variableDefs = [];\n      },\n      leave: function leave(operation) {\n        var variableNameUsed = Object.create(null);\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          variableNameUsed[node.name.value] = true;\n        }\n\n        for (var _i4 = 0, _variableDefs2 = variableDefs; _i4 < _variableDefs2.length; _i4++) {\n          var variableDef = _variableDefs2[_i4];\n          var variableName = variableDef.variable.name.value;\n\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(new GraphQLError(operation.name ? \"Variable \\\"$\".concat(variableName, \"\\\" is never used in operation \\\"\").concat(operation.name.value, \"\\\".\") : \"Variable \\\"$\".concat(variableName, \"\\\" is never used.\"), variableDef));\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(def) {\n      variableDefs.push(def);\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAQO,SAAS,sBAAsB,OAAO;IAC3C,IAAI,eAAe,EAAE;IACrB,OAAO;QACL,qBAAqB;YACnB,OAAO,SAAS;gBACd,eAAe,EAAE;YACnB;YACA,OAAO,SAAS,MAAM,SAAS;gBAC7B,IAAI,mBAAmB,OAAO,MAAM,CAAC;gBACrC,IAAI,SAAS,QAAQ,0BAA0B,CAAC;gBAEhD,IAAK,IAAI,MAAM,GAAG,MAAM,OAAO,MAAM,EAAE,MAAO;oBAC5C,IAAI,QAAQ,MAAM,CAAC,IAAI;oBACvB,IAAI,OAAO,MAAM,IAAI;oBACrB,gBAAgB,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,GAAG;gBACtC;gBAEA,IAAK,IAAI,MAAM,GAAG,iBAAiB,cAAc,MAAM,eAAe,MAAM,EAAE,MAAO;oBACnF,IAAI,cAAc,cAAc,CAAC,IAAI;oBACrC,IAAI,eAAe,YAAY,QAAQ,CAAC,IAAI,CAAC,KAAK;oBAElD,IAAI,gBAAgB,CAAC,aAAa,KAAK,MAAM;wBAC3C,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,UAAU,IAAI,GAAG,eAAe,MAAM,CAAC,cAAc,oCAAoC,MAAM,CAAC,UAAU,IAAI,CAAC,KAAK,EAAE,SAAS,eAAe,MAAM,CAAC,cAAc,sBAAsB;oBAChO;gBACF;YACF;QACF;QACA,oBAAoB,SAAS,mBAAmB,GAAG;YACjD,aAAa,IAAI,CAAC;QACpB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 656, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownDirectivesRule.mjs"],"sourcesContent":["import inspect from \"../../jsutils/inspect.mjs\";\nimport invariant from \"../../jsutils/invariant.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { DirectiveLocation } from \"../../language/directiveLocation.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n */\nexport function KnownDirectivesRule(context) {\n  var locationsMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    locationsMap[directive.name] = directive.locations;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map(function (name) {\n        return name.value;\n      });\n    }\n  }\n\n  return {\n    Directive: function Directive(node, _key, _parent, _path, ancestors) {\n      var name = node.name.value;\n      var locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(new GraphQLError(\"Unknown directive \\\"@\".concat(name, \"\\\".\"), node));\n        return;\n      }\n\n      var candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && locations.indexOf(candidateLocation) === -1) {\n        context.reportError(new GraphQLError(\"Directive \\\"@\".concat(name, \"\\\" may not be used on \").concat(candidateLocation, \".\"), node));\n      }\n    }\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  var appliedTo = ancestors[ancestors.length - 1];\n  !Array.isArray(appliedTo) || invariant(0);\n\n  switch (appliedTo.kind) {\n    case Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n\n    case Kind.FIELD:\n      return DirectiveLocation.FIELD;\n\n    case Kind.FRAGMENT_SPREAD:\n      return DirectiveLocation.FRAGMENT_SPREAD;\n\n    case Kind.INLINE_FRAGMENT:\n      return DirectiveLocation.INLINE_FRAGMENT;\n\n    case Kind.FRAGMENT_DEFINITION:\n      return DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case Kind.VARIABLE_DEFINITION:\n      return DirectiveLocation.VARIABLE_DEFINITION;\n\n    case Kind.SCHEMA_DEFINITION:\n    case Kind.SCHEMA_EXTENSION:\n      return DirectiveLocation.SCHEMA;\n\n    case Kind.SCALAR_TYPE_DEFINITION:\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return DirectiveLocation.SCALAR;\n\n    case Kind.OBJECT_TYPE_DEFINITION:\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.OBJECT;\n\n    case Kind.FIELD_DEFINITION:\n      return DirectiveLocation.FIELD_DEFINITION;\n\n    case Kind.INTERFACE_TYPE_DEFINITION:\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return DirectiveLocation.INTERFACE;\n\n    case Kind.UNION_TYPE_DEFINITION:\n    case Kind.UNION_TYPE_EXTENSION:\n      return DirectiveLocation.UNION;\n\n    case Kind.ENUM_TYPE_DEFINITION:\n    case Kind.ENUM_TYPE_EXTENSION:\n      return DirectiveLocation.ENUM;\n\n    case Kind.ENUM_VALUE_DEFINITION:\n      return DirectiveLocation.ENUM_VALUE;\n\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.INPUT_OBJECT;\n\n    case Kind.INPUT_VALUE_DEFINITION:\n      {\n        var parentNode = ancestors[ancestors.length - 3];\n        return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;\n      }\n  }\n}\n\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case 'query':\n      return DirectiveLocation.QUERY;\n\n    case 'mutation':\n      return DirectiveLocation.MUTATION;\n\n    case 'subscription':\n      return DirectiveLocation.SUBSCRIPTION;\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected operation: ' + inspect(operation));\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 766, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isTypeDefinitionNode, isTypeExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\nexport function UniqueDirectivesPerLocationRule(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  var schemaDirectives = Object.create(null);\n  var typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      if (node.directives == null) {\n        return;\n      }\n\n      var seenDirectives;\n\n      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        var typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++) {\n        var _directive = _node$directives2[_i6];\n        var directiveName = _directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(new GraphQLError(\"The directive \\\"@\".concat(directiveName, \"\\\" can only be used once at this location.\"), [seenDirectives[directiveName], _directive]));\n          } else {\n            seenDirectives[directiveName] = _directive;\n          }\n        }\n      }\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AAQO,SAAS,gCAAgC,OAAO;IACrD,IAAI,qBAAqB,OAAO,MAAM,CAAC;IACvC,IAAI,SAAS,QAAQ,SAAS;IAC9B,IAAI,oBAAoB,SAAS,OAAO,aAAa,KAAK,gJAAA,CAAA,sBAAmB;IAE7E,IAAK,IAAI,MAAM,GAAG,MAAM,kBAAkB,MAAM,EAAE,MAAO;QACvD,IAAI,YAAY,iBAAiB,CAAC,IAAI;QACtC,kBAAkB,CAAC,UAAU,IAAI,CAAC,GAAG,CAAC,UAAU,YAAY;IAC9D;IAEA,IAAI,iBAAiB,QAAQ,WAAW,GAAG,WAAW;IAEtD,IAAK,IAAI,MAAM,GAAG,MAAM,eAAe,MAAM,EAAE,MAAO;QACpD,IAAI,MAAM,cAAc,CAAC,IAAI;QAE7B,IAAI,IAAI,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,oBAAoB,EAAE;YAC1C,kBAAkB,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,UAAU;QACtD;IACF;IAEA,IAAI,mBAAmB,OAAO,MAAM,CAAC;IACrC,IAAI,oBAAoB,OAAO,MAAM,CAAC;IACtC,OAAO;QACL,uEAAuE;QACvE,sEAAsE;QACtE,0BAA0B;QAC1B,OAAO,SAAS,MAAM,IAAI;YACxB,IAAI,KAAK,UAAU,IAAI,MAAM;gBAC3B;YACF;YAEA,IAAI;YAEJ,IAAI,KAAK,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,iBAAiB,IAAI,KAAK,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,gBAAgB,EAAE;gBAC/E,iBAAiB;YACnB,OAAO,IAAI,CAAA,GAAA,oJAAA,CAAA,uBAAoB,AAAD,EAAE,SAAS,CAAA,GAAA,oJAAA,CAAA,sBAAmB,AAAD,EAAE,OAAO;gBAClE,IAAI,WAAW,KAAK,IAAI,CAAC,KAAK;gBAC9B,iBAAiB,iBAAiB,CAAC,SAAS;gBAE5C,IAAI,mBAAmB,WAAW;oBAChC,iBAAiB,CAAC,SAAS,GAAG,iBAAiB,OAAO,MAAM,CAAC;gBAC/D;YACF,OAAO;gBACL,iBAAiB,OAAO,MAAM,CAAC;YACjC;YAEA,IAAK,IAAI,MAAM,GAAG,oBAAoB,KAAK,UAAU,EAAE,MAAM,kBAAkB,MAAM,EAAE,MAAO;gBAC5F,IAAI,aAAa,iBAAiB,CAAC,IAAI;gBACvC,IAAI,gBAAgB,WAAW,IAAI,CAAC,KAAK;gBAEzC,IAAI,kBAAkB,CAAC,cAAc,EAAE;oBACrC,IAAI,cAAc,CAAC,cAAc,EAAE;wBACjC,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,oBAAoB,MAAM,CAAC,eAAe,+CAA+C;4BAAC,cAAc,CAAC,cAAc;4BAAE;yBAAW;oBAC3K,OAAO;wBACL,cAAc,CAAC,cAAc,GAAG;oBAClC;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 835, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n */\nexport function KnownArgumentNamesRule(context) {\n  return _objectSpread(_objectSpread({}, KnownArgumentNamesOnDirectivesRule(context)), {}, {\n    Argument: function Argument(argNode) {\n      var argDef = context.getArgument();\n      var fieldDef = context.getFieldDef();\n      var parentType = context.getParentType();\n\n      if (!argDef && fieldDef && parentType) {\n        var argName = argNode.name.value;\n        var knownArgsNames = fieldDef.args.map(function (arg) {\n          return arg.name;\n        });\n        var suggestions = suggestionList(argName, knownArgsNames);\n        context.reportError(new GraphQLError(\"Unknown argument \\\"\".concat(argName, \"\\\" on field \\\"\").concat(parentType.name, \".\").concat(fieldDef.name, \"\\\".\") + didYouMean(suggestions), argNode));\n      }\n    }\n  });\n}\n/**\n * @internal\n */\n\nexport function KnownArgumentNamesOnDirectivesRule(context) {\n  var directiveArgs = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    directiveArgs[directive.name] = directive.args.map(function (arg) {\n      return arg.name;\n    });\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];\n      directiveArgs[def.name.value] = argsNodes.map(function (arg) {\n        return arg.name.value;\n      });\n    }\n  }\n\n  return {\n    Directive: function Directive(directiveNode) {\n      var directiveName = directiveNode.name.value;\n      var knownArgs = directiveArgs[directiveName];\n\n      if (directiveNode.arguments && knownArgs) {\n        for (var _i6 = 0, _directiveNode$argume2 = directiveNode.arguments; _i6 < _directiveNode$argume2.length; _i6++) {\n          var argNode = _directiveNode$argume2[_i6];\n          var argName = argNode.name.value;\n\n          if (knownArgs.indexOf(argName) === -1) {\n            var suggestions = suggestionList(argName, knownArgs);\n            context.reportError(new GraphQLError(\"Unknown argument \\\"\".concat(argName, \"\\\" on directive \\\"@\").concat(directiveName, \"\\\".\") + didYouMean(suggestions), argNode));\n          }\n        }\n      }\n\n      return false;\n    }\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 951, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique argument names\n *\n * A GraphQL field or directive is only valid if all supplied arguments are\n * uniquely named.\n */\nexport function UniqueArgumentNamesRule(context) {\n  var knownArgNames = Object.create(null);\n  return {\n    Field: function Field() {\n      knownArgNames = Object.create(null);\n    },\n    Directive: function Directive() {\n      knownArgNames = Object.create(null);\n    },\n    Argument: function Argument(node) {\n      var argName = node.name.value;\n\n      if (knownArgNames[argName]) {\n        context.reportError(new GraphQLError(\"There can be only one argument named \\\"\".concat(argName, \"\\\".\"), [knownArgNames[argName], node.name]));\n      } else {\n        knownArgNames[argName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAQO,SAAS,wBAAwB,OAAO;IAC7C,IAAI,gBAAgB,OAAO,MAAM,CAAC;IAClC,OAAO;QACL,OAAO,SAAS;YACd,gBAAgB,OAAO,MAAM,CAAC;QAChC;QACA,WAAW,SAAS;YAClB,gBAAgB,OAAO,MAAM,CAAC;QAChC;QACA,UAAU,SAAS,SAAS,IAAI;YAC9B,IAAI,UAAU,KAAK,IAAI,CAAC,KAAK;YAE7B,IAAI,aAAa,CAAC,QAAQ,EAAE;gBAC1B,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,0CAA0C,MAAM,CAAC,SAAS,QAAQ;oBAAC,aAAa,CAAC,QAAQ;oBAAE,KAAK,IAAI;iBAAC;YAC5I,OAAO;gBACL,aAAa,CAAC,QAAQ,GAAG,KAAK,IAAI;YACpC;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 983, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs"],"sourcesContent":["import objectValues from \"../../polyfills/objectValues.mjs\";\nimport keyMap from \"../../jsutils/keyMap.mjs\";\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { isLeafType, isInputObjectType, isListType, isNonNullType, isRequiredInputField, getNullableType, getNamedType } from \"../../type/definition.mjs\";\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n */\nexport function ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue: function ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      var type = getNullableType(context.getParentInputType());\n\n      if (!isListType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n    ObjectValue: function ObjectValue(node) {\n      var type = getNamedType(context.getInputType());\n\n      if (!isInputObjectType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n\n      var fieldNodeMap = keyMap(node.fields, function (field) {\n        return field.name.value;\n      });\n\n      for (var _i2 = 0, _objectValues2 = objectValues(type.getFields()); _i2 < _objectValues2.length; _i2++) {\n        var fieldDef = _objectValues2[_i2];\n        var fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && isRequiredInputField(fieldDef)) {\n          var typeStr = inspect(fieldDef.type);\n          context.reportError(new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldDef.name, \"\\\" of required type \\\"\").concat(typeStr, \"\\\" was not provided.\"), node));\n        }\n      }\n    },\n    ObjectField: function ObjectField(node) {\n      var parentType = getNamedType(context.getParentInputType());\n      var fieldType = context.getInputType();\n\n      if (!fieldType && isInputObjectType(parentType)) {\n        var suggestions = suggestionList(node.name.value, Object.keys(parentType.getFields()));\n        context.reportError(new GraphQLError(\"Field \\\"\".concat(node.name.value, \"\\\" is not defined by type \\\"\").concat(parentType.name, \"\\\".\") + didYouMean(suggestions), node));\n      }\n    },\n    NullValue: function NullValue(node) {\n      var type = context.getInputType();\n\n      if (isNonNullType(type)) {\n        context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(inspect(type), \"\\\", found \").concat(print(node), \".\"), node));\n      }\n    },\n    EnumValue: function EnumValue(node) {\n      return isValidValueNode(context, node);\n    },\n    IntValue: function IntValue(node) {\n      return isValidValueNode(context, node);\n    },\n    FloatValue: function FloatValue(node) {\n      return isValidValueNode(context, node);\n    },\n    StringValue: function StringValue(node) {\n      return isValidValueNode(context, node);\n    },\n    BooleanValue: function BooleanValue(node) {\n      return isValidValueNode(context, node);\n    }\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  var locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  var type = getNamedType(locationType);\n\n  if (!isLeafType(type)) {\n    var typeStr = inspect(locationType);\n    context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(typeStr, \"\\\", found \").concat(print(node), \".\"), node));\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n\n  try {\n    var parseResult = type.parseLiteral(node, undefined\n    /* variables */\n    );\n\n    if (parseResult === undefined) {\n      var _typeStr = inspect(locationType);\n\n      context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(_typeStr, \"\\\", found \").concat(print(node), \".\"), node));\n    }\n  } catch (error) {\n    var _typeStr2 = inspect(locationType);\n\n    if (error instanceof GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(_typeStr2, \"\\\", found \").concat(print(node), \"; \") + error.message, node, undefined, undefined, undefined, error));\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1097, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport keyMap from \"../../jsutils/keyMap.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\nimport { isType, isRequiredArgument } from \"../../type/definition.mjs\";\n\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null without a\n * default value) field arguments have been provided.\n */\nexport function ProvidedRequiredArgumentsRule(context) {\n  return _objectSpread(_objectSpread({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {}, {\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave: function leave(fieldNode) {\n        var _fieldNode$arguments;\n\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          return false;\n        } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n        var argNodes = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];\n        var argNodeMap = keyMap(argNodes, function (arg) {\n          return arg.name.value;\n        });\n\n        for (var _i2 = 0, _fieldDef$args2 = fieldDef.args; _i2 < _fieldDef$args2.length; _i2++) {\n          var argDef = _fieldDef$args2[_i2];\n          var argNode = argNodeMap[argDef.name];\n\n          if (!argNode && isRequiredArgument(argDef)) {\n            var argTypeStr = inspect(argDef.type);\n            context.reportError(new GraphQLError(\"Field \\\"\".concat(fieldDef.name, \"\\\" argument \\\"\").concat(argDef.name, \"\\\" of type \\\"\").concat(argTypeStr, \"\\\" is required, but it was not provided.\"), fieldNode));\n          }\n        }\n      }\n    }\n  });\n}\n/**\n * @internal\n */\n\nexport function ProvidedRequiredArgumentsOnDirectivesRule(context) {\n  var requiredArgsMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i4 = 0; _i4 < definedDirectives.length; _i4++) {\n    var directive = definedDirectives[_i4];\n    requiredArgsMap[directive.name] = keyMap(directive.args.filter(isRequiredArgument), function (arg) {\n      return arg.name;\n    });\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i6 = 0; _i6 < astDefinitions.length; _i6++) {\n    var def = astDefinitions[_i6];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];\n      requiredArgsMap[def.name.value] = keyMap(argNodes.filter(isRequiredArgumentNode), function (arg) {\n        return arg.name.value;\n      });\n    }\n  }\n\n  return {\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave: function leave(directiveNode) {\n        var directiveName = directiveNode.name.value;\n        var requiredArgs = requiredArgsMap[directiveName];\n\n        if (requiredArgs) {\n          var _directiveNode$argume;\n\n          // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n          var _argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];\n\n          var argNodeMap = keyMap(_argNodes, function (arg) {\n            return arg.name.value;\n          });\n\n          for (var _i8 = 0, _Object$keys2 = Object.keys(requiredArgs); _i8 < _Object$keys2.length; _i8++) {\n            var argName = _Object$keys2[_i8];\n\n            if (!argNodeMap[argName]) {\n              var argType = requiredArgs[argName].type;\n              var argTypeStr = isType(argType) ? inspect(argType) : print(argType);\n              context.reportError(new GraphQLError(\"Directive \\\"@\".concat(directiveName, \"\\\" argument \\\"\").concat(argName, \"\\\" of type \\\"\").concat(argTypeStr, \"\\\" is required, but it was not provided.\"), directiveNode));\n            }\n          }\n        }\n      }\n    }\n  };\n}\n\nfunction isRequiredArgumentNode(arg) {\n  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1237, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs"],"sourcesContent":["import inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isNonNullType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\nimport { isTypeSubTypeOf } from \"../../utilities/typeComparators.mjs\";\n\n/**\n * Variables passed to field arguments conform to type\n */\nexport function VariablesInAllowedPositionRule(context) {\n  var varDefMap = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        varDefMap = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          var type = _ref2.type;\n          var defaultValue = _ref2.defaultValue;\n          var varName = node.name.value;\n          var varDef = varDefMap[varName];\n\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            var schema = context.getSchema();\n            var varType = typeFromAST(schema, varDef.type);\n\n            if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {\n              var varTypeStr = inspect(varType);\n              var typeStr = inspect(type);\n              context.reportError(new GraphQLError(\"Variable \\\"$\".concat(varName, \"\\\" of type \\\"\").concat(varTypeStr, \"\\\" used in position expecting type \\\"\").concat(typeStr, \"\\\".\"), [varDef, node]));\n            }\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    }\n  };\n}\n/**\n * Returns true if the variable is allowed in the location it was found,\n * which includes considering if default values exist for either the variable\n * or the location at which it is located.\n */\n\nfunction allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {\n  if (isNonNullType(locationType) && !isNonNullType(varType)) {\n    var hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;\n    var hasLocationDefaultValue = locationDefaultValue !== undefined;\n\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n\n    var nullableLocationType = locationType.ofType;\n    return isTypeSubTypeOf(schema, varType, nullableLocationType);\n  }\n\n  return isTypeSubTypeOf(schema, varType, locationType);\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAKO,SAAS,+BAA+B,OAAO;IACpD,IAAI,YAAY,OAAO,MAAM,CAAC;IAC9B,OAAO;QACL,qBAAqB;YACnB,OAAO,SAAS;gBACd,YAAY,OAAO,MAAM,CAAC;YAC5B;YACA,OAAO,SAAS,MAAM,SAAS;gBAC7B,IAAI,SAAS,QAAQ,0BAA0B,CAAC;gBAEhD,IAAK,IAAI,MAAM,GAAG,MAAM,OAAO,MAAM,EAAE,MAAO;oBAC5C,IAAI,QAAQ,MAAM,CAAC,IAAI;oBACvB,IAAI,OAAO,MAAM,IAAI;oBACrB,IAAI,OAAO,MAAM,IAAI;oBACrB,IAAI,eAAe,MAAM,YAAY;oBACrC,IAAI,UAAU,KAAK,IAAI,CAAC,KAAK;oBAC7B,IAAI,SAAS,SAAS,CAAC,QAAQ;oBAE/B,IAAI,UAAU,MAAM;wBAClB,kEAAkE;wBAClE,iEAAiE;wBACjE,oEAAoE;wBACpE,oEAAoE;wBACpE,+CAA+C;wBAC/C,IAAI,SAAS,QAAQ,SAAS;wBAC9B,IAAI,UAAU,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,OAAO,IAAI;wBAE7C,IAAI,WAAW,CAAC,qBAAqB,QAAQ,SAAS,OAAO,YAAY,EAAE,MAAM,eAAe;4BAC9F,IAAI,aAAa,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;4BACzB,IAAI,UAAU,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;4BACtB,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,eAAe,MAAM,CAAC,SAAS,iBAAiB,MAAM,CAAC,YAAY,yCAAyC,MAAM,CAAC,SAAS,QAAQ;gCAAC;gCAAQ;6BAAK;wBACzL;oBACF;gBACF;YACF;QACF;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,SAAS,CAAC,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG;QACxC;IACF;AACF;AACA;;;;CAIC,GAED,SAAS,qBAAqB,MAAM,EAAE,OAAO,EAAE,eAAe,EAAE,YAAY,EAAE,oBAAoB;IAChG,IAAI,CAAA,GAAA,gJAAA,CAAA,gBAAa,AAAD,EAAE,iBAAiB,CAAC,CAAA,GAAA,gJAAA,CAAA,gBAAa,AAAD,EAAE,UAAU;QAC1D,IAAI,iCAAiC,mBAAmB,QAAQ,gBAAgB,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,IAAI;QAClG,IAAI,0BAA0B,yBAAyB;QAEvD,IAAI,CAAC,kCAAkC,CAAC,yBAAyB;YAC/D,OAAO;QACT;QAEA,IAAI,uBAAuB,aAAa,MAAM;QAC9C,OAAO,CAAA,GAAA,0JAAA,CAAA,kBAAe,AAAD,EAAE,QAAQ,SAAS;IAC1C;IAEA,OAAO,CAAA,GAAA,0JAAA,CAAA,kBAAe,AAAD,EAAE,QAAQ,SAAS;AAC1C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1313, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"],"sourcesContent":["import find from \"../../polyfills/find.mjs\";\nimport objectEntries from \"../../polyfills/objectEntries.mjs\";\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { getNamedType, isNonNullType, isLeafType, isObjectType, isListType, isInterfaceType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subReason = _ref[1];\n      return \"subfields \\\"\".concat(responseName, \"\\\" conflict because \") + reasonMessage(subReason);\n    }).join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\n\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  var cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n\n      for (var _i2 = 0; _i2 < conflicts.length; _i2++) {\n        var _ref3 = conflicts[_i2];\n        var _ref2$ = _ref3[0];\n        var responseName = _ref2$[0];\n        var reason = _ref2$[1];\n        var fields1 = _ref3[1];\n        var fields2 = _ref3[2];\n        var reasonMsg = reasonMessage(reason);\n        context.reportError(new GraphQLError(\"Fields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMsg, \". Use different aliases on the fields to fetch both if this was intentional.\"), fields1.concat(fields2)));\n      }\n    }\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  var fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.\n\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  if (fragmentNames2.length !== 0) {\n    for (var j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n    }\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n\n  if (fragmentNames1.length !== 0) {\n    for (var i = 0; i < fragmentNames1.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n    }\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n\n  for (var _i3 = 0; _i3 < fragmentNames1.length; _i3++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i3], fragmentNames2[_j]);\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (var _i5 = 0, _objectEntries2 = objectEntries(fieldMap); _i5 < _objectEntries2.length; _i5++) {\n    var _ref5 = _objectEntries2[_i5];\n    var responseName = _ref5[0];\n    var fields = _ref5[1];\n\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (var _i7 = 0, _Object$keys2 = Object.keys(fieldMap1); _i7 < _Object$keys2.length; _i7++) {\n    var responseName = _Object$keys2[_i7];\n    var fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2]; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);\n\n  if (!areMutuallyExclusive) {\n    var _node1$arguments, _node2$arguments;\n\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [[responseName, \"\\\"\".concat(name1, \"\\\" and \\\"\").concat(name2, \"\\\" are different fields\")], [node1], [node2]];\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n    var args1 = (_node1$arguments = node1.arguments) !== null && _node1$arguments !== void 0 ? _node1$arguments : []; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n    var args2 = (_node2$arguments = node2.arguments) !== null && _node2$arguments !== void 0 ? _node2$arguments : []; // Two field calls must have the same arguments.\n\n    if (!sameArguments(args1, args2)) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  } // The return type for each field.\n\n\n  var type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  var type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, \"they return conflicting types \\\"\".concat(inspect(type1), \"\\\" and \\\"\").concat(inspect(type2), \"\\\"\")], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n\n  return arguments1.every(function (argument1) {\n    var argument2 = find(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n\n    if (!argument2) {\n      return false;\n    }\n\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return print(value1) === print(value2);\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n\n  return cached;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var _i9 = 0, _selectionSet$selecti2 = selectionSet.selections; _i9 < _selectionSet$selecti2.length; _i9++) {\n    var selection = _selectionSet$selecti2[_i9];\n\n    switch (selection.kind) {\n      case Kind.FIELD:\n        {\n          var fieldName = selection.name.value;\n          var fieldDef = void 0;\n\n          if (isObjectType(parentType) || isInterfaceType(parentType)) {\n            fieldDef = parentType.getFields()[fieldName];\n          }\n\n          var responseName = selection.alias ? selection.alias.value : fieldName;\n\n          if (!nodeAndDefs[responseName]) {\n            nodeAndDefs[responseName] = [];\n          }\n\n          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n          break;\n        }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n        {\n          var typeCondition = selection.typeCondition;\n          var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n\n          _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n\n          break;\n        }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref6) {\n      var reason = _ref6[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref7) {\n      var fields1 = _ref7[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref8) {\n      var fields2 = _ref8[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\n\nvar PairSet = /*#__PURE__*/function () {\n  function PairSet() {\n    this._data = Object.create(null);\n  }\n\n  var _proto = PairSet.prototype;\n\n  _proto.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n\n\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n\n    return true;\n  };\n\n  _proto.add = function add(a, b, areMutuallyExclusive) {\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\n\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\n  };\n\n  return PairSet;\n}();\n\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\n  var map = data[a];\n\n  if (!map) {\n    map = Object.create(null);\n    data[a] = map;\n  }\n\n  map[b] = areMutuallyExclusive;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1800, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique input field names\n *\n * A GraphQL input object value is only valid if all supplied fields are\n * uniquely named.\n */\nexport function UniqueInputFieldNamesRule(context) {\n  var knownNameStack = [];\n  var knownNames = Object.create(null);\n  return {\n    ObjectValue: {\n      enter: function enter() {\n        knownNameStack.push(knownNames);\n        knownNames = Object.create(null);\n      },\n      leave: function leave() {\n        knownNames = knownNameStack.pop();\n      }\n    },\n    ObjectField: function ObjectField(node) {\n      var fieldName = node.name.value;\n\n      if (knownNames[fieldName]) {\n        context.reportError(new GraphQLError(\"There can be only one input field named \\\"\".concat(fieldName, \"\\\".\"), [knownNames[fieldName], node.name]));\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAQO,SAAS,0BAA0B,OAAO;IAC/C,IAAI,iBAAiB,EAAE;IACvB,IAAI,aAAa,OAAO,MAAM,CAAC;IAC/B,OAAO;QACL,aAAa;YACX,OAAO,SAAS;gBACd,eAAe,IAAI,CAAC;gBACpB,aAAa,OAAO,MAAM,CAAC;YAC7B;YACA,OAAO,SAAS;gBACd,aAAa,eAAe,GAAG;YACjC;QACF;QACA,aAAa,SAAS,YAAY,IAAI;YACpC,IAAI,YAAY,KAAK,IAAI,CAAC,KAAK;YAE/B,IAAI,UAAU,CAAC,UAAU,EAAE;gBACzB,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,6CAA6C,MAAM,CAAC,WAAW,QAAQ;oBAAC,UAAU,CAAC,UAAU;oBAAE,KAAK,IAAI;iBAAC;YAChJ,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,KAAK,IAAI;YACnC;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1835, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Lone Schema definition\n *\n * A GraphQL document is only valid if it contains only one schema definition.\n */\nexport function LoneSchemaDefinitionRule(context) {\n  var _ref, _ref2, _oldSchema$astNode;\n\n  var oldSchema = context.getSchema();\n  var alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();\n  var schemaDefinitionsCount = 0;\n  return {\n    SchemaDefinition: function SchemaDefinition(node) {\n      if (alreadyDefined) {\n        context.reportError(new GraphQLError('Cannot define a new schema within a schema extension.', node));\n        return;\n      }\n\n      if (schemaDefinitionsCount > 0) {\n        context.reportError(new GraphQLError('Must provide only one schema definition.', node));\n      }\n\n      ++schemaDefinitionsCount;\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,yBAAyB,OAAO;IAC9C,IAAI,MAAM,OAAO;IAEjB,IAAI,YAAY,QAAQ,SAAS;IACjC,IAAI,iBAAiB,CAAC,OAAO,CAAC,QAAQ,CAAC,qBAAqB,cAAc,QAAQ,cAAc,KAAK,IAAI,KAAK,IAAI,UAAU,OAAO,MAAM,QAAQ,uBAAuB,KAAK,IAAI,qBAAqB,cAAc,QAAQ,cAAc,KAAK,IAAI,KAAK,IAAI,UAAU,YAAY,EAAE,MAAM,QAAQ,UAAU,KAAK,IAAI,QAAQ,cAAc,QAAQ,cAAc,KAAK,IAAI,KAAK,IAAI,UAAU,eAAe,EAAE,MAAM,QAAQ,SAAS,KAAK,IAAI,OAAO,cAAc,QAAQ,cAAc,KAAK,IAAI,KAAK,IAAI,UAAU,mBAAmB;IACxgB,IAAI,yBAAyB;IAC7B,OAAO;QACL,kBAAkB,SAAS,iBAAiB,IAAI;YAC9C,IAAI,gBAAgB;gBAClB,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,yDAAyD;gBAC9F;YACF;YAEA,IAAI,yBAAyB,GAAG;gBAC9B,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,4CAA4C;YACnF;YAEA,EAAE;QACJ;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1862, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique operation types\n *\n * A GraphQL document is only valid if it has only one type per operation.\n */\nexport function UniqueOperationTypesRule(context) {\n  var schema = context.getSchema();\n  var definedOperationTypes = Object.create(null);\n  var existingOperationTypes = schema ? {\n    query: schema.getQueryType(),\n    mutation: schema.getMutationType(),\n    subscription: schema.getSubscriptionType()\n  } : {};\n  return {\n    SchemaDefinition: checkOperationTypes,\n    SchemaExtension: checkOperationTypes\n  };\n\n  function checkOperationTypes(node) {\n    var _node$operationTypes;\n\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n\n    for (var _i2 = 0; _i2 < operationTypesNodes.length; _i2++) {\n      var operationType = operationTypesNodes[_i2];\n      var operation = operationType.operation;\n      var alreadyDefinedOperationType = definedOperationTypes[operation];\n\n      if (existingOperationTypes[operation]) {\n        context.reportError(new GraphQLError(\"Type for \".concat(operation, \" already defined in the schema. It cannot be redefined.\"), operationType));\n      } else if (alreadyDefinedOperationType) {\n        context.reportError(new GraphQLError(\"There can be only one \".concat(operation, \" type in schema.\"), [alreadyDefinedOperationType, operationType]));\n      } else {\n        definedOperationTypes[operation] = operationType;\n      }\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,yBAAyB,OAAO;IAC9C,IAAI,SAAS,QAAQ,SAAS;IAC9B,IAAI,wBAAwB,OAAO,MAAM,CAAC;IAC1C,IAAI,yBAAyB,SAAS;QACpC,OAAO,OAAO,YAAY;QAC1B,UAAU,OAAO,eAAe;QAChC,cAAc,OAAO,mBAAmB;IAC1C,IAAI,CAAC;IACL,OAAO;QACL,kBAAkB;QAClB,iBAAiB;IACnB;;;IAEA,SAAS,oBAAoB,IAAI;QAC/B,IAAI;QAEJ,kFAAkF;QAClF,IAAI,sBAAsB,CAAC,uBAAuB,KAAK,cAAc,MAAM,QAAQ,yBAAyB,KAAK,IAAI,uBAAuB,EAAE;QAE9I,IAAK,IAAI,MAAM,GAAG,MAAM,oBAAoB,MAAM,EAAE,MAAO;YACzD,IAAI,gBAAgB,mBAAmB,CAAC,IAAI;YAC5C,IAAI,YAAY,cAAc,SAAS;YACvC,IAAI,8BAA8B,qBAAqB,CAAC,UAAU;YAElE,IAAI,sBAAsB,CAAC,UAAU,EAAE;gBACrC,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,YAAY,MAAM,CAAC,WAAW,4DAA4D;YACjI,OAAO,IAAI,6BAA6B;gBACtC,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,yBAAyB,MAAM,CAAC,WAAW,qBAAqB;oBAAC;oBAA6B;iBAAc;YACnJ,OAAO;gBACL,qBAAqB,CAAC,UAAU,GAAG;YACrC;QACF;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1907, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique type names\n *\n * A GraphQL document is only valid if all defined types have unique names.\n */\nexport function UniqueTypeNamesRule(context) {\n  var knownTypeNames = Object.create(null);\n  var schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName\n  };\n\n  function checkTypeName(node) {\n    var typeName = node.name.value;\n\n    if (schema === null || schema === void 0 ? void 0 : schema.getType(typeName)) {\n      context.reportError(new GraphQLError(\"Type \\\"\".concat(typeName, \"\\\" already exists in the schema. It cannot also be defined in this type definition.\"), node.name));\n      return;\n    }\n\n    if (knownTypeNames[typeName]) {\n      context.reportError(new GraphQLError(\"There can be only one type named \\\"\".concat(typeName, \"\\\".\"), [knownTypeNames[typeName], node.name]));\n    } else {\n      knownTypeNames[typeName] = node.name;\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,oBAAoB,OAAO;IACzC,IAAI,iBAAiB,OAAO,MAAM,CAAC;IACnC,IAAI,SAAS,QAAQ,SAAS;IAC9B,OAAO;QACL,sBAAsB;QACtB,sBAAsB;QACtB,yBAAyB;QACzB,qBAAqB;QACrB,oBAAoB;QACpB,2BAA2B;IAC7B;;;IAEA,SAAS,cAAc,IAAI;QACzB,IAAI,WAAW,KAAK,IAAI,CAAC,KAAK;QAE9B,IAAI,WAAW,QAAQ,WAAW,KAAK,IAAI,KAAK,IAAI,OAAO,OAAO,CAAC,WAAW;YAC5E,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,UAAU,MAAM,CAAC,UAAU,wFAAwF,KAAK,IAAI;YACjK;QACF;QAEA,IAAI,cAAc,CAAC,SAAS,EAAE;YAC5B,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,sCAAsC,MAAM,CAAC,UAAU,QAAQ;gBAAC,cAAc,CAAC,SAAS;gBAAE,KAAK,IAAI;aAAC;QAC3I,OAAO;YACL,cAAc,CAAC,SAAS,GAAG,KAAK,IAAI;QACtC;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1946, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isEnumType } from \"../../type/definition.mjs\";\n\n/**\n * Unique enum value names\n *\n * A GraphQL enum type is only valid if all its values are uniquely named.\n */\nexport function UniqueEnumValueNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  var knownValueNames = Object.create(null);\n  return {\n    EnumTypeDefinition: checkValueUniqueness,\n    EnumTypeExtension: checkValueUniqueness\n  };\n\n  function checkValueUniqueness(node) {\n    var _node$values;\n\n    var typeName = node.name.value;\n\n    if (!knownValueNames[typeName]) {\n      knownValueNames[typeName] = Object.create(null);\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n    var valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n    var valueNames = knownValueNames[typeName];\n\n    for (var _i2 = 0; _i2 < valueNodes.length; _i2++) {\n      var valueDef = valueNodes[_i2];\n      var valueName = valueDef.name.value;\n      var existingType = existingTypeMap[typeName];\n\n      if (isEnumType(existingType) && existingType.getValue(valueName)) {\n        context.reportError(new GraphQLError(\"Enum value \\\"\".concat(typeName, \".\").concat(valueName, \"\\\" already exists in the schema. It cannot also be defined in this type extension.\"), valueDef.name));\n      } else if (valueNames[valueName]) {\n        context.reportError(new GraphQLError(\"Enum value \\\"\".concat(typeName, \".\").concat(valueName, \"\\\" can only be defined once.\"), [valueNames[valueName], valueDef.name]));\n      } else {\n        valueNames[valueName] = valueDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAOO,SAAS,yBAAyB,OAAO;IAC9C,IAAI,SAAS,QAAQ,SAAS;IAC9B,IAAI,kBAAkB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACnE,IAAI,kBAAkB,OAAO,MAAM,CAAC;IACpC,OAAO;QACL,oBAAoB;QACpB,mBAAmB;IACrB;;;IAEA,SAAS,qBAAqB,IAAI;QAChC,IAAI;QAEJ,IAAI,WAAW,KAAK,IAAI,CAAC,KAAK;QAE9B,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE;YAC9B,eAAe,CAAC,SAAS,GAAG,OAAO,MAAM,CAAC;QAC5C,EAAE,kFAAkF;QAGpF,IAAI,aAAa,CAAC,eAAe,KAAK,MAAM,MAAM,QAAQ,iBAAiB,KAAK,IAAI,eAAe,EAAE;QACrG,IAAI,aAAa,eAAe,CAAC,SAAS;QAE1C,IAAK,IAAI,MAAM,GAAG,MAAM,WAAW,MAAM,EAAE,MAAO;YAChD,IAAI,WAAW,UAAU,CAAC,IAAI;YAC9B,IAAI,YAAY,SAAS,IAAI,CAAC,KAAK;YACnC,IAAI,eAAe,eAAe,CAAC,SAAS;YAE5C,IAAI,CAAA,GAAA,gJAAA,CAAA,aAAU,AAAD,EAAE,iBAAiB,aAAa,QAAQ,CAAC,YAAY;gBAChE,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,gBAAgB,MAAM,CAAC,UAAU,KAAK,MAAM,CAAC,WAAW,uFAAuF,SAAS,IAAI;YACnM,OAAO,IAAI,UAAU,CAAC,UAAU,EAAE;gBAChC,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,gBAAgB,MAAM,CAAC,UAAU,KAAK,MAAM,CAAC,WAAW,iCAAiC;oBAAC,UAAU,CAAC,UAAU;oBAAE,SAAS,IAAI;iBAAC;YACtK,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,SAAS,IAAI;YACvC;QACF;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1993, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isObjectType, isInterfaceType, isInputObjectType } from \"../../type/definition.mjs\";\n\n/**\n * Unique field definition names\n *\n * A GraphQL complex type is only valid if all its fields are uniquely named.\n */\nexport function UniqueFieldDefinitionNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  var knownFieldNames = Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness\n  };\n\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n\n    var typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n    var fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n    var fieldNames = knownFieldNames[typeName];\n\n    for (var _i2 = 0; _i2 < fieldNodes.length; _i2++) {\n      var fieldDef = fieldNodes[_i2];\n      var fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(new GraphQLError(\"Field \\\"\".concat(typeName, \".\").concat(fieldName, \"\\\" already exists in the schema. It cannot also be defined in this type extension.\"), fieldDef.name));\n      } else if (fieldNames[fieldName]) {\n        context.reportError(new GraphQLError(\"Field \\\"\".concat(typeName, \".\").concat(fieldName, \"\\\" can only be defined once.\"), [fieldNames[fieldName], fieldDef.name]));\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasField(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    return type.getFields()[fieldName];\n  }\n\n  return false;\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAOO,SAAS,+BAA+B,OAAO;IACpD,IAAI,SAAS,QAAQ,SAAS;IAC9B,IAAI,kBAAkB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACnE,IAAI,kBAAkB,OAAO,MAAM,CAAC;IACpC,OAAO;QACL,2BAA2B;QAC3B,0BAA0B;QAC1B,yBAAyB;QACzB,wBAAwB;QACxB,sBAAsB;QACtB,qBAAqB;IACvB;;;IAEA,SAAS,qBAAqB,IAAI;QAChC,IAAI;QAEJ,IAAI,WAAW,KAAK,IAAI,CAAC,KAAK;QAE9B,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE;YAC9B,eAAe,CAAC,SAAS,GAAG,OAAO,MAAM,CAAC;QAC5C,EAAE,kFAAkF;QAGpF,IAAI,aAAa,CAAC,eAAe,KAAK,MAAM,MAAM,QAAQ,iBAAiB,KAAK,IAAI,eAAe,EAAE;QACrG,IAAI,aAAa,eAAe,CAAC,SAAS;QAE1C,IAAK,IAAI,MAAM,GAAG,MAAM,WAAW,MAAM,EAAE,MAAO;YAChD,IAAI,WAAW,UAAU,CAAC,IAAI;YAC9B,IAAI,YAAY,SAAS,IAAI,CAAC,KAAK;YAEnC,IAAI,SAAS,eAAe,CAAC,SAAS,EAAE,YAAY;gBAClD,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,WAAW,MAAM,CAAC,UAAU,KAAK,MAAM,CAAC,WAAW,uFAAuF,SAAS,IAAI;YAC9L,OAAO,IAAI,UAAU,CAAC,UAAU,EAAE;gBAChC,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,WAAW,MAAM,CAAC,UAAU,KAAK,MAAM,CAAC,WAAW,iCAAiC;oBAAC,UAAU,CAAC,UAAU;oBAAE,SAAS,IAAI;iBAAC;YACjK,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,SAAS,IAAI;YACvC;QACF;QAEA,OAAO;IACT;AACF;AAEA,SAAS,SAAS,IAAI,EAAE,SAAS;IAC/B,IAAI,CAAA,GAAA,gJAAA,CAAA,eAAY,AAAD,EAAE,SAAS,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD,EAAE,SAAS,CAAA,GAAA,gJAAA,CAAA,oBAAiB,AAAD,EAAE,OAAO;QAC1E,OAAO,KAAK,SAAS,EAAE,CAAC,UAAU;IACpC;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2049, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique directive names\n *\n * A GraphQL document is only valid if all defined directives have unique names.\n */\nexport function UniqueDirectiveNamesRule(context) {\n  var knownDirectiveNames = Object.create(null);\n  var schema = context.getSchema();\n  return {\n    DirectiveDefinition: function DirectiveDefinition(node) {\n      var directiveName = node.name.value;\n\n      if (schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName)) {\n        context.reportError(new GraphQLError(\"Directive \\\"@\".concat(directiveName, \"\\\" already exists in the schema. It cannot be redefined.\"), node.name));\n        return;\n      }\n\n      if (knownDirectiveNames[directiveName]) {\n        context.reportError(new GraphQLError(\"There can be only one directive named \\\"@\".concat(directiveName, \"\\\".\"), [knownDirectiveNames[directiveName], node.name]));\n      } else {\n        knownDirectiveNames[directiveName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,yBAAyB,OAAO;IAC9C,IAAI,sBAAsB,OAAO,MAAM,CAAC;IACxC,IAAI,SAAS,QAAQ,SAAS;IAC9B,OAAO;QACL,qBAAqB,SAAS,oBAAoB,IAAI;YACpD,IAAI,gBAAgB,KAAK,IAAI,CAAC,KAAK;YAEnC,IAAI,WAAW,QAAQ,WAAW,KAAK,IAAI,KAAK,IAAI,OAAO,YAAY,CAAC,gBAAgB;gBACtF,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,gBAAgB,MAAM,CAAC,eAAe,6DAA6D,KAAK,IAAI;gBACjJ;YACF;YAEA,IAAI,mBAAmB,CAAC,cAAc,EAAE;gBACtC,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,4CAA4C,MAAM,CAAC,eAAe,QAAQ;oBAAC,mBAAmB,CAAC,cAAc;oBAAE,KAAK,IAAI;iBAAC;YAChK,OAAO;gBACL,mBAAmB,CAAC,cAAc,GAAG,KAAK,IAAI;YAChD;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2080, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs"],"sourcesContent":["var _defKindToExtKind;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport invariant from \"../../jsutils/invariant.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isTypeDefinitionNode } from \"../../language/predicates.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType } from \"../../type/definition.mjs\";\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  var schema = context.getSchema();\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n\n  function checkExtension(node) {\n    var typeName = node.name.value;\n    var defNode = definedTypes[typeName];\n    var existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    var expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        var kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(new GraphQLError(\"Cannot extend non-\".concat(kindStr, \" type \\\"\").concat(typeName, \"\\\".\"), defNode ? [defNode, node] : node));\n      }\n    } else {\n      var allTypeNames = Object.keys(definedTypes);\n\n      if (schema) {\n        allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));\n      }\n\n      var suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(new GraphQLError(\"Cannot extend type \\\"\".concat(typeName, \"\\\" because it is not defined.\") + didYouMean(suggestedTypes), node.name));\n    }\n  }\n}\nvar defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, Kind.SCALAR_TYPE_DEFINITION, Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INTERFACE_TYPE_DEFINITION, Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.UNION_TYPE_DEFINITION, Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INPUT_OBJECT_TYPE_DEFINITION, Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected kind: ' + inspect(kind));\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2203, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/specifiedRules.mjs"],"sourcesContent":["// Spec Section: \"Executable Definitions\"\nimport { ExecutableDefinitionsRule } from \"./rules/ExecutableDefinitionsRule.mjs\"; // Spec Section: \"Operation Name Uniqueness\"\n\nimport { UniqueOperationNamesRule } from \"./rules/UniqueOperationNamesRule.mjs\"; // Spec Section: \"Lone Anonymous Operation\"\n\nimport { LoneAnonymousOperationRule } from \"./rules/LoneAnonymousOperationRule.mjs\"; // Spec Section: \"Subscriptions with Single Root Field\"\n\nimport { SingleFieldSubscriptionsRule } from \"./rules/SingleFieldSubscriptionsRule.mjs\"; // Spec Section: \"Fragment Spread Type Existence\"\n\nimport { KnownTypeNamesRule } from \"./rules/KnownTypeNamesRule.mjs\"; // Spec Section: \"Fragments on Composite Types\"\n\nimport { FragmentsOnCompositeTypesRule } from \"./rules/FragmentsOnCompositeTypesRule.mjs\"; // Spec Section: \"Variables are Input Types\"\n\nimport { VariablesAreInputTypesRule } from \"./rules/VariablesAreInputTypesRule.mjs\"; // Spec Section: \"Leaf Field Selections\"\n\nimport { ScalarLeafsRule } from \"./rules/ScalarLeafsRule.mjs\"; // Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n\nimport { FieldsOnCorrectTypeRule } from \"./rules/FieldsOnCorrectTypeRule.mjs\"; // Spec Section: \"Fragment Name Uniqueness\"\n\nimport { UniqueFragmentNamesRule } from \"./rules/UniqueFragmentNamesRule.mjs\"; // Spec Section: \"Fragment spread target defined\"\n\nimport { KnownFragmentNamesRule } from \"./rules/KnownFragmentNamesRule.mjs\"; // Spec Section: \"Fragments must be used\"\n\nimport { NoUnusedFragmentsRule } from \"./rules/NoUnusedFragmentsRule.mjs\"; // Spec Section: \"Fragment spread is possible\"\n\nimport { PossibleFragmentSpreadsRule } from \"./rules/PossibleFragmentSpreadsRule.mjs\"; // Spec Section: \"Fragments must not form cycles\"\n\nimport { NoFragmentCyclesRule } from \"./rules/NoFragmentCyclesRule.mjs\"; // Spec Section: \"Variable Uniqueness\"\n\nimport { UniqueVariableNamesRule } from \"./rules/UniqueVariableNamesRule.mjs\"; // Spec Section: \"All Variable Used Defined\"\n\nimport { NoUndefinedVariablesRule } from \"./rules/NoUndefinedVariablesRule.mjs\"; // Spec Section: \"All Variables Used\"\n\nimport { NoUnusedVariablesRule } from \"./rules/NoUnusedVariablesRule.mjs\"; // Spec Section: \"Directives Are Defined\"\n\nimport { KnownDirectivesRule } from \"./rules/KnownDirectivesRule.mjs\"; // Spec Section: \"Directives Are Unique Per Location\"\n\nimport { UniqueDirectivesPerLocationRule } from \"./rules/UniqueDirectivesPerLocationRule.mjs\"; // Spec Section: \"Argument Names\"\n\nimport { KnownArgumentNamesRule, KnownArgumentNamesOnDirectivesRule } from \"./rules/KnownArgumentNamesRule.mjs\"; // Spec Section: \"Argument Uniqueness\"\n\nimport { UniqueArgumentNamesRule } from \"./rules/UniqueArgumentNamesRule.mjs\"; // Spec Section: \"Value Type Correctness\"\n\nimport { ValuesOfCorrectTypeRule } from \"./rules/ValuesOfCorrectTypeRule.mjs\"; // Spec Section: \"Argument Optionality\"\n\nimport { ProvidedRequiredArgumentsRule, ProvidedRequiredArgumentsOnDirectivesRule } from \"./rules/ProvidedRequiredArgumentsRule.mjs\"; // Spec Section: \"All Variable Usages Are Allowed\"\n\nimport { VariablesInAllowedPositionRule } from \"./rules/VariablesInAllowedPositionRule.mjs\"; // Spec Section: \"Field Selection Merging\"\n\nimport { OverlappingFieldsCanBeMergedRule } from \"./rules/OverlappingFieldsCanBeMergedRule.mjs\"; // Spec Section: \"Input Object Field Uniqueness\"\n\nimport { UniqueInputFieldNamesRule } from \"./rules/UniqueInputFieldNamesRule.mjs\"; // SDL-specific validation rules\n\nimport { LoneSchemaDefinitionRule } from \"./rules/LoneSchemaDefinitionRule.mjs\";\nimport { UniqueOperationTypesRule } from \"./rules/UniqueOperationTypesRule.mjs\";\nimport { UniqueTypeNamesRule } from \"./rules/UniqueTypeNamesRule.mjs\";\nimport { UniqueEnumValueNamesRule } from \"./rules/UniqueEnumValueNamesRule.mjs\";\nimport { UniqueFieldDefinitionNamesRule } from \"./rules/UniqueFieldDefinitionNamesRule.mjs\";\nimport { UniqueDirectiveNamesRule } from \"./rules/UniqueDirectiveNamesRule.mjs\";\nimport { PossibleTypeExtensionsRule } from \"./rules/PossibleTypeExtensionsRule.mjs\";\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n *\n * The order of the rules in this list has been adjusted to lead to the\n * most clear output when encountering multiple validation errors.\n */\n\nexport var specifiedRules = Object.freeze([ExecutableDefinitionsRule, UniqueOperationNamesRule, LoneAnonymousOperationRule, SingleFieldSubscriptionsRule, KnownTypeNamesRule, FragmentsOnCompositeTypesRule, VariablesAreInputTypesRule, ScalarLeafsRule, FieldsOnCorrectTypeRule, UniqueFragmentNamesRule, KnownFragmentNamesRule, NoUnusedFragmentsRule, PossibleFragmentSpreadsRule, NoFragmentCyclesRule, UniqueVariableNamesRule, NoUndefinedVariablesRule, NoUnusedVariablesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, KnownArgumentNamesRule, UniqueArgumentNamesRule, ValuesOfCorrectTypeRule, ProvidedRequiredArgumentsRule, VariablesInAllowedPositionRule, OverlappingFieldsCanBeMergedRule, UniqueInputFieldNamesRule]);\n/**\n * @internal\n */\n\nexport var specifiedSDLRules = Object.freeze([LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, KnownArgumentNamesOnDirectivesRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, ProvidedRequiredArgumentsOnDirectivesRule]);\n"],"names":[],"mappings":"AAAA,yCAAyC;;;;;AACzC,wTAAmF,4CAA4C;AAE/H,sTAAiF,2CAA2C;AAE5H,0TAAqF,uDAAuD;AAE5I,8TAAyF,iDAAiD;AAE1I,0SAAqE,+CAA+C;AAEpH,gUAA2F,4CAA4C;AAEvI,0TAAqF,wCAAwC;AAE7H,oSAA+D,4EAA4E;AAE3I,oTAA+E,2CAA2C;AAE1H,oTAA+E,iDAAiD;AAEhI,kTAA6E,yCAAyC;AAEtH,gTAA2E,8CAA8C;AAEzH,4TAAuF,iDAAiD;AAExI,8SAAyE,sCAAsC;AAE/G,oTAA+E,4CAA4C;AAE3H,sTAAiF,qCAAqC;AAEtH,gTAA2E,yCAAyC;AAEpH,4SAAuE,qDAAqD;AAE5H,oUAA+F,iCAAiC;AAEhI,kTAAiH,sCAAsC;AAEvJ,oTAA+E,yCAAyC;AAExH,oTAA+E,uCAAuC;AAEtH,gUAAsI,kDAAkD;AAExL,kUAA6F,0CAA0C;AAEvI,sUAAiG,gDAAgD;AAEjJ,wTAAmF,gCAAgC;AAEnH;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQO,IAAI,iBAAiB,OAAO,MAAM,CAAC;IAAC,8KAAA,CAAA,4BAAyB;IAAE,6KAAA,CAAA,2BAAwB;IAAE,+KAAA,CAAA,6BAA0B;IAAE,iLAAA,CAAA,+BAA4B;IAAE,uKAAA,CAAA,qBAAkB;IAAE,kLAAA,CAAA,gCAA6B;IAAE,+KAAA,CAAA,6BAA0B;IAAE,oKAAA,CAAA,kBAAe;IAAE,4KAAA,CAAA,0BAAuB;IAAE,4KAAA,CAAA,0BAAuB;IAAE,2KAAA,CAAA,yBAAsB;IAAE,0KAAA,CAAA,wBAAqB;IAAE,gLAAA,CAAA,8BAA2B;IAAE,yKAAA,CAAA,uBAAoB;IAAE,4KAAA,CAAA,0BAAuB;IAAE,6KAAA,CAAA,2BAAwB;IAAE,0KAAA,CAAA,wBAAqB;IAAE,wKAAA,CAAA,sBAAmB;IAAE,oLAAA,CAAA,kCAA+B;IAAE,2KAAA,CAAA,yBAAsB;IAAE,4KAAA,CAAA,0BAAuB;IAAE,4KAAA,CAAA,0BAAuB;IAAE,kLAAA,CAAA,gCAA6B;IAAE,mLAAA,CAAA,iCAA8B;IAAE,qLAAA,CAAA,mCAAgC;IAAE,8KAAA,CAAA,4BAAyB;CAAC;AAK5sB,IAAI,oBAAoB,OAAO,MAAM,CAAC;IAAC,6KAAA,CAAA,2BAAwB;IAAE,6KAAA,CAAA,2BAAwB;IAAE,wKAAA,CAAA,sBAAmB;IAAE,6KAAA,CAAA,2BAAwB;IAAE,mLAAA,CAAA,iCAA8B;IAAE,6KAAA,CAAA,2BAAwB;IAAE,uKAAA,CAAA,qBAAkB;IAAE,wKAAA,CAAA,sBAAmB;IAAE,oLAAA,CAAA,kCAA+B;IAAE,+KAAA,CAAA,6BAA0B;IAAE,2KAAA,CAAA,qCAAkC;IAAE,4KAAA,CAAA,0BAAuB;IAAE,8KAAA,CAAA,4BAAyB;IAAE,kLAAA,CAAA,4CAAyC;CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2322, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/ValidationContext.mjs"],"sourcesContent":["function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nimport { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\nimport { TypeInfo, visitWithTypeInfo } from \"../utilities/TypeInfo.mjs\";\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport var ASTValidationContext = /*#__PURE__*/function () {\n  function ASTValidationContext(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  var _proto = ASTValidationContext.prototype;\n\n  _proto.reportError = function reportError(error) {\n    this._onError(error);\n  };\n\n  _proto.getDocument = function getDocument() {\n    return this._ast;\n  };\n\n  _proto.getFragment = function getFragment(name) {\n    var fragments = this._fragments;\n\n    if (!fragments) {\n      this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {\n        if (statement.kind === Kind.FRAGMENT_DEFINITION) {\n          frags[statement.name.value] = statement;\n        }\n\n        return frags;\n      }, Object.create(null));\n    }\n\n    return fragments[name];\n  };\n\n  _proto.getFragmentSpreads = function getFragmentSpreads(node) {\n    var spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      var setsToVisit = [node];\n\n      while (setsToVisit.length !== 0) {\n        var set = setsToVisit.pop();\n\n        for (var _i2 = 0, _set$selections2 = set.selections; _i2 < _set$selections2.length; _i2++) {\n          var selection = _set$selections2[_i2];\n\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  };\n\n  _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {\n    var fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      var collectedNames = Object.create(null);\n      var nodesToVisit = [operation.selectionSet];\n\n      while (nodesToVisit.length !== 0) {\n        var node = nodesToVisit.pop();\n\n        for (var _i4 = 0, _this$getFragmentSpre2 = this.getFragmentSpreads(node); _i4 < _this$getFragmentSpre2.length; _i4++) {\n          var spread = _this$getFragmentSpre2[_i4];\n          var fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            var fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  };\n\n  return ASTValidationContext;\n}();\nexport var SDLValidationContext = /*#__PURE__*/function (_ASTValidationContext) {\n  _inheritsLoose(SDLValidationContext, _ASTValidationContext);\n\n  function SDLValidationContext(ast, schema, onError) {\n    var _this;\n\n    _this = _ASTValidationContext.call(this, ast, onError) || this;\n    _this._schema = schema;\n    return _this;\n  }\n\n  var _proto2 = SDLValidationContext.prototype;\n\n  _proto2.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  return SDLValidationContext;\n}(ASTValidationContext);\nexport var ValidationContext = /*#__PURE__*/function (_ASTValidationContext2) {\n  _inheritsLoose(ValidationContext, _ASTValidationContext2);\n\n  function ValidationContext(schema, ast, typeInfo, onError) {\n    var _this2;\n\n    _this2 = _ASTValidationContext2.call(this, ast, onError) || this;\n    _this2._schema = schema;\n    _this2._typeInfo = typeInfo;\n    _this2._variableUsages = new Map();\n    _this2._recursiveVariableUsages = new Map();\n    return _this2;\n  }\n\n  var _proto3 = ValidationContext.prototype;\n\n  _proto3.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  _proto3.getVariableUsages = function getVariableUsages(node) {\n    var usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      var newUsages = [];\n      var typeInfo = new TypeInfo(this._schema);\n      visit(node, visitWithTypeInfo(typeInfo, {\n        VariableDefinition: function VariableDefinition() {\n          return false;\n        },\n        Variable: function Variable(variable) {\n          newUsages.push({\n            node: variable,\n            type: typeInfo.getInputType(),\n            defaultValue: typeInfo.getDefaultValue()\n          });\n        }\n      }));\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  };\n\n  _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {\n    var usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (var _i6 = 0, _this$getRecursivelyR2 = this.getRecursivelyReferencedFragments(operation); _i6 < _this$getRecursivelyR2.length; _i6++) {\n        var frag = _this$getRecursivelyR2[_i6];\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  };\n\n  _proto3.getType = function getType() {\n    return this._typeInfo.getType();\n  };\n\n  _proto3.getParentType = function getParentType() {\n    return this._typeInfo.getParentType();\n  };\n\n  _proto3.getInputType = function getInputType() {\n    return this._typeInfo.getInputType();\n  };\n\n  _proto3.getParentInputType = function getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  };\n\n  _proto3.getFieldDef = function getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  };\n\n  _proto3.getDirective = function getDirective() {\n    return this._typeInfo.getDirective();\n  };\n\n  _proto3.getArgument = function getArgument() {\n    return this._typeInfo.getArgument();\n  };\n\n  _proto3.getEnumValue = function getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  };\n\n  return ValidationContext;\n}(ASTValidationContext);\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2509, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/validate.mjs"],"sourcesContent":["import devAssert from \"../jsutils/devAssert.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { visit, visitInParallel } from \"../language/visitor.mjs\";\nimport { assertValidSchema } from \"../type/validate.mjs\";\nimport { TypeInfo, visitWithTypeInfo } from \"../utilities/TypeInfo.mjs\";\nimport { specifiedRules, specifiedSDLRules } from \"./specifiedRules.mjs\";\nimport { SDLValidationContext, ValidationContext } from \"./ValidationContext.mjs\";\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(schema, documentAST) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;\n  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new TypeInfo(schema);\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    maxErrors: undefined\n  };\n  documentAST || devAssert(0, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  var abortObj = Object.freeze({});\n  var errors = [];\n  var context = new ValidationContext(schema, documentAST, typeInfo, function (error) {\n    if (options.maxErrors != null && errors.length >= options.maxErrors) {\n      errors.push(new GraphQLError('Too many validation errors, error limit reached. Validation aborted.'));\n      throw abortObj;\n    }\n\n    errors.push(error);\n  }); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  var visitor = visitInParallel(rules.map(function (rule) {\n    return rule(context);\n  })); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(documentAST, schemaToExtend) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;\n  var errors = [];\n  var context = new SDLValidationContext(documentAST, schemaToExtend, function (error) {\n    errors.push(error);\n  });\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  var errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  var errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAkBO,SAAS,SAAS,MAAM,EAAE,WAAW;IAC1C,IAAI,QAAQ,UAAU,MAAM,GAAG,KAAK,SAAS,CAAC,EAAE,KAAK,YAAY,SAAS,CAAC,EAAE,GAAG,0JAAA,CAAA,iBAAc;IAC9F,IAAI,WAAW,UAAU,MAAM,GAAG,KAAK,SAAS,CAAC,EAAE,KAAK,YAAY,SAAS,CAAC,EAAE,GAAG,IAAI,mJAAA,CAAA,WAAQ,CAAC;IAChG,IAAI,UAAU,UAAU,MAAM,GAAG,KAAK,SAAS,CAAC,EAAE,KAAK,YAAY,SAAS,CAAC,EAAE,GAAG;QAChF,WAAW;IACb;IACA,eAAe,CAAA,GAAA,kJAAA,CAAA,UAAS,AAAD,EAAE,GAAG,2BAA2B,gEAAgE;IAEvH,CAAA,GAAA,8IAAA,CAAA,oBAAiB,AAAD,EAAE;IAClB,IAAI,WAAW,OAAO,MAAM,CAAC,CAAC;IAC9B,IAAI,SAAS,EAAE;IACf,IAAI,UAAU,IAAI,6JAAA,CAAA,oBAAiB,CAAC,QAAQ,aAAa,UAAU,SAAU,KAAK;QAChF,IAAI,QAAQ,SAAS,IAAI,QAAQ,OAAO,MAAM,IAAI,QAAQ,SAAS,EAAE;YACnE,OAAO,IAAI,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC;YAC7B,MAAM;QACR;QAEA,OAAO,IAAI,CAAC;IACd,IAAI,4EAA4E;IAChF,oDAAoD;IAEpD,IAAI,UAAU,CAAA,GAAA,iJAAA,CAAA,kBAAe,AAAD,EAAE,MAAM,GAAG,CAAC,SAAU,IAAI;QACpD,OAAO,KAAK;IACd,KAAK,qEAAqE;IAE1E,IAAI;QACF,CAAA,GAAA,iJAAA,CAAA,QAAK,AAAD,EAAE,aAAa,CAAA,GAAA,mJAAA,CAAA,oBAAiB,AAAD,EAAE,UAAU;IACjD,EAAE,OAAO,GAAG;QACV,IAAI,MAAM,UAAU;YAClB,MAAM;QACR;IACF;IAEA,OAAO;AACT;AAKO,SAAS,YAAY,WAAW,EAAE,cAAc;IACrD,IAAI,QAAQ,UAAU,MAAM,GAAG,KAAK,SAAS,CAAC,EAAE,KAAK,YAAY,SAAS,CAAC,EAAE,GAAG,0JAAA,CAAA,oBAAiB;IACjG,IAAI,SAAS,EAAE;IACf,IAAI,UAAU,IAAI,6JAAA,CAAA,uBAAoB,CAAC,aAAa,gBAAgB,SAAU,KAAK;QACjF,OAAO,IAAI,CAAC;IACd;IACA,IAAI,WAAW,MAAM,GAAG,CAAC,SAAU,IAAI;QACrC,OAAO,KAAK;IACd;IACA,CAAA,GAAA,iJAAA,CAAA,QAAK,AAAD,EAAE,aAAa,CAAA,GAAA,iJAAA,CAAA,kBAAe,AAAD,EAAE;IACnC,OAAO;AACT;AAQO,SAAS,eAAe,WAAW;IACxC,IAAI,SAAS,YAAY;IAEzB,IAAI,OAAO,MAAM,KAAK,GAAG;QACvB,MAAM,IAAI,MAAM,OAAO,GAAG,CAAC,SAAU,KAAK;YACxC,OAAO,MAAM,OAAO;QACtB,GAAG,IAAI,CAAC;IACV;AACF;AAQO,SAAS,wBAAwB,WAAW,EAAE,MAAM;IACzD,IAAI,SAAS,YAAY,aAAa;IAEtC,IAAI,OAAO,MAAM,KAAK,GAAG;QACvB,MAAM,IAAI,MAAM,OAAO,GAAG,CAAC,SAAU,KAAK;YACxC,OAAO,MAAM,OAAO;QACtB,GAAG,IAAI,CAAC;IACV;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2591, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../../error/GraphQLError.mjs\";\nimport { getNamedType } from \"../../../type/definition.mjs\";\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field: function Field(node) {\n      var fieldDef = context.getFieldDef();\n      var parentType = context.getParentType();\n\n      if (parentType && (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason) != null) {\n        context.reportError(new GraphQLError(\"The field \".concat(parentType.name, \".\").concat(fieldDef.name, \" is deprecated. \") + fieldDef.deprecationReason, node));\n      }\n    },\n    EnumValue: function EnumValue(node) {\n      var type = getNamedType(context.getInputType());\n      var enumValue = context.getEnumValue();\n\n      if (type && (enumValue === null || enumValue === void 0 ? void 0 : enumValue.deprecationReason) != null) {\n        context.reportError(new GraphQLError(\"The enum value \\\"\".concat(type.name, \".\").concat(enumValue.name, \"\\\" is deprecated. \") + enumValue.deprecationReason, node));\n      }\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAYO,SAAS,uBAAuB,OAAO;IAC5C,OAAO;QACL,OAAO,SAAS,MAAM,IAAI;YACxB,IAAI,WAAW,QAAQ,WAAW;YAClC,IAAI,aAAa,QAAQ,aAAa;YAEtC,IAAI,cAAc,CAAC,aAAa,QAAQ,aAAa,KAAK,IAAI,KAAK,IAAI,SAAS,iBAAiB,KAAK,MAAM;gBAC1G,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,aAAa,MAAM,CAAC,WAAW,IAAI,EAAE,KAAK,MAAM,CAAC,SAAS,IAAI,EAAE,sBAAsB,SAAS,iBAAiB,EAAE;YACzJ;QACF;QACA,WAAW,SAAS,UAAU,IAAI;YAChC,IAAI,OAAO,CAAA,GAAA,gJAAA,CAAA,eAAY,AAAD,EAAE,QAAQ,YAAY;YAC5C,IAAI,YAAY,QAAQ,YAAY;YAEpC,IAAI,QAAQ,CAAC,cAAc,QAAQ,cAAc,KAAK,IAAI,KAAK,IAAI,UAAU,iBAAiB,KAAK,MAAM;gBACvG,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,oBAAoB,MAAM,CAAC,KAAK,IAAI,EAAE,KAAK,MAAM,CAAC,UAAU,IAAI,EAAE,wBAAwB,UAAU,iBAAiB,EAAE;YAC9J;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2620, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../../error/GraphQLError.mjs\";\nimport { getNamedType } from \"../../../type/definition.mjs\";\nimport { isIntrospectionType } from \"../../../type/introspection.mjs\";\n\n/**\n * Prohibit introspection queries\n *\n * A GraphQL document is only valid if all fields selected are not fields that\n * return an introspection type.\n *\n * Note: This rule is optional and is not part of the Validation section of the\n * GraphQL Specification. This rule effectively disables introspection, which\n * does not reflect best practices and should only be done if absolutely necessary.\n */\nexport function NoSchemaIntrospectionCustomRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = getNamedType(context.getType());\n\n      if (type && isIntrospectionType(type)) {\n        context.reportError(new GraphQLError(\"GraphQL introspection has been disabled, but the requested query contained the field \\\"\".concat(node.name.value, \"\\\".\"), node));\n      }\n    }\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAYO,SAAS,gCAAgC,OAAO;IACrD,OAAO;QACL,OAAO,SAAS,MAAM,IAAI;YACxB,IAAI,OAAO,CAAA,GAAA,gJAAA,CAAA,eAAY,AAAD,EAAE,QAAQ,OAAO;YAEvC,IAAI,QAAQ,CAAA,GAAA,mJAAA,CAAA,sBAAmB,AAAD,EAAE,OAAO;gBACrC,QAAQ,WAAW,CAAC,IAAI,mJAAA,CAAA,eAAY,CAAC,0FAA0F,MAAM,CAAC,KAAK,IAAI,CAAC,KAAK,EAAE,QAAQ;YACjK;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2645, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExecutableDefinitionsRule = ExecutableDefinitionsRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _kinds = require(\"../../language/kinds\");\n\nvar _predicates = require(\"../../language/predicates\");\n\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n */\nfunction ExecutableDefinitionsRule(context) {\n  return {\n    Document: function Document(node) {\n      for (var _i2 = 0, _node$definitions2 = node.definitions; _i2 < _node$definitions2.length; _i2++) {\n        var definition = _node$definitions2[_i2];\n\n        if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {\n          var defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? 'schema' : '\"' + definition.name.value + '\"';\n          context.reportError(new _GraphQLError.GraphQLError(\"The \".concat(defName, \" definition is not executable.\"), definition));\n        }\n      }\n\n      return false;\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,yBAAyB,GAAG;AAEpC,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;CAKC,GACD,SAAS,0BAA0B,OAAO;IACxC,OAAO;QACL,UAAU,SAAS,SAAS,IAAI;YAC9B,IAAK,IAAI,MAAM,GAAG,qBAAqB,KAAK,WAAW,EAAE,MAAM,mBAAmB,MAAM,EAAE,MAAO;gBAC/F,IAAI,aAAa,kBAAkB,CAAC,IAAI;gBAExC,IAAI,CAAC,CAAC,GAAG,YAAY,0BAA0B,EAAE,aAAa;oBAC5D,IAAI,UAAU,WAAW,IAAI,KAAK,OAAO,IAAI,CAAC,iBAAiB,IAAI,WAAW,IAAI,KAAK,OAAO,IAAI,CAAC,gBAAgB,GAAG,WAAW,MAAM,WAAW,IAAI,CAAC,KAAK,GAAG;oBAC/J,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,OAAO,MAAM,CAAC,SAAS,mCAAmC;gBAC/G;YACF;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2677, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueOperationNamesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueOperationNamesRule = UniqueOperationNamesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n */\nfunction UniqueOperationNamesRule(context) {\n  var knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      var operationName = node.name;\n\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(new _GraphQLError.GraphQLError(\"There can be only one operation named \\\"\".concat(operationName.value, \"\\\".\"), [knownOperationNames[operationName.value], operationName]));\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition() {\n      return false;\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,wBAAwB,GAAG;AAEnC,IAAI;AAEJ;;;;CAIC,GACD,SAAS,yBAAyB,OAAO;IACvC,IAAI,sBAAsB,OAAO,MAAM,CAAC;IACxC,OAAO;QACL,qBAAqB,SAAS,oBAAoB,IAAI;YACpD,IAAI,gBAAgB,KAAK,IAAI;YAE7B,IAAI,eAAe;gBACjB,IAAI,mBAAmB,CAAC,cAAc,KAAK,CAAC,EAAE;oBAC5C,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,2CAA2C,MAAM,CAAC,cAAc,KAAK,EAAE,QAAQ;wBAAC,mBAAmB,CAAC,cAAc,KAAK,CAAC;wBAAE;qBAAc;gBAC7L,OAAO;oBACL,mBAAmB,CAAC,cAAc,KAAK,CAAC,GAAG;gBAC7C;YACF;YAEA,OAAO;QACT;QACA,oBAAoB,SAAS;YAC3B,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2714, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LoneAnonymousOperationRule = LoneAnonymousOperationRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _kinds = require(\"../../language/kinds\");\n\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n */\nfunction LoneAnonymousOperationRule(context) {\n  var operationCount = 0;\n  return {\n    Document: function Document(node) {\n      operationCount = node.definitions.filter(function (definition) {\n        return definition.kind === _kinds.Kind.OPERATION_DEFINITION;\n      }).length;\n    },\n    OperationDefinition: function OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(new _GraphQLError.GraphQLError('This anonymous operation must be the only defined operation.', node));\n      }\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,0BAA0B,GAAG;AAErC,IAAI;AAEJ,IAAI;AAEJ;;;;;CAKC,GACD,SAAS,2BAA2B,OAAO;IACzC,IAAI,iBAAiB;IACrB,OAAO;QACL,UAAU,SAAS,SAAS,IAAI;YAC9B,iBAAiB,KAAK,WAAW,CAAC,MAAM,CAAC,SAAU,UAAU;gBAC3D,OAAO,WAAW,IAAI,KAAK,OAAO,IAAI,CAAC,oBAAoB;YAC7D,GAAG,MAAM;QACX;QACA,qBAAqB,SAAS,oBAAoB,IAAI;YACpD,IAAI,CAAC,KAAK,IAAI,IAAI,iBAAiB,GAAG;gBACpC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,gEAAgE;YACrH;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2746, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\n/**\n * Subscriptions must only include one field.\n *\n * A GraphQL subscription is valid only if it contains a single root field.\n */\nfunction SingleFieldSubscriptionsRule(context) {\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      if (node.operation === 'subscription') {\n        if (node.selectionSet.selections.length !== 1) {\n          context.reportError(new _GraphQLError.GraphQLError(node.name ? \"Subscription \\\"\".concat(node.name.value, \"\\\" must select only one top level field.\") : 'Anonymous Subscription must select only one top level field.', node.selectionSet.selections.slice(1)));\n        }\n      }\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,4BAA4B,GAAG;AAEvC,IAAI;AAEJ;;;;CAIC,GACD,SAAS,6BAA6B,OAAO;IAC3C,OAAO;QACL,qBAAqB,SAAS,oBAAoB,IAAI;YACpD,IAAI,KAAK,SAAS,KAAK,gBAAgB;gBACrC,IAAI,KAAK,YAAY,CAAC,UAAU,CAAC,MAAM,KAAK,GAAG;oBAC7C,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,KAAK,IAAI,GAAG,kBAAkB,MAAM,CAAC,KAAK,IAAI,CAAC,KAAK,EAAE,8CAA8C,gEAAgE,KAAK,YAAY,CAAC,UAAU,CAAC,KAAK,CAAC;gBAC5P;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2772, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownTypeNamesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KnownTypeNamesRule = KnownTypeNamesRule;\n\nvar _didYouMean = _interopRequireDefault(require(\"../../jsutils/didYouMean\"));\n\nvar _suggestionList = _interopRequireDefault(require(\"../../jsutils/suggestionList\"));\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _predicates = require(\"../../language/predicates\");\n\nvar _scalars = require(\"../../type/scalars\");\n\nvar _introspection = require(\"../../type/introspection\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\nfunction KnownTypeNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\n        var isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && isStandardTypeName(typeName)) {\n          return;\n        }\n\n        var suggestedTypes = (0, _suggestionList.default)(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);\n        context.reportError(new _GraphQLError.GraphQLError(\"Unknown type \\\"\".concat(typeName, \"\\\".\") + (0, _didYouMean.default)(suggestedTypes), node));\n      }\n    }\n  };\n}\n\nvar standardTypeNames = [].concat(_scalars.specifiedScalarTypes, _introspection.introspectionTypes).map(function (type) {\n  return type.name;\n});\n\nfunction isStandardTypeName(typeName) {\n  return standardTypeNames.indexOf(typeName) !== -1;\n}\n\nfunction isSDLNode(value) {\n  return !Array.isArray(value) && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,kBAAkB,GAAG;AAE7B,IAAI,cAAc;AAElB,IAAI,kBAAkB;AAEtB,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F;;;;;CAKC,GACD,SAAS,mBAAmB,OAAO;IACjC,IAAI,SAAS,QAAQ,SAAS;IAC9B,IAAI,mBAAmB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACpE,IAAI,eAAe,OAAO,MAAM,CAAC;IAEjC,IAAK,IAAI,MAAM,GAAG,yBAAyB,QAAQ,WAAW,GAAG,WAAW,EAAE,MAAM,uBAAuB,MAAM,EAAE,MAAO;QACxH,IAAI,MAAM,sBAAsB,CAAC,IAAI;QAErC,IAAI,CAAC,GAAG,YAAY,oBAAoB,EAAE,MAAM;YAC9C,YAAY,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG;QACjC;IACF;IAEA,IAAI,YAAY,OAAO,IAAI,CAAC,kBAAkB,MAAM,CAAC,OAAO,IAAI,CAAC;IACjE,OAAO;QACL,WAAW,SAAS,UAAU,IAAI,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,SAAS;YAC3D,IAAI,WAAW,KAAK,IAAI,CAAC,KAAK;YAE9B,IAAI,CAAC,gBAAgB,CAAC,SAAS,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE;gBAC1D,IAAI;gBAEJ,IAAI,iBAAiB,CAAC,cAAc,SAAS,CAAC,EAAE,MAAM,QAAQ,gBAAgB,KAAK,IAAI,cAAc;gBACrG,IAAI,QAAQ,kBAAkB,QAAQ,UAAU;gBAEhD,IAAI,SAAS,mBAAmB,WAAW;oBACzC;gBACF;gBAEA,IAAI,iBAAiB,CAAC,GAAG,gBAAgB,OAAO,EAAE,UAAU,QAAQ,kBAAkB,MAAM,CAAC,aAAa;gBAC1G,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,kBAAkB,MAAM,CAAC,UAAU,SAAS,CAAC,GAAG,YAAY,OAAO,EAAE,iBAAiB;YAC3I;QACF;IACF;AACF;AAEA,IAAI,oBAAoB,EAAE,CAAC,MAAM,CAAC,SAAS,oBAAoB,EAAE,eAAe,kBAAkB,EAAE,GAAG,CAAC,SAAU,IAAI;IACpH,OAAO,KAAK,IAAI;AAClB;AAEA,SAAS,mBAAmB,QAAQ;IAClC,OAAO,kBAAkB,OAAO,CAAC,cAAc,CAAC;AAClD;AAEA,SAAS,UAAU,KAAK;IACtB,OAAO,CAAC,MAAM,OAAO,CAAC,UAAU,CAAC,CAAC,GAAG,YAAY,0BAA0B,EAAE,UAAU,CAAC,GAAG,YAAY,yBAAyB,EAAE,MAAM;AAC1I","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2834, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _printer = require(\"../../language/printer\");\n\nvar _definition = require(\"../../type/definition\");\n\nvar _typeFromAST = require(\"../../utilities/typeFromAST\");\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n */\nfunction FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition);\n\n        if (type && !(0, _definition.isCompositeType)(type)) {\n          var typeStr = (0, _printer.print)(typeCondition);\n          context.reportError(new _GraphQLError.GraphQLError(\"Fragment cannot condition on non composite type \\\"\".concat(typeStr, \"\\\".\"), typeCondition));\n        }\n      }\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.typeCondition);\n\n      if (type && !(0, _definition.isCompositeType)(type)) {\n        var typeStr = (0, _printer.print)(node.typeCondition);\n        context.reportError(new _GraphQLError.GraphQLError(\"Fragment \\\"\".concat(node.name.value, \"\\\" cannot condition on non composite type \\\"\").concat(typeStr, \"\\\".\"), node.typeCondition));\n      }\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,6BAA6B,GAAG;AAExC,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;;CAMC,GACD,SAAS,8BAA8B,OAAO;IAC5C,OAAO;QACL,gBAAgB,SAAS,eAAe,IAAI;YAC1C,IAAI,gBAAgB,KAAK,aAAa;YAEtC,IAAI,eAAe;gBACjB,IAAI,OAAO,CAAC,GAAG,aAAa,WAAW,EAAE,QAAQ,SAAS,IAAI;gBAE9D,IAAI,QAAQ,CAAC,CAAC,GAAG,YAAY,eAAe,EAAE,OAAO;oBACnD,IAAI,UAAU,CAAC,GAAG,SAAS,KAAK,EAAE;oBAClC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,qDAAqD,MAAM,CAAC,SAAS,QAAQ;gBAClI;YACF;QACF;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,IAAI,OAAO,CAAC,GAAG,aAAa,WAAW,EAAE,QAAQ,SAAS,IAAI,KAAK,aAAa;YAEhF,IAAI,QAAQ,CAAC,CAAC,GAAG,YAAY,eAAe,EAAE,OAAO;gBACnD,IAAI,UAAU,CAAC,GAAG,SAAS,KAAK,EAAE,KAAK,aAAa;gBACpD,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,cAAc,MAAM,CAAC,KAAK,IAAI,CAAC,KAAK,EAAE,gDAAgD,MAAM,CAAC,SAAS,QAAQ,KAAK,aAAa;YACrL;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2875, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariablesAreInputTypesRule = VariablesAreInputTypesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _printer = require(\"../../language/printer\");\n\nvar _definition = require(\"../../type/definition\");\n\nvar _typeFromAST = require(\"../../utilities/typeFromAST\");\n\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n */\nfunction VariablesAreInputTypesRule(context) {\n  return {\n    VariableDefinition: function VariableDefinition(node) {\n      var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.type);\n\n      if (type && !(0, _definition.isInputType)(type)) {\n        var variableName = node.variable.name.value;\n        var typeName = (0, _printer.print)(node.type);\n        context.reportError(new _GraphQLError.GraphQLError(\"Variable \\\"$\".concat(variableName, \"\\\" cannot be non-input type \\\"\").concat(typeName, \"\\\".\"), node.type));\n      }\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,0BAA0B,GAAG;AAErC,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;CAKC,GACD,SAAS,2BAA2B,OAAO;IACzC,OAAO;QACL,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,IAAI,OAAO,CAAC,GAAG,aAAa,WAAW,EAAE,QAAQ,SAAS,IAAI,KAAK,IAAI;YAEvE,IAAI,QAAQ,CAAC,CAAC,GAAG,YAAY,WAAW,EAAE,OAAO;gBAC/C,IAAI,eAAe,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK;gBAC3C,IAAI,WAAW,CAAC,GAAG,SAAS,KAAK,EAAE,KAAK,IAAI;gBAC5C,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,eAAe,MAAM,CAAC,cAAc,kCAAkC,MAAM,CAAC,UAAU,QAAQ,KAAK,IAAI;YAC7J;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2906, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ScalarLeafsRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScalarLeafsRule = ScalarLeafsRule;\n\nvar _inspect = _interopRequireDefault(require(\"../../jsutils/inspect\"));\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _definition = require(\"../../type/definition\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\nfunction ScalarLeafsRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getType();\n      var selectionSet = node.selectionSet;\n\n      if (type) {\n        if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {\n          if (selectionSet) {\n            var fieldName = node.name.value;\n            var typeStr = (0, _inspect.default)(type);\n            context.reportError(new _GraphQLError.GraphQLError(\"Field \\\"\".concat(fieldName, \"\\\" must not have a selection since type \\\"\").concat(typeStr, \"\\\" has no subfields.\"), selectionSet));\n          }\n        } else if (!selectionSet) {\n          var _fieldName = node.name.value;\n\n          var _typeStr = (0, _inspect.default)(type);\n\n          context.reportError(new _GraphQLError.GraphQLError(\"Field \\\"\".concat(_fieldName, \"\\\" of type \\\"\").concat(_typeStr, \"\\\" must have a selection of subfields. Did you mean \\\"\").concat(_fieldName, \" { ... }\\\"?\"), node));\n        }\n      }\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,eAAe,GAAG;AAE1B,IAAI,WAAW;AAEf,IAAI;AAEJ,IAAI;AAEJ,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F;;;;;CAKC,GACD,SAAS,gBAAgB,OAAO;IAC9B,OAAO;QACL,OAAO,SAAS,MAAM,IAAI;YACxB,IAAI,OAAO,QAAQ,OAAO;YAC1B,IAAI,eAAe,KAAK,YAAY;YAEpC,IAAI,MAAM;gBACR,IAAI,CAAC,GAAG,YAAY,UAAU,EAAE,CAAC,GAAG,YAAY,YAAY,EAAE,QAAQ;oBACpE,IAAI,cAAc;wBAChB,IAAI,YAAY,KAAK,IAAI,CAAC,KAAK;wBAC/B,IAAI,UAAU,CAAC,GAAG,SAAS,OAAO,EAAE;wBACpC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,WAAW,MAAM,CAAC,WAAW,8CAA8C,MAAM,CAAC,SAAS,yBAAyB;oBACzK;gBACF,OAAO,IAAI,CAAC,cAAc;oBACxB,IAAI,aAAa,KAAK,IAAI,CAAC,KAAK;oBAEhC,IAAI,WAAW,CAAC,GAAG,SAAS,OAAO,EAAE;oBAErC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,WAAW,MAAM,CAAC,YAAY,iBAAiB,MAAM,CAAC,UAAU,0DAA0D,MAAM,CAAC,YAAY,gBAAgB;gBAClN;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2950, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;\n\nvar _arrayFrom = _interopRequireDefault(require(\"../../polyfills/arrayFrom\"));\n\nvar _didYouMean = _interopRequireDefault(require(\"../../jsutils/didYouMean\"));\n\nvar _suggestionList = _interopRequireDefault(require(\"../../jsutils/suggestionList\"));\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _definition = require(\"../../type/definition\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\nfunction FieldsOnCorrectTypeRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestion = (0, _didYouMean.default)('to use an inline fragment on', getSuggestedTypeNames(schema, type, fieldName)); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = (0, _didYouMean.default)(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n\n          context.reportError(new _GraphQLError.GraphQLError(\"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type.name, \"\\\".\") + suggestion, node));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!(0, _definition.isAbstractType)(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  var suggestedTypes = new Set();\n  var usageCount = Object.create(null);\n\n  for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {\n    var possibleType = _schema$getPossibleTy2[_i2];\n\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {\n      var _usageCount$possibleI;\n\n      var possibleInterface = _possibleType$getInte2[_i4];\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;\n    }\n  }\n\n  return (0, _arrayFrom.default)(suggestedTypes).sort(function (typeA, typeB) {\n    // Suggest both interface and object types based on how common they are.\n    var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n    if (usageCountDiff !== 0) {\n      return usageCountDiff;\n    } // Suggest super types first followed by subtypes\n\n\n    if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {\n      return -1;\n    }\n\n    if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {\n      return 1;\n    }\n\n    return typeA.name.localeCompare(typeB.name);\n  }).map(function (x) {\n    return x.name;\n  });\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return (0, _suggestionList.default)(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3050, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueFragmentNamesRule = UniqueFragmentNamesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n */\nfunction UniqueFragmentNamesRule(context) {\n  var knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var fragmentName = node.name.value;\n\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(new _GraphQLError.GraphQLError(\"There can be only one fragment named \\\"\".concat(fragmentName, \"\\\".\"), [knownFragmentNames[fragmentName], node.name]));\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,uBAAuB,GAAG;AAElC,IAAI;AAEJ;;;;CAIC,GACD,SAAS,wBAAwB,OAAO;IACtC,IAAI,qBAAqB,OAAO,MAAM,CAAC;IACvC,OAAO;QACL,qBAAqB,SAAS;YAC5B,OAAO;QACT;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,IAAI,eAAe,KAAK,IAAI,CAAC,KAAK;YAElC,IAAI,kBAAkB,CAAC,aAAa,EAAE;gBACpC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,0CAA0C,MAAM,CAAC,cAAc,QAAQ;oBAAC,kBAAkB,CAAC,aAAa;oBAAE,KAAK,IAAI;iBAAC;YACzK,OAAO;gBACL,kBAAkB,CAAC,aAAa,GAAG,KAAK,IAAI;YAC9C;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3085, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownFragmentNamesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KnownFragmentNamesRule = KnownFragmentNamesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n */\nfunction KnownFragmentNamesRule(context) {\n  return {\n    FragmentSpread: function FragmentSpread(node) {\n      var fragmentName = node.name.value;\n      var fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        context.reportError(new _GraphQLError.GraphQLError(\"Unknown fragment \\\"\".concat(fragmentName, \"\\\".\"), node.name));\n      }\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,sBAAsB,GAAG;AAEjC,IAAI;AAEJ;;;;;CAKC,GACD,SAAS,uBAAuB,OAAO;IACrC,OAAO;QACL,gBAAgB,SAAS,eAAe,IAAI;YAC1C,IAAI,eAAe,KAAK,IAAI,CAAC,KAAK;YAClC,IAAI,WAAW,QAAQ,WAAW,CAAC;YAEnC,IAAI,CAAC,UAAU;gBACb,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,sBAAsB,MAAM,CAAC,cAAc,QAAQ,KAAK,IAAI;YACjH;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3112, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NoUnusedFragmentsRule = NoUnusedFragmentsRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n */\nfunction NoUnusedFragmentsRule(context) {\n  var operationDefs = [];\n  var fragmentDefs = [];\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n    Document: {\n      leave: function leave() {\n        var fragmentNameUsed = Object.create(null);\n\n        for (var _i2 = 0; _i2 < operationDefs.length; _i2++) {\n          var operation = operationDefs[_i2];\n\n          for (var _i4 = 0, _context$getRecursive2 = context.getRecursivelyReferencedFragments(operation); _i4 < _context$getRecursive2.length; _i4++) {\n            var fragment = _context$getRecursive2[_i4];\n            fragmentNameUsed[fragment.name.value] = true;\n          }\n        }\n\n        for (var _i6 = 0; _i6 < fragmentDefs.length; _i6++) {\n          var fragmentDef = fragmentDefs[_i6];\n          var fragName = fragmentDef.name.value;\n\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(new _GraphQLError.GraphQLError(\"Fragment \\\"\".concat(fragName, \"\\\" is never used.\"), fragmentDef));\n          }\n        }\n      }\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,qBAAqB,GAAG;AAEhC,IAAI;AAEJ;;;;;CAKC,GACD,SAAS,sBAAsB,OAAO;IACpC,IAAI,gBAAgB,EAAE;IACtB,IAAI,eAAe,EAAE;IACrB,OAAO;QACL,qBAAqB,SAAS,oBAAoB,IAAI;YACpD,cAAc,IAAI,CAAC;YACnB,OAAO;QACT;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,aAAa,IAAI,CAAC;YAClB,OAAO;QACT;QACA,UAAU;YACR,OAAO,SAAS;gBACd,IAAI,mBAAmB,OAAO,MAAM,CAAC;gBAErC,IAAK,IAAI,MAAM,GAAG,MAAM,cAAc,MAAM,EAAE,MAAO;oBACnD,IAAI,YAAY,aAAa,CAAC,IAAI;oBAElC,IAAK,IAAI,MAAM,GAAG,yBAAyB,QAAQ,iCAAiC,CAAC,YAAY,MAAM,uBAAuB,MAAM,EAAE,MAAO;wBAC3I,IAAI,WAAW,sBAAsB,CAAC,IAAI;wBAC1C,gBAAgB,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,GAAG;oBAC1C;gBACF;gBAEA,IAAK,IAAI,MAAM,GAAG,MAAM,aAAa,MAAM,EAAE,MAAO;oBAClD,IAAI,cAAc,YAAY,CAAC,IAAI;oBACnC,IAAI,WAAW,YAAY,IAAI,CAAC,KAAK;oBAErC,IAAI,gBAAgB,CAAC,SAAS,KAAK,MAAM;wBACvC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,cAAc,MAAM,CAAC,UAAU,sBAAsB;oBAC1G;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3161, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;\n\nvar _inspect = _interopRequireDefault(require(\"../../jsutils/inspect\"));\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _definition = require(\"../../type/definition\");\n\nvar _typeFromAST = require(\"../../utilities/typeFromAST\");\n\nvar _typeComparators = require(\"../../utilities/typeComparators\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nfunction PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {\n        var parentTypeStr = (0, _inspect.default)(parentType);\n        var fragTypeStr = (0, _inspect.default)(fragType);\n        context.reportError(new _GraphQLError.GraphQLError(\"Fragment cannot be spread here as objects of type \\\"\".concat(parentTypeStr, \"\\\" can never be of type \\\"\").concat(fragTypeStr, \"\\\".\"), node));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {\n        var parentTypeStr = (0, _inspect.default)(parentType);\n        var fragTypeStr = (0, _inspect.default)(fragType);\n        context.reportError(new _GraphQLError.GraphQLError(\"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of type \\\"\").concat(parentTypeStr, \"\\\" can never be of type \\\"\").concat(fragTypeStr, \"\\\".\"), node));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);\n\n    if ((0, _definition.isCompositeType)(type)) {\n      return type;\n    }\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,2BAA2B,GAAG;AAEtC,IAAI,WAAW;AAEf,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F;;;;;;CAMC,GACD,SAAS,4BAA4B,OAAO;IAC1C,OAAO;QACL,gBAAgB,SAAS,eAAe,IAAI;YAC1C,IAAI,WAAW,QAAQ,OAAO;YAC9B,IAAI,aAAa,QAAQ,aAAa;YAEtC,IAAI,CAAC,GAAG,YAAY,eAAe,EAAE,aAAa,CAAC,GAAG,YAAY,eAAe,EAAE,eAAe,CAAC,CAAC,GAAG,iBAAiB,cAAc,EAAE,QAAQ,SAAS,IAAI,UAAU,aAAa;gBAClL,IAAI,gBAAgB,CAAC,GAAG,SAAS,OAAO,EAAE;gBAC1C,IAAI,cAAc,CAAC,GAAG,SAAS,OAAO,EAAE;gBACxC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,uDAAuD,MAAM,CAAC,eAAe,8BAA8B,MAAM,CAAC,aAAa,QAAQ;YAC5L;QACF;QACA,gBAAgB,SAAS,eAAe,IAAI;YAC1C,IAAI,WAAW,KAAK,IAAI,CAAC,KAAK;YAC9B,IAAI,WAAW,gBAAgB,SAAS;YACxC,IAAI,aAAa,QAAQ,aAAa;YAEtC,IAAI,YAAY,cAAc,CAAC,CAAC,GAAG,iBAAiB,cAAc,EAAE,QAAQ,SAAS,IAAI,UAAU,aAAa;gBAC9G,IAAI,gBAAgB,CAAC,GAAG,SAAS,OAAO,EAAE;gBAC1C,IAAI,cAAc,CAAC,GAAG,SAAS,OAAO,EAAE;gBACxC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,cAAc,MAAM,CAAC,UAAU,kDAAkD,MAAM,CAAC,eAAe,8BAA8B,MAAM,CAAC,aAAa,QAAQ;YACtN;QACF;IACF;AACF;AAEA,SAAS,gBAAgB,OAAO,EAAE,IAAI;IACpC,IAAI,OAAO,QAAQ,WAAW,CAAC;IAE/B,IAAI,MAAM;QACR,IAAI,OAAO,CAAC,GAAG,aAAa,WAAW,EAAE,QAAQ,SAAS,IAAI,KAAK,aAAa;QAEhF,IAAI,CAAC,GAAG,YAAY,eAAe,EAAE,OAAO;YAC1C,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3219, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NoFragmentCyclesRule = NoFragmentCyclesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nfunction NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var _i2 = 0; _i2 < spreadNodes.length; _i2++) {\n      var spreadNode = spreadNodes[_i2];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        var spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        var viaPath = cyclePath.slice(0, -1).map(function (s) {\n          return '\"' + s.name.value + '\"';\n        }).join(', ');\n        context.reportError(new _GraphQLError.GraphQLError(\"Cannot spread fragment \\\"\".concat(spreadName, \"\\\" within itself\") + (viaPath !== '' ? \" via \".concat(viaPath, \".\") : '.'), cyclePath));\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,oBAAoB,GAAG;AAE/B,IAAI;AAEJ,SAAS,qBAAqB,OAAO;IACnC,8EAA8E;IAC9E,gCAAgC;IAChC,IAAI,eAAe,OAAO,MAAM,CAAC,OAAO,uDAAuD;IAE/F,IAAI,aAAa,EAAE,EAAE,8BAA8B;IAEnD,IAAI,wBAAwB,OAAO,MAAM,CAAC;IAC1C,OAAO;QACL,qBAAqB,SAAS;YAC5B,OAAO;QACT;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,qBAAqB;YACrB,OAAO;QACT;IACF,GAAG,mDAAmD;;;IACtD,wEAAwE;IACxE,yCAAyC;IAEzC,SAAS,qBAAqB,QAAQ;QACpC,IAAI,YAAY,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,EAAE;YACrC;QACF;QAEA,IAAI,eAAe,SAAS,IAAI,CAAC,KAAK;QACtC,YAAY,CAAC,aAAa,GAAG;QAC7B,IAAI,cAAc,QAAQ,kBAAkB,CAAC,SAAS,YAAY;QAElE,IAAI,YAAY,MAAM,KAAK,GAAG;YAC5B;QACF;QAEA,qBAAqB,CAAC,aAAa,GAAG,WAAW,MAAM;QAEvD,IAAK,IAAI,MAAM,GAAG,MAAM,YAAY,MAAM,EAAE,MAAO;YACjD,IAAI,aAAa,WAAW,CAAC,IAAI;YACjC,IAAI,aAAa,WAAW,IAAI,CAAC,KAAK;YACtC,IAAI,aAAa,qBAAqB,CAAC,WAAW;YAClD,WAAW,IAAI,CAAC;YAEhB,IAAI,eAAe,WAAW;gBAC5B,IAAI,iBAAiB,QAAQ,WAAW,CAAC;gBAEzC,IAAI,gBAAgB;oBAClB,qBAAqB;gBACvB;YACF,OAAO;gBACL,IAAI,YAAY,WAAW,KAAK,CAAC;gBACjC,IAAI,UAAU,UAAU,KAAK,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,SAAU,CAAC;oBAClD,OAAO,MAAM,EAAE,IAAI,CAAC,KAAK,GAAG;gBAC9B,GAAG,IAAI,CAAC;gBACR,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,4BAA4B,MAAM,CAAC,YAAY,sBAAsB,CAAC,YAAY,KAAK,QAAQ,MAAM,CAAC,SAAS,OAAO,GAAG,GAAG;YACjL;YAEA,WAAW,GAAG;QAChB;QAEA,qBAAqB,CAAC,aAAa,GAAG;IACxC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3282, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueVariableNamesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueVariableNamesRule = UniqueVariableNamesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\n/**\n * Unique variable names\n *\n * A GraphQL operation is only valid if all its variables are uniquely named.\n */\nfunction UniqueVariableNamesRule(context) {\n  var knownVariableNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      knownVariableNames = Object.create(null);\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      var variableName = node.variable.name.value;\n\n      if (knownVariableNames[variableName]) {\n        context.reportError(new _GraphQLError.GraphQLError(\"There can be only one variable named \\\"$\".concat(variableName, \"\\\".\"), [knownVariableNames[variableName], node.variable.name]));\n      } else {\n        knownVariableNames[variableName] = node.variable.name;\n      }\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,uBAAuB,GAAG;AAElC,IAAI;AAEJ;;;;CAIC,GACD,SAAS,wBAAwB,OAAO;IACtC,IAAI,qBAAqB,OAAO,MAAM,CAAC;IACvC,OAAO;QACL,qBAAqB,SAAS;YAC5B,qBAAqB,OAAO,MAAM,CAAC;QACrC;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,IAAI,eAAe,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK;YAE3C,IAAI,kBAAkB,CAAC,aAAa,EAAE;gBACpC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,2CAA2C,MAAM,CAAC,cAAc,QAAQ;oBAAC,kBAAkB,CAAC,aAAa;oBAAE,KAAK,QAAQ,CAAC,IAAI;iBAAC;YACnL,OAAO;gBACL,kBAAkB,CAAC,aAAa,GAAG,KAAK,QAAQ,CAAC,IAAI;YACvD;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3316, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NoUndefinedVariablesRule = NoUndefinedVariablesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n */\nfunction NoUndefinedVariablesRule(context) {\n  var variableNameDefined = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        variableNameDefined = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          var varName = node.name.value;\n\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(new _GraphQLError.GraphQLError(operation.name ? \"Variable \\\"$\".concat(varName, \"\\\" is not defined by operation \\\"\").concat(operation.name.value, \"\\\".\") : \"Variable \\\"$\".concat(varName, \"\\\" is not defined.\"), [node, operation]));\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,wBAAwB,GAAG;AAEnC,IAAI;AAEJ;;;;;CAKC,GACD,SAAS,yBAAyB,OAAO;IACvC,IAAI,sBAAsB,OAAO,MAAM,CAAC;IACxC,OAAO;QACL,qBAAqB;YACnB,OAAO,SAAS;gBACd,sBAAsB,OAAO,MAAM,CAAC;YACtC;YACA,OAAO,SAAS,MAAM,SAAS;gBAC7B,IAAI,SAAS,QAAQ,0BAA0B,CAAC;gBAEhD,IAAK,IAAI,MAAM,GAAG,MAAM,OAAO,MAAM,EAAE,MAAO;oBAC5C,IAAI,QAAQ,MAAM,CAAC,IAAI;oBACvB,IAAI,OAAO,MAAM,IAAI;oBACrB,IAAI,UAAU,KAAK,IAAI,CAAC,KAAK;oBAE7B,IAAI,mBAAmB,CAAC,QAAQ,KAAK,MAAM;wBACzC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,UAAU,IAAI,GAAG,eAAe,MAAM,CAAC,SAAS,qCAAqC,MAAM,CAAC,UAAU,IAAI,CAAC,KAAK,EAAE,SAAS,eAAe,MAAM,CAAC,SAAS,uBAAuB;4BAAC;4BAAM;yBAAU;oBACvP;gBACF;YACF;QACF;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,mBAAmB,CAAC,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG;QAClD;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3359, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoUnusedVariablesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NoUnusedVariablesRule = NoUnusedVariablesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n */\nfunction NoUnusedVariablesRule(context) {\n  var variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        variableDefs = [];\n      },\n      leave: function leave(operation) {\n        var variableNameUsed = Object.create(null);\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          variableNameUsed[node.name.value] = true;\n        }\n\n        for (var _i4 = 0, _variableDefs2 = variableDefs; _i4 < _variableDefs2.length; _i4++) {\n          var variableDef = _variableDefs2[_i4];\n          var variableName = variableDef.variable.name.value;\n\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(new _GraphQLError.GraphQLError(operation.name ? \"Variable \\\"$\".concat(variableName, \"\\\" is never used in operation \\\"\").concat(operation.name.value, \"\\\".\") : \"Variable \\\"$\".concat(variableName, \"\\\" is never used.\"), variableDef));\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(def) {\n      variableDefs.push(def);\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,qBAAqB,GAAG;AAEhC,IAAI;AAEJ;;;;;CAKC,GACD,SAAS,sBAAsB,OAAO;IACpC,IAAI,eAAe,EAAE;IACrB,OAAO;QACL,qBAAqB;YACnB,OAAO,SAAS;gBACd,eAAe,EAAE;YACnB;YACA,OAAO,SAAS,MAAM,SAAS;gBAC7B,IAAI,mBAAmB,OAAO,MAAM,CAAC;gBACrC,IAAI,SAAS,QAAQ,0BAA0B,CAAC;gBAEhD,IAAK,IAAI,MAAM,GAAG,MAAM,OAAO,MAAM,EAAE,MAAO;oBAC5C,IAAI,QAAQ,MAAM,CAAC,IAAI;oBACvB,IAAI,OAAO,MAAM,IAAI;oBACrB,gBAAgB,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,GAAG;gBACtC;gBAEA,IAAK,IAAI,MAAM,GAAG,iBAAiB,cAAc,MAAM,eAAe,MAAM,EAAE,MAAO;oBACnF,IAAI,cAAc,cAAc,CAAC,IAAI;oBACrC,IAAI,eAAe,YAAY,QAAQ,CAAC,IAAI,CAAC,KAAK;oBAElD,IAAI,gBAAgB,CAAC,aAAa,KAAK,MAAM;wBAC3C,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,UAAU,IAAI,GAAG,eAAe,MAAM,CAAC,cAAc,oCAAoC,MAAM,CAAC,UAAU,IAAI,CAAC,KAAK,EAAE,SAAS,eAAe,MAAM,CAAC,cAAc,sBAAsB;oBAC9O;gBACF;YACF;QACF;QACA,oBAAoB,SAAS,mBAAmB,GAAG;YACjD,aAAa,IAAI,CAAC;QACpB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3404, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownDirectivesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KnownDirectivesRule = KnownDirectivesRule;\n\nvar _inspect = _interopRequireDefault(require(\"../../jsutils/inspect\"));\n\nvar _invariant = _interopRequireDefault(require(\"../../jsutils/invariant\"));\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _kinds = require(\"../../language/kinds\");\n\nvar _directiveLocation = require(\"../../language/directiveLocation\");\n\nvar _directives = require(\"../../type/directives\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n */\nfunction KnownDirectivesRule(context) {\n  var locationsMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    locationsMap[directive.name] = directive.locations;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map(function (name) {\n        return name.value;\n      });\n    }\n  }\n\n  return {\n    Directive: function Directive(node, _key, _parent, _path, ancestors) {\n      var name = node.name.value;\n      var locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(new _GraphQLError.GraphQLError(\"Unknown directive \\\"@\".concat(name, \"\\\".\"), node));\n        return;\n      }\n\n      var candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && locations.indexOf(candidateLocation) === -1) {\n        context.reportError(new _GraphQLError.GraphQLError(\"Directive \\\"@\".concat(name, \"\\\" may not be used on \").concat(candidateLocation, \".\"), node));\n      }\n    }\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  var appliedTo = ancestors[ancestors.length - 1];\n  !Array.isArray(appliedTo) || (0, _invariant.default)(0);\n\n  switch (appliedTo.kind) {\n    case _kinds.Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n\n    case _kinds.Kind.FIELD:\n      return _directiveLocation.DirectiveLocation.FIELD;\n\n    case _kinds.Kind.FRAGMENT_SPREAD:\n      return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;\n\n    case _kinds.Kind.INLINE_FRAGMENT:\n      return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;\n\n    case _kinds.Kind.FRAGMENT_DEFINITION:\n      return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case _kinds.Kind.VARIABLE_DEFINITION:\n      return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;\n\n    case _kinds.Kind.SCHEMA_DEFINITION:\n    case _kinds.Kind.SCHEMA_EXTENSION:\n      return _directiveLocation.DirectiveLocation.SCHEMA;\n\n    case _kinds.Kind.SCALAR_TYPE_DEFINITION:\n    case _kinds.Kind.SCALAR_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.SCALAR;\n\n    case _kinds.Kind.OBJECT_TYPE_DEFINITION:\n    case _kinds.Kind.OBJECT_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.OBJECT;\n\n    case _kinds.Kind.FIELD_DEFINITION:\n      return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;\n\n    case _kinds.Kind.INTERFACE_TYPE_DEFINITION:\n    case _kinds.Kind.INTERFACE_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.INTERFACE;\n\n    case _kinds.Kind.UNION_TYPE_DEFINITION:\n    case _kinds.Kind.UNION_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.UNION;\n\n    case _kinds.Kind.ENUM_TYPE_DEFINITION:\n    case _kinds.Kind.ENUM_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.ENUM;\n\n    case _kinds.Kind.ENUM_VALUE_DEFINITION:\n      return _directiveLocation.DirectiveLocation.ENUM_VALUE;\n\n    case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.INPUT_OBJECT;\n\n    case _kinds.Kind.INPUT_VALUE_DEFINITION:\n      {\n        var parentNode = ancestors[ancestors.length - 3];\n        return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;\n      }\n  }\n}\n\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case 'query':\n      return _directiveLocation.DirectiveLocation.QUERY;\n\n    case 'mutation':\n      return _directiveLocation.DirectiveLocation.MUTATION;\n\n    case 'subscription':\n      return _directiveLocation.DirectiveLocation.SUBSCRIPTION;\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || (0, _invariant.default)(0, 'Unexpected operation: ' + (0, _inspect.default)(operation));\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,mBAAmB,GAAG;AAE9B,IAAI,WAAW;AAEf,IAAI,aAAa;AAEjB,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F;;;;;CAKC,GACD,SAAS,oBAAoB,OAAO;IAClC,IAAI,eAAe,OAAO,MAAM,CAAC;IACjC,IAAI,SAAS,QAAQ,SAAS;IAC9B,IAAI,oBAAoB,SAAS,OAAO,aAAa,KAAK,YAAY,mBAAmB;IAEzF,IAAK,IAAI,MAAM,GAAG,MAAM,kBAAkB,MAAM,EAAE,MAAO;QACvD,IAAI,YAAY,iBAAiB,CAAC,IAAI;QACtC,YAAY,CAAC,UAAU,IAAI,CAAC,GAAG,UAAU,SAAS;IACpD;IAEA,IAAI,iBAAiB,QAAQ,WAAW,GAAG,WAAW;IAEtD,IAAK,IAAI,MAAM,GAAG,MAAM,eAAe,MAAM,EAAE,MAAO;QACpD,IAAI,MAAM,cAAc,CAAC,IAAI;QAE7B,IAAI,IAAI,IAAI,KAAK,OAAO,IAAI,CAAC,oBAAoB,EAAE;YACjD,YAAY,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,SAAS,CAAC,GAAG,CAAC,SAAU,IAAI;gBAC7D,OAAO,KAAK,KAAK;YACnB;QACF;IACF;IAEA,OAAO;QACL,WAAW,SAAS,UAAU,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,SAAS;YACjE,IAAI,OAAO,KAAK,IAAI,CAAC,KAAK;YAC1B,IAAI,YAAY,YAAY,CAAC,KAAK;YAElC,IAAI,CAAC,WAAW;gBACd,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,wBAAwB,MAAM,CAAC,MAAM,QAAQ;gBAChG;YACF;YAEA,IAAI,oBAAoB,+BAA+B;YAEvD,IAAI,qBAAqB,UAAU,OAAO,CAAC,uBAAuB,CAAC,GAAG;gBACpE,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,gBAAgB,MAAM,CAAC,MAAM,0BAA0B,MAAM,CAAC,mBAAmB,MAAM;YAC5I;QACF;IACF;AACF;AAEA,SAAS,+BAA+B,SAAS;IAC/C,IAAI,YAAY,SAAS,CAAC,UAAU,MAAM,GAAG,EAAE;IAC/C,CAAC,MAAM,OAAO,CAAC,cAAc,CAAC,GAAG,WAAW,OAAO,EAAE;IAErD,OAAQ,UAAU,IAAI;QACpB,KAAK,OAAO,IAAI,CAAC,oBAAoB;YACnC,OAAO,iCAAiC,UAAU,SAAS;QAE7D,KAAK,OAAO,IAAI,CAAC,KAAK;YACpB,OAAO,mBAAmB,iBAAiB,CAAC,KAAK;QAEnD,KAAK,OAAO,IAAI,CAAC,eAAe;YAC9B,OAAO,mBAAmB,iBAAiB,CAAC,eAAe;QAE7D,KAAK,OAAO,IAAI,CAAC,eAAe;YAC9B,OAAO,mBAAmB,iBAAiB,CAAC,eAAe;QAE7D,KAAK,OAAO,IAAI,CAAC,mBAAmB;YAClC,OAAO,mBAAmB,iBAAiB,CAAC,mBAAmB;QAEjE,KAAK,OAAO,IAAI,CAAC,mBAAmB;YAClC,OAAO,mBAAmB,iBAAiB,CAAC,mBAAmB;QAEjE,KAAK,OAAO,IAAI,CAAC,iBAAiB;QAClC,KAAK,OAAO,IAAI,CAAC,gBAAgB;YAC/B,OAAO,mBAAmB,iBAAiB,CAAC,MAAM;QAEpD,KAAK,OAAO,IAAI,CAAC,sBAAsB;QACvC,KAAK,OAAO,IAAI,CAAC,qBAAqB;YACpC,OAAO,mBAAmB,iBAAiB,CAAC,MAAM;QAEpD,KAAK,OAAO,IAAI,CAAC,sBAAsB;QACvC,KAAK,OAAO,IAAI,CAAC,qBAAqB;YACpC,OAAO,mBAAmB,iBAAiB,CAAC,MAAM;QAEpD,KAAK,OAAO,IAAI,CAAC,gBAAgB;YAC/B,OAAO,mBAAmB,iBAAiB,CAAC,gBAAgB;QAE9D,KAAK,OAAO,IAAI,CAAC,yBAAyB;QAC1C,KAAK,OAAO,IAAI,CAAC,wBAAwB;YACvC,OAAO,mBAAmB,iBAAiB,CAAC,SAAS;QAEvD,KAAK,OAAO,IAAI,CAAC,qBAAqB;QACtC,KAAK,OAAO,IAAI,CAAC,oBAAoB;YACnC,OAAO,mBAAmB,iBAAiB,CAAC,KAAK;QAEnD,KAAK,OAAO,IAAI,CAAC,oBAAoB;QACrC,KAAK,OAAO,IAAI,CAAC,mBAAmB;YAClC,OAAO,mBAAmB,iBAAiB,CAAC,IAAI;QAElD,KAAK,OAAO,IAAI,CAAC,qBAAqB;YACpC,OAAO,mBAAmB,iBAAiB,CAAC,UAAU;QAExD,KAAK,OAAO,IAAI,CAAC,4BAA4B;QAC7C,KAAK,OAAO,IAAI,CAAC,2BAA2B;YAC1C,OAAO,mBAAmB,iBAAiB,CAAC,YAAY;QAE1D,KAAK,OAAO,IAAI,CAAC,sBAAsB;YACrC;gBACE,IAAI,aAAa,SAAS,CAAC,UAAU,MAAM,GAAG,EAAE;gBAChD,OAAO,WAAW,IAAI,KAAK,OAAO,IAAI,CAAC,4BAA4B,GAAG,mBAAmB,iBAAiB,CAAC,sBAAsB,GAAG,mBAAmB,iBAAiB,CAAC,mBAAmB;YAC9L;IACJ;AACF;AAEA,SAAS,iCAAiC,SAAS;IACjD,OAAQ;QACN,KAAK;YACH,OAAO,mBAAmB,iBAAiB,CAAC,KAAK;QAEnD,KAAK;YACH,OAAO,mBAAmB,iBAAiB,CAAC,QAAQ;QAEtD,KAAK;YACH,OAAO,mBAAmB,iBAAiB,CAAC,YAAY;IAC5D,EAAE,gFAAgF;IAGlF,SAAS,CAAC,GAAG,WAAW,OAAO,EAAE,GAAG,2BAA2B,CAAC,GAAG,SAAS,OAAO,EAAE;AACvF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3521, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _kinds = require(\"../../language/kinds\");\n\nvar _predicates = require(\"../../language/predicates\");\n\nvar _directives = require(\"../../type/directives\");\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\nfunction UniqueDirectivesPerLocationRule(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  var schemaDirectives = Object.create(null);\n  var typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      if (node.directives == null) {\n        return;\n      }\n\n      var seenDirectives;\n\n      if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {\n        seenDirectives = schemaDirectives;\n      } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {\n        var typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++) {\n        var _directive = _node$directives2[_i6];\n        var directiveName = _directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(new _GraphQLError.GraphQLError(\"The directive \\\"@\".concat(directiveName, \"\\\" can only be used once at this location.\"), [seenDirectives[directiveName], _directive]));\n          } else {\n            seenDirectives[directiveName] = _directive;\n          }\n        }\n      }\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,+BAA+B,GAAG;AAE1C,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;CAKC,GACD,SAAS,gCAAgC,OAAO;IAC9C,IAAI,qBAAqB,OAAO,MAAM,CAAC;IACvC,IAAI,SAAS,QAAQ,SAAS;IAC9B,IAAI,oBAAoB,SAAS,OAAO,aAAa,KAAK,YAAY,mBAAmB;IAEzF,IAAK,IAAI,MAAM,GAAG,MAAM,kBAAkB,MAAM,EAAE,MAAO;QACvD,IAAI,YAAY,iBAAiB,CAAC,IAAI;QACtC,kBAAkB,CAAC,UAAU,IAAI,CAAC,GAAG,CAAC,UAAU,YAAY;IAC9D;IAEA,IAAI,iBAAiB,QAAQ,WAAW,GAAG,WAAW;IAEtD,IAAK,IAAI,MAAM,GAAG,MAAM,eAAe,MAAM,EAAE,MAAO;QACpD,IAAI,MAAM,cAAc,CAAC,IAAI;QAE7B,IAAI,IAAI,IAAI,KAAK,OAAO,IAAI,CAAC,oBAAoB,EAAE;YACjD,kBAAkB,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,UAAU;QACtD;IACF;IAEA,IAAI,mBAAmB,OAAO,MAAM,CAAC;IACrC,IAAI,oBAAoB,OAAO,MAAM,CAAC;IACtC,OAAO;QACL,uEAAuE;QACvE,sEAAsE;QACtE,0BAA0B;QAC1B,OAAO,SAAS,MAAM,IAAI;YACxB,IAAI,KAAK,UAAU,IAAI,MAAM;gBAC3B;YACF;YAEA,IAAI;YAEJ,IAAI,KAAK,IAAI,KAAK,OAAO,IAAI,CAAC,iBAAiB,IAAI,KAAK,IAAI,KAAK,OAAO,IAAI,CAAC,gBAAgB,EAAE;gBAC7F,iBAAiB;YACnB,OAAO,IAAI,CAAC,GAAG,YAAY,oBAAoB,EAAE,SAAS,CAAC,GAAG,YAAY,mBAAmB,EAAE,OAAO;gBACpG,IAAI,WAAW,KAAK,IAAI,CAAC,KAAK;gBAC9B,iBAAiB,iBAAiB,CAAC,SAAS;gBAE5C,IAAI,mBAAmB,WAAW;oBAChC,iBAAiB,CAAC,SAAS,GAAG,iBAAiB,OAAO,MAAM,CAAC;gBAC/D;YACF,OAAO;gBACL,iBAAiB,OAAO,MAAM,CAAC;YACjC;YAEA,IAAK,IAAI,MAAM,GAAG,oBAAoB,KAAK,UAAU,EAAE,MAAM,kBAAkB,MAAM,EAAE,MAAO;gBAC5F,IAAI,aAAa,iBAAiB,CAAC,IAAI;gBACvC,IAAI,gBAAgB,WAAW,IAAI,CAAC,KAAK;gBAEzC,IAAI,kBAAkB,CAAC,cAAc,EAAE;oBACrC,IAAI,cAAc,CAAC,cAAc,EAAE;wBACjC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,oBAAoB,MAAM,CAAC,eAAe,+CAA+C;4BAAC,cAAc,CAAC,cAAc;4BAAE;yBAAW;oBACzL,OAAO;wBACL,cAAc,CAAC,cAAc,GAAG;oBAClC;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3594, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownArgumentNamesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KnownArgumentNamesRule = KnownArgumentNamesRule;\nexports.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;\n\nvar _didYouMean = _interopRequireDefault(require(\"../../jsutils/didYouMean\"));\n\nvar _suggestionList = _interopRequireDefault(require(\"../../jsutils/suggestionList\"));\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _kinds = require(\"../../language/kinds\");\n\nvar _directives = require(\"../../type/directives\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n */\nfunction KnownArgumentNamesRule(context) {\n  return _objectSpread(_objectSpread({}, KnownArgumentNamesOnDirectivesRule(context)), {}, {\n    Argument: function Argument(argNode) {\n      var argDef = context.getArgument();\n      var fieldDef = context.getFieldDef();\n      var parentType = context.getParentType();\n\n      if (!argDef && fieldDef && parentType) {\n        var argName = argNode.name.value;\n        var knownArgsNames = fieldDef.args.map(function (arg) {\n          return arg.name;\n        });\n        var suggestions = (0, _suggestionList.default)(argName, knownArgsNames);\n        context.reportError(new _GraphQLError.GraphQLError(\"Unknown argument \\\"\".concat(argName, \"\\\" on field \\\"\").concat(parentType.name, \".\").concat(fieldDef.name, \"\\\".\") + (0, _didYouMean.default)(suggestions), argNode));\n      }\n    }\n  });\n}\n/**\n * @internal\n */\n\n\nfunction KnownArgumentNamesOnDirectivesRule(context) {\n  var directiveArgs = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    directiveArgs[directive.name] = directive.args.map(function (arg) {\n      return arg.name;\n    });\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];\n      directiveArgs[def.name.value] = argsNodes.map(function (arg) {\n        return arg.name.value;\n      });\n    }\n  }\n\n  return {\n    Directive: function Directive(directiveNode) {\n      var directiveName = directiveNode.name.value;\n      var knownArgs = directiveArgs[directiveName];\n\n      if (directiveNode.arguments && knownArgs) {\n        for (var _i6 = 0, _directiveNode$argume2 = directiveNode.arguments; _i6 < _directiveNode$argume2.length; _i6++) {\n          var argNode = _directiveNode$argume2[_i6];\n          var argName = argNode.name.value;\n\n          if (knownArgs.indexOf(argName) === -1) {\n            var suggestions = (0, _suggestionList.default)(argName, knownArgs);\n            context.reportError(new _GraphQLError.GraphQLError(\"Unknown argument \\\"\".concat(argName, \"\\\" on directive \\\"@\").concat(directiveName, \"\\\".\") + (0, _didYouMean.default)(suggestions), argNode));\n          }\n        }\n      }\n\n      return false;\n    }\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3720, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueArgumentNamesRule = UniqueArgumentNamesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\n/**\n * Unique argument names\n *\n * A GraphQL field or directive is only valid if all supplied arguments are\n * uniquely named.\n */\nfunction UniqueArgumentNamesRule(context) {\n  var knownArgNames = Object.create(null);\n  return {\n    Field: function Field() {\n      knownArgNames = Object.create(null);\n    },\n    Directive: function Directive() {\n      knownArgNames = Object.create(null);\n    },\n    Argument: function Argument(node) {\n      var argName = node.name.value;\n\n      if (knownArgNames[argName]) {\n        context.reportError(new _GraphQLError.GraphQLError(\"There can be only one argument named \\\"\".concat(argName, \"\\\".\"), [knownArgNames[argName], node.name]));\n      } else {\n        knownArgNames[argName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,uBAAuB,GAAG;AAElC,IAAI;AAEJ;;;;;CAKC,GACD,SAAS,wBAAwB,OAAO;IACtC,IAAI,gBAAgB,OAAO,MAAM,CAAC;IAClC,OAAO;QACL,OAAO,SAAS;YACd,gBAAgB,OAAO,MAAM,CAAC;QAChC;QACA,WAAW,SAAS;YAClB,gBAAgB,OAAO,MAAM,CAAC;QAChC;QACA,UAAU,SAAS,SAAS,IAAI;YAC9B,IAAI,UAAU,KAAK,IAAI,CAAC,KAAK;YAE7B,IAAI,aAAa,CAAC,QAAQ,EAAE;gBAC1B,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,0CAA0C,MAAM,CAAC,SAAS,QAAQ;oBAAC,aAAa,CAAC,QAAQ;oBAAE,KAAK,IAAI;iBAAC;YAC1J,OAAO;gBACL,aAAa,CAAC,QAAQ,GAAG,KAAK,IAAI;YACpC;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3759, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;\n\nvar _objectValues3 = _interopRequireDefault(require(\"../../polyfills/objectValues\"));\n\nvar _keyMap = _interopRequireDefault(require(\"../../jsutils/keyMap\"));\n\nvar _inspect = _interopRequireDefault(require(\"../../jsutils/inspect\"));\n\nvar _didYouMean = _interopRequireDefault(require(\"../../jsutils/didYouMean\"));\n\nvar _suggestionList = _interopRequireDefault(require(\"../../jsutils/suggestionList\"));\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _printer = require(\"../../language/printer\");\n\nvar _definition = require(\"../../type/definition\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n */\nfunction ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue: function ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      var type = (0, _definition.getNullableType)(context.getParentInputType());\n\n      if (!(0, _definition.isListType)(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n    ObjectValue: function ObjectValue(node) {\n      var type = (0, _definition.getNamedType)(context.getInputType());\n\n      if (!(0, _definition.isInputObjectType)(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n\n      var fieldNodeMap = (0, _keyMap.default)(node.fields, function (field) {\n        return field.name.value;\n      });\n\n      for (var _i2 = 0, _objectValues2 = (0, _objectValues3.default)(type.getFields()); _i2 < _objectValues2.length; _i2++) {\n        var fieldDef = _objectValues2[_i2];\n        var fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {\n          var typeStr = (0, _inspect.default)(fieldDef.type);\n          context.reportError(new _GraphQLError.GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldDef.name, \"\\\" of required type \\\"\").concat(typeStr, \"\\\" was not provided.\"), node));\n        }\n      }\n    },\n    ObjectField: function ObjectField(node) {\n      var parentType = (0, _definition.getNamedType)(context.getParentInputType());\n      var fieldType = context.getInputType();\n\n      if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {\n        var suggestions = (0, _suggestionList.default)(node.name.value, Object.keys(parentType.getFields()));\n        context.reportError(new _GraphQLError.GraphQLError(\"Field \\\"\".concat(node.name.value, \"\\\" is not defined by type \\\"\").concat(parentType.name, \"\\\".\") + (0, _didYouMean.default)(suggestions), node));\n      }\n    },\n    NullValue: function NullValue(node) {\n      var type = context.getInputType();\n\n      if ((0, _definition.isNonNullType)(type)) {\n        context.reportError(new _GraphQLError.GraphQLError(\"Expected value of type \\\"\".concat((0, _inspect.default)(type), \"\\\", found \").concat((0, _printer.print)(node), \".\"), node));\n      }\n    },\n    EnumValue: function EnumValue(node) {\n      return isValidValueNode(context, node);\n    },\n    IntValue: function IntValue(node) {\n      return isValidValueNode(context, node);\n    },\n    FloatValue: function FloatValue(node) {\n      return isValidValueNode(context, node);\n    },\n    StringValue: function StringValue(node) {\n      return isValidValueNode(context, node);\n    },\n    BooleanValue: function BooleanValue(node) {\n      return isValidValueNode(context, node);\n    }\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  var locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  var type = (0, _definition.getNamedType)(locationType);\n\n  if (!(0, _definition.isLeafType)(type)) {\n    var typeStr = (0, _inspect.default)(locationType);\n    context.reportError(new _GraphQLError.GraphQLError(\"Expected value of type \\\"\".concat(typeStr, \"\\\", found \").concat((0, _printer.print)(node), \".\"), node));\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n\n  try {\n    var parseResult = type.parseLiteral(node, undefined\n    /* variables */\n    );\n\n    if (parseResult === undefined) {\n      var _typeStr = (0, _inspect.default)(locationType);\n\n      context.reportError(new _GraphQLError.GraphQLError(\"Expected value of type \\\"\".concat(_typeStr, \"\\\", found \").concat((0, _printer.print)(node), \".\"), node));\n    }\n  } catch (error) {\n    var _typeStr2 = (0, _inspect.default)(locationType);\n\n    if (error instanceof _GraphQLError.GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(new _GraphQLError.GraphQLError(\"Expected value of type \\\"\".concat(_typeStr2, \"\\\", found \").concat((0, _printer.print)(node), \"; \") + error.message, node, undefined, undefined, undefined, error));\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3878, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;\nexports.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;\n\nvar _inspect = _interopRequireDefault(require(\"../../jsutils/inspect\"));\n\nvar _keyMap = _interopRequireDefault(require(\"../../jsutils/keyMap\"));\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _kinds = require(\"../../language/kinds\");\n\nvar _printer = require(\"../../language/printer\");\n\nvar _directives = require(\"../../type/directives\");\n\nvar _definition = require(\"../../type/definition\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null without a\n * default value) field arguments have been provided.\n */\nfunction ProvidedRequiredArgumentsRule(context) {\n  return _objectSpread(_objectSpread({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {}, {\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave: function leave(fieldNode) {\n        var _fieldNode$arguments;\n\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          return false;\n        } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n        var argNodes = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];\n        var argNodeMap = (0, _keyMap.default)(argNodes, function (arg) {\n          return arg.name.value;\n        });\n\n        for (var _i2 = 0, _fieldDef$args2 = fieldDef.args; _i2 < _fieldDef$args2.length; _i2++) {\n          var argDef = _fieldDef$args2[_i2];\n          var argNode = argNodeMap[argDef.name];\n\n          if (!argNode && (0, _definition.isRequiredArgument)(argDef)) {\n            var argTypeStr = (0, _inspect.default)(argDef.type);\n            context.reportError(new _GraphQLError.GraphQLError(\"Field \\\"\".concat(fieldDef.name, \"\\\" argument \\\"\").concat(argDef.name, \"\\\" of type \\\"\").concat(argTypeStr, \"\\\" is required, but it was not provided.\"), fieldNode));\n          }\n        }\n      }\n    }\n  });\n}\n/**\n * @internal\n */\n\n\nfunction ProvidedRequiredArgumentsOnDirectivesRule(context) {\n  var requiredArgsMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;\n\n  for (var _i4 = 0; _i4 < definedDirectives.length; _i4++) {\n    var directive = definedDirectives[_i4];\n    requiredArgsMap[directive.name] = (0, _keyMap.default)(directive.args.filter(_definition.isRequiredArgument), function (arg) {\n      return arg.name;\n    });\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i6 = 0; _i6 < astDefinitions.length; _i6++) {\n    var def = astDefinitions[_i6];\n\n    if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];\n      requiredArgsMap[def.name.value] = (0, _keyMap.default)(argNodes.filter(isRequiredArgumentNode), function (arg) {\n        return arg.name.value;\n      });\n    }\n  }\n\n  return {\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave: function leave(directiveNode) {\n        var directiveName = directiveNode.name.value;\n        var requiredArgs = requiredArgsMap[directiveName];\n\n        if (requiredArgs) {\n          var _directiveNode$argume;\n\n          // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n          var _argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];\n\n          var argNodeMap = (0, _keyMap.default)(_argNodes, function (arg) {\n            return arg.name.value;\n          });\n\n          for (var _i8 = 0, _Object$keys2 = Object.keys(requiredArgs); _i8 < _Object$keys2.length; _i8++) {\n            var argName = _Object$keys2[_i8];\n\n            if (!argNodeMap[argName]) {\n              var argType = requiredArgs[argName].type;\n              var argTypeStr = (0, _definition.isType)(argType) ? (0, _inspect.default)(argType) : (0, _printer.print)(argType);\n              context.reportError(new _GraphQLError.GraphQLError(\"Directive \\\"@\".concat(directiveName, \"\\\" argument \\\"\").concat(argName, \"\\\" of type \\\"\").concat(argTypeStr, \"\\\" is required, but it was not provided.\"), directiveNode));\n            }\n          }\n        }\n      }\n    }\n  };\n}\n\nfunction isRequiredArgumentNode(arg) {\n  return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4026, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;\n\nvar _inspect = _interopRequireDefault(require(\"../../jsutils/inspect\"));\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _kinds = require(\"../../language/kinds\");\n\nvar _definition = require(\"../../type/definition\");\n\nvar _typeFromAST = require(\"../../utilities/typeFromAST\");\n\nvar _typeComparators = require(\"../../utilities/typeComparators\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Variables passed to field arguments conform to type\n */\nfunction VariablesInAllowedPositionRule(context) {\n  var varDefMap = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        varDefMap = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          var type = _ref2.type;\n          var defaultValue = _ref2.defaultValue;\n          var varName = node.name.value;\n          var varDef = varDefMap[varName];\n\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            var schema = context.getSchema();\n            var varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);\n\n            if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {\n              var varTypeStr = (0, _inspect.default)(varType);\n              var typeStr = (0, _inspect.default)(type);\n              context.reportError(new _GraphQLError.GraphQLError(\"Variable \\\"$\".concat(varName, \"\\\" of type \\\"\").concat(varTypeStr, \"\\\" used in position expecting type \\\"\").concat(typeStr, \"\\\".\"), [varDef, node]));\n            }\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    }\n  };\n}\n/**\n * Returns true if the variable is allowed in the location it was found,\n * which includes considering if default values exist for either the variable\n * or the location at which it is located.\n */\n\n\nfunction allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {\n  if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {\n    var hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;\n    var hasLocationDefaultValue = locationDefaultValue !== undefined;\n\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n\n    var nullableLocationType = locationType.ofType;\n    return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, nullableLocationType);\n  }\n\n  return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,8BAA8B,GAAG;AAEzC,IAAI,WAAW;AAEf,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F;;CAEC,GACD,SAAS,+BAA+B,OAAO;IAC7C,IAAI,YAAY,OAAO,MAAM,CAAC;IAC9B,OAAO;QACL,qBAAqB;YACnB,OAAO,SAAS;gBACd,YAAY,OAAO,MAAM,CAAC;YAC5B;YACA,OAAO,SAAS,MAAM,SAAS;gBAC7B,IAAI,SAAS,QAAQ,0BAA0B,CAAC;gBAEhD,IAAK,IAAI,MAAM,GAAG,MAAM,OAAO,MAAM,EAAE,MAAO;oBAC5C,IAAI,QAAQ,MAAM,CAAC,IAAI;oBACvB,IAAI,OAAO,MAAM,IAAI;oBACrB,IAAI,OAAO,MAAM,IAAI;oBACrB,IAAI,eAAe,MAAM,YAAY;oBACrC,IAAI,UAAU,KAAK,IAAI,CAAC,KAAK;oBAC7B,IAAI,SAAS,SAAS,CAAC,QAAQ;oBAE/B,IAAI,UAAU,MAAM;wBAClB,kEAAkE;wBAClE,iEAAiE;wBACjE,oEAAoE;wBACpE,oEAAoE;wBACpE,+CAA+C;wBAC/C,IAAI,SAAS,QAAQ,SAAS;wBAC9B,IAAI,UAAU,CAAC,GAAG,aAAa,WAAW,EAAE,QAAQ,OAAO,IAAI;wBAE/D,IAAI,WAAW,CAAC,qBAAqB,QAAQ,SAAS,OAAO,YAAY,EAAE,MAAM,eAAe;4BAC9F,IAAI,aAAa,CAAC,GAAG,SAAS,OAAO,EAAE;4BACvC,IAAI,UAAU,CAAC,GAAG,SAAS,OAAO,EAAE;4BACpC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,eAAe,MAAM,CAAC,SAAS,iBAAiB,MAAM,CAAC,YAAY,yCAAyC,MAAM,CAAC,SAAS,QAAQ;gCAAC;gCAAQ;6BAAK;wBACvM;oBACF;gBACF;YACF;QACF;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,SAAS,CAAC,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG;QACxC;IACF;AACF;AACA;;;;CAIC,GAGD,SAAS,qBAAqB,MAAM,EAAE,OAAO,EAAE,eAAe,EAAE,YAAY,EAAE,oBAAoB;IAChG,IAAI,CAAC,GAAG,YAAY,aAAa,EAAE,iBAAiB,CAAC,CAAC,GAAG,YAAY,aAAa,EAAE,UAAU;QAC5F,IAAI,iCAAiC,mBAAmB,QAAQ,gBAAgB,IAAI,KAAK,OAAO,IAAI,CAAC,IAAI;QACzG,IAAI,0BAA0B,yBAAyB;QAEvD,IAAI,CAAC,kCAAkC,CAAC,yBAAyB;YAC/D,OAAO;QACT;QAEA,IAAI,uBAAuB,aAAa,MAAM;QAC9C,OAAO,CAAC,GAAG,iBAAiB,eAAe,EAAE,QAAQ,SAAS;IAChE;IAEA,OAAO,CAAC,GAAG,iBAAiB,eAAe,EAAE,QAAQ,SAAS;AAChE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4106, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;\n\nvar _find = _interopRequireDefault(require(\"../../polyfills/find\"));\n\nvar _objectEntries3 = _interopRequireDefault(require(\"../../polyfills/objectEntries\"));\n\nvar _inspect = _interopRequireDefault(require(\"../../jsutils/inspect\"));\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _kinds = require(\"../../language/kinds\");\n\nvar _printer = require(\"../../language/printer\");\n\nvar _definition = require(\"../../type/definition\");\n\nvar _typeFromAST = require(\"../../utilities/typeFromAST\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subReason = _ref[1];\n      return \"subfields \\\"\".concat(responseName, \"\\\" conflict because \") + reasonMessage(subReason);\n    }).join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\n\n\nfunction OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  var cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n\n      for (var _i2 = 0; _i2 < conflicts.length; _i2++) {\n        var _ref3 = conflicts[_i2];\n        var _ref2$ = _ref3[0];\n        var responseName = _ref2$[0];\n        var reason = _ref2$[1];\n        var fields1 = _ref3[1];\n        var fields2 = _ref3[2];\n        var reasonMsg = reasonMessage(reason);\n        context.reportError(new _GraphQLError.GraphQLError(\"Fields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMsg, \". Use different aliases on the fields to fetch both if this was intentional.\"), fields1.concat(fields2)));\n      }\n    }\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  var fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.\n\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  if (fragmentNames2.length !== 0) {\n    for (var j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n    }\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n\n  if (fragmentNames1.length !== 0) {\n    for (var i = 0; i < fragmentNames1.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n    }\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n\n  for (var _i3 = 0; _i3 < fragmentNames1.length; _i3++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i3], fragmentNames2[_j]);\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (var _i5 = 0, _objectEntries2 = (0, _objectEntries3.default)(fieldMap); _i5 < _objectEntries2.length; _i5++) {\n    var _ref5 = _objectEntries2[_i5];\n    var responseName = _ref5[0];\n    var fields = _ref5[1];\n\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (var _i7 = 0, _Object$keys2 = Object.keys(fieldMap1); _i7 < _Object$keys2.length; _i7++) {\n    var responseName = _Object$keys2[_i7];\n    var fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2]; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);\n\n  if (!areMutuallyExclusive) {\n    var _node1$arguments, _node2$arguments;\n\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [[responseName, \"\\\"\".concat(name1, \"\\\" and \\\"\").concat(name2, \"\\\" are different fields\")], [node1], [node2]];\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n    var args1 = (_node1$arguments = node1.arguments) !== null && _node1$arguments !== void 0 ? _node1$arguments : []; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n    var args2 = (_node2$arguments = node2.arguments) !== null && _node2$arguments !== void 0 ? _node2$arguments : []; // Two field calls must have the same arguments.\n\n    if (!sameArguments(args1, args2)) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  } // The return type for each field.\n\n\n  var type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  var type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, \"they return conflicting types \\\"\".concat((0, _inspect.default)(type1), \"\\\" and \\\"\").concat((0, _inspect.default)(type2), \"\\\"\")], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n\n  return arguments1.every(function (argument1) {\n    var argument2 = (0, _find.default)(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n\n    if (!argument2) {\n      return false;\n    }\n\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return (0, _printer.print)(value1) === (0, _printer.print)(value2);\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\n\nfunction doTypesConflict(type1, type2) {\n  if ((0, _definition.isListType)(type1)) {\n    return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if ((0, _definition.isListType)(type2)) {\n    return true;\n  }\n\n  if ((0, _definition.isNonNullType)(type1)) {\n    return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if ((0, _definition.isNonNullType)(type2)) {\n    return true;\n  }\n\n  if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n\n  return cached;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var _i9 = 0, _selectionSet$selecti2 = selectionSet.selections; _i9 < _selectionSet$selecti2.length; _i9++) {\n    var selection = _selectionSet$selecti2[_i9];\n\n    switch (selection.kind) {\n      case _kinds.Kind.FIELD:\n        {\n          var fieldName = selection.name.value;\n          var fieldDef = void 0;\n\n          if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {\n            fieldDef = parentType.getFields()[fieldName];\n          }\n\n          var responseName = selection.alias ? selection.alias.value : fieldName;\n\n          if (!nodeAndDefs[responseName]) {\n            nodeAndDefs[responseName] = [];\n          }\n\n          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n          break;\n        }\n\n      case _kinds.Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case _kinds.Kind.INLINE_FRAGMENT:\n        {\n          var typeCondition = selection.typeCondition;\n          var inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;\n\n          _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n\n          break;\n        }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref6) {\n      var reason = _ref6[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref7) {\n      var fields1 = _ref7[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref8) {\n      var fields2 = _ref8[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\n\nvar PairSet = /*#__PURE__*/function () {\n  function PairSet() {\n    this._data = Object.create(null);\n  }\n\n  var _proto = PairSet.prototype;\n\n  _proto.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n\n\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n\n    return true;\n  };\n\n  _proto.add = function add(a, b, areMutuallyExclusive) {\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\n\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\n  };\n\n  return PairSet;\n}();\n\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\n  var map = data[a];\n\n  if (!map) {\n    map = Object.create(null);\n    data[a] = map;\n  }\n\n  map[b] = areMutuallyExclusive;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4599, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\n/**\n * Unique input field names\n *\n * A GraphQL input object value is only valid if all supplied fields are\n * uniquely named.\n */\nfunction UniqueInputFieldNamesRule(context) {\n  var knownNameStack = [];\n  var knownNames = Object.create(null);\n  return {\n    ObjectValue: {\n      enter: function enter() {\n        knownNameStack.push(knownNames);\n        knownNames = Object.create(null);\n      },\n      leave: function leave() {\n        knownNames = knownNameStack.pop();\n      }\n    },\n    ObjectField: function ObjectField(node) {\n      var fieldName = node.name.value;\n\n      if (knownNames[fieldName]) {\n        context.reportError(new _GraphQLError.GraphQLError(\"There can be only one input field named \\\"\".concat(fieldName, \"\\\".\"), [knownNames[fieldName], node.name]));\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,yBAAyB,GAAG;AAEpC,IAAI;AAEJ;;;;;CAKC,GACD,SAAS,0BAA0B,OAAO;IACxC,IAAI,iBAAiB,EAAE;IACvB,IAAI,aAAa,OAAO,MAAM,CAAC;IAC/B,OAAO;QACL,aAAa;YACX,OAAO,SAAS;gBACd,eAAe,IAAI,CAAC;gBACpB,aAAa,OAAO,MAAM,CAAC;YAC7B;YACA,OAAO,SAAS;gBACd,aAAa,eAAe,GAAG;YACjC;QACF;QACA,aAAa,SAAS,YAAY,IAAI;YACpC,IAAI,YAAY,KAAK,IAAI,CAAC,KAAK;YAE/B,IAAI,UAAU,CAAC,UAAU,EAAE;gBACzB,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,6CAA6C,MAAM,CAAC,WAAW,QAAQ;oBAAC,UAAU,CAAC,UAAU;oBAAE,KAAK,IAAI;iBAAC;YAC9J,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,KAAK,IAAI;YACnC;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4641, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\n/**\n * Lone Schema definition\n *\n * A GraphQL document is only valid if it contains only one schema definition.\n */\nfunction LoneSchemaDefinitionRule(context) {\n  var _ref, _ref2, _oldSchema$astNode;\n\n  var oldSchema = context.getSchema();\n  var alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();\n  var schemaDefinitionsCount = 0;\n  return {\n    SchemaDefinition: function SchemaDefinition(node) {\n      if (alreadyDefined) {\n        context.reportError(new _GraphQLError.GraphQLError('Cannot define a new schema within a schema extension.', node));\n        return;\n      }\n\n      if (schemaDefinitionsCount > 0) {\n        context.reportError(new _GraphQLError.GraphQLError('Must provide only one schema definition.', node));\n      }\n\n      ++schemaDefinitionsCount;\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,wBAAwB,GAAG;AAEnC,IAAI;AAEJ;;;;CAIC,GACD,SAAS,yBAAyB,OAAO;IACvC,IAAI,MAAM,OAAO;IAEjB,IAAI,YAAY,QAAQ,SAAS;IACjC,IAAI,iBAAiB,CAAC,OAAO,CAAC,QAAQ,CAAC,qBAAqB,cAAc,QAAQ,cAAc,KAAK,IAAI,KAAK,IAAI,UAAU,OAAO,MAAM,QAAQ,uBAAuB,KAAK,IAAI,qBAAqB,cAAc,QAAQ,cAAc,KAAK,IAAI,KAAK,IAAI,UAAU,YAAY,EAAE,MAAM,QAAQ,UAAU,KAAK,IAAI,QAAQ,cAAc,QAAQ,cAAc,KAAK,IAAI,KAAK,IAAI,UAAU,eAAe,EAAE,MAAM,QAAQ,SAAS,KAAK,IAAI,OAAO,cAAc,QAAQ,cAAc,KAAK,IAAI,KAAK,IAAI,UAAU,mBAAmB;IACxgB,IAAI,yBAAyB;IAC7B,OAAO;QACL,kBAAkB,SAAS,iBAAiB,IAAI;YAC9C,IAAI,gBAAgB;gBAClB,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,yDAAyD;gBAC5G;YACF;YAEA,IAAI,yBAAyB,GAAG;gBAC9B,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,4CAA4C;YACjG;YAEA,EAAE;QACJ;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4674, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueOperationTypesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueOperationTypesRule = UniqueOperationTypesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\n/**\n * Unique operation types\n *\n * A GraphQL document is only valid if it has only one type per operation.\n */\nfunction UniqueOperationTypesRule(context) {\n  var schema = context.getSchema();\n  var definedOperationTypes = Object.create(null);\n  var existingOperationTypes = schema ? {\n    query: schema.getQueryType(),\n    mutation: schema.getMutationType(),\n    subscription: schema.getSubscriptionType()\n  } : {};\n  return {\n    SchemaDefinition: checkOperationTypes,\n    SchemaExtension: checkOperationTypes\n  };\n\n  function checkOperationTypes(node) {\n    var _node$operationTypes;\n\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n\n    for (var _i2 = 0; _i2 < operationTypesNodes.length; _i2++) {\n      var operationType = operationTypesNodes[_i2];\n      var operation = operationType.operation;\n      var alreadyDefinedOperationType = definedOperationTypes[operation];\n\n      if (existingOperationTypes[operation]) {\n        context.reportError(new _GraphQLError.GraphQLError(\"Type for \".concat(operation, \" already defined in the schema. It cannot be redefined.\"), operationType));\n      } else if (alreadyDefinedOperationType) {\n        context.reportError(new _GraphQLError.GraphQLError(\"There can be only one \".concat(operation, \" type in schema.\"), [alreadyDefinedOperationType, operationType]));\n      } else {\n        definedOperationTypes[operation] = operationType;\n      }\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,wBAAwB,GAAG;AAEnC,IAAI;AAEJ;;;;CAIC,GACD,SAAS,yBAAyB,OAAO;IACvC,IAAI,SAAS,QAAQ,SAAS;IAC9B,IAAI,wBAAwB,OAAO,MAAM,CAAC;IAC1C,IAAI,yBAAyB,SAAS;QACpC,OAAO,OAAO,YAAY;QAC1B,UAAU,OAAO,eAAe;QAChC,cAAc,OAAO,mBAAmB;IAC1C,IAAI,CAAC;IACL,OAAO;QACL,kBAAkB;QAClB,iBAAiB;IACnB;;;IAEA,SAAS,oBAAoB,IAAI;QAC/B,IAAI;QAEJ,kFAAkF;QAClF,IAAI,sBAAsB,CAAC,uBAAuB,KAAK,cAAc,MAAM,QAAQ,yBAAyB,KAAK,IAAI,uBAAuB,EAAE;QAE9I,IAAK,IAAI,MAAM,GAAG,MAAM,oBAAoB,MAAM,EAAE,MAAO;YACzD,IAAI,gBAAgB,mBAAmB,CAAC,IAAI;YAC5C,IAAI,YAAY,cAAc,SAAS;YACvC,IAAI,8BAA8B,qBAAqB,CAAC,UAAU;YAElE,IAAI,sBAAsB,CAAC,UAAU,EAAE;gBACrC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,YAAY,MAAM,CAAC,WAAW,4DAA4D;YAC/I,OAAO,IAAI,6BAA6B;gBACtC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,yBAAyB,MAAM,CAAC,WAAW,qBAAqB;oBAAC;oBAA6B;iBAAc;YACjK,OAAO;gBACL,qBAAqB,CAAC,UAAU,GAAG;YACrC;QACF;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4725, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueTypeNamesRule = UniqueTypeNamesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\n/**\n * Unique type names\n *\n * A GraphQL document is only valid if all defined types have unique names.\n */\nfunction UniqueTypeNamesRule(context) {\n  var knownTypeNames = Object.create(null);\n  var schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName\n  };\n\n  function checkTypeName(node) {\n    var typeName = node.name.value;\n\n    if (schema === null || schema === void 0 ? void 0 : schema.getType(typeName)) {\n      context.reportError(new _GraphQLError.GraphQLError(\"Type \\\"\".concat(typeName, \"\\\" already exists in the schema. It cannot also be defined in this type definition.\"), node.name));\n      return;\n    }\n\n    if (knownTypeNames[typeName]) {\n      context.reportError(new _GraphQLError.GraphQLError(\"There can be only one type named \\\"\".concat(typeName, \"\\\".\"), [knownTypeNames[typeName], node.name]));\n    } else {\n      knownTypeNames[typeName] = node.name;\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,mBAAmB,GAAG;AAE9B,IAAI;AAEJ;;;;CAIC,GACD,SAAS,oBAAoB,OAAO;IAClC,IAAI,iBAAiB,OAAO,MAAM,CAAC;IACnC,IAAI,SAAS,QAAQ,SAAS;IAC9B,OAAO;QACL,sBAAsB;QACtB,sBAAsB;QACtB,yBAAyB;QACzB,qBAAqB;QACrB,oBAAoB;QACpB,2BAA2B;IAC7B;;;IAEA,SAAS,cAAc,IAAI;QACzB,IAAI,WAAW,KAAK,IAAI,CAAC,KAAK;QAE9B,IAAI,WAAW,QAAQ,WAAW,KAAK,IAAI,KAAK,IAAI,OAAO,OAAO,CAAC,WAAW;YAC5E,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,UAAU,MAAM,CAAC,UAAU,wFAAwF,KAAK,IAAI;YAC/K;QACF;QAEA,IAAI,cAAc,CAAC,SAAS,EAAE;YAC5B,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,sCAAsC,MAAM,CAAC,UAAU,QAAQ;gBAAC,cAAc,CAAC,SAAS;gBAAE,KAAK,IAAI;aAAC;QACzJ,OAAO;YACL,cAAc,CAAC,SAAS,GAAG,KAAK,IAAI;QACtC;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4770, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _definition = require(\"../../type/definition\");\n\n/**\n * Unique enum value names\n *\n * A GraphQL enum type is only valid if all its values are uniquely named.\n */\nfunction UniqueEnumValueNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  var knownValueNames = Object.create(null);\n  return {\n    EnumTypeDefinition: checkValueUniqueness,\n    EnumTypeExtension: checkValueUniqueness\n  };\n\n  function checkValueUniqueness(node) {\n    var _node$values;\n\n    var typeName = node.name.value;\n\n    if (!knownValueNames[typeName]) {\n      knownValueNames[typeName] = Object.create(null);\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n    var valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n    var valueNames = knownValueNames[typeName];\n\n    for (var _i2 = 0; _i2 < valueNodes.length; _i2++) {\n      var valueDef = valueNodes[_i2];\n      var valueName = valueDef.name.value;\n      var existingType = existingTypeMap[typeName];\n\n      if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {\n        context.reportError(new _GraphQLError.GraphQLError(\"Enum value \\\"\".concat(typeName, \".\").concat(valueName, \"\\\" already exists in the schema. It cannot also be defined in this type extension.\"), valueDef.name));\n      } else if (valueNames[valueName]) {\n        context.reportError(new _GraphQLError.GraphQLError(\"Enum value \\\"\".concat(typeName, \".\").concat(valueName, \"\\\" can only be defined once.\"), [valueNames[valueName], valueDef.name]));\n      } else {\n        valueNames[valueName] = valueDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,wBAAwB,GAAG;AAEnC,IAAI;AAEJ,IAAI;AAEJ;;;;CAIC,GACD,SAAS,yBAAyB,OAAO;IACvC,IAAI,SAAS,QAAQ,SAAS;IAC9B,IAAI,kBAAkB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACnE,IAAI,kBAAkB,OAAO,MAAM,CAAC;IACpC,OAAO;QACL,oBAAoB;QACpB,mBAAmB;IACrB;;;IAEA,SAAS,qBAAqB,IAAI;QAChC,IAAI;QAEJ,IAAI,WAAW,KAAK,IAAI,CAAC,KAAK;QAE9B,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE;YAC9B,eAAe,CAAC,SAAS,GAAG,OAAO,MAAM,CAAC;QAC5C,EAAE,kFAAkF;QAGpF,IAAI,aAAa,CAAC,eAAe,KAAK,MAAM,MAAM,QAAQ,iBAAiB,KAAK,IAAI,eAAe,EAAE;QACrG,IAAI,aAAa,eAAe,CAAC,SAAS;QAE1C,IAAK,IAAI,MAAM,GAAG,MAAM,WAAW,MAAM,EAAE,MAAO;YAChD,IAAI,WAAW,UAAU,CAAC,IAAI;YAC9B,IAAI,YAAY,SAAS,IAAI,CAAC,KAAK;YACnC,IAAI,eAAe,eAAe,CAAC,SAAS;YAE5C,IAAI,CAAC,GAAG,YAAY,UAAU,EAAE,iBAAiB,aAAa,QAAQ,CAAC,YAAY;gBACjF,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,gBAAgB,MAAM,CAAC,UAAU,KAAK,MAAM,CAAC,WAAW,uFAAuF,SAAS,IAAI;YACjN,OAAO,IAAI,UAAU,CAAC,UAAU,EAAE;gBAChC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,gBAAgB,MAAM,CAAC,UAAU,KAAK,MAAM,CAAC,WAAW,iCAAiC;oBAAC,UAAU,CAAC,UAAU;oBAAE,SAAS,IAAI;iBAAC;YACpL,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,SAAS,IAAI;YACvC;QACF;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4822, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _definition = require(\"../../type/definition\");\n\n/**\n * Unique field definition names\n *\n * A GraphQL complex type is only valid if all its fields are uniquely named.\n */\nfunction UniqueFieldDefinitionNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  var knownFieldNames = Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness\n  };\n\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n\n    var typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n    var fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n    var fieldNames = knownFieldNames[typeName];\n\n    for (var _i2 = 0; _i2 < fieldNodes.length; _i2++) {\n      var fieldDef = fieldNodes[_i2];\n      var fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(new _GraphQLError.GraphQLError(\"Field \\\"\".concat(typeName, \".\").concat(fieldName, \"\\\" already exists in the schema. It cannot also be defined in this type extension.\"), fieldDef.name));\n      } else if (fieldNames[fieldName]) {\n        context.reportError(new _GraphQLError.GraphQLError(\"Field \\\"\".concat(typeName, \".\").concat(fieldName, \"\\\" can only be defined once.\"), [fieldNames[fieldName], fieldDef.name]));\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasField(type, fieldName) {\n  if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {\n    return type.getFields()[fieldName];\n  }\n\n  return false;\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,8BAA8B,GAAG;AAEzC,IAAI;AAEJ,IAAI;AAEJ;;;;CAIC,GACD,SAAS,+BAA+B,OAAO;IAC7C,IAAI,SAAS,QAAQ,SAAS;IAC9B,IAAI,kBAAkB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACnE,IAAI,kBAAkB,OAAO,MAAM,CAAC;IACpC,OAAO;QACL,2BAA2B;QAC3B,0BAA0B;QAC1B,yBAAyB;QACzB,wBAAwB;QACxB,sBAAsB;QACtB,qBAAqB;IACvB;;;IAEA,SAAS,qBAAqB,IAAI;QAChC,IAAI;QAEJ,IAAI,WAAW,KAAK,IAAI,CAAC,KAAK;QAE9B,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE;YAC9B,eAAe,CAAC,SAAS,GAAG,OAAO,MAAM,CAAC;QAC5C,EAAE,kFAAkF;QAGpF,IAAI,aAAa,CAAC,eAAe,KAAK,MAAM,MAAM,QAAQ,iBAAiB,KAAK,IAAI,eAAe,EAAE;QACrG,IAAI,aAAa,eAAe,CAAC,SAAS;QAE1C,IAAK,IAAI,MAAM,GAAG,MAAM,WAAW,MAAM,EAAE,MAAO;YAChD,IAAI,WAAW,UAAU,CAAC,IAAI;YAC9B,IAAI,YAAY,SAAS,IAAI,CAAC,KAAK;YAEnC,IAAI,SAAS,eAAe,CAAC,SAAS,EAAE,YAAY;gBAClD,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,WAAW,MAAM,CAAC,UAAU,KAAK,MAAM,CAAC,WAAW,uFAAuF,SAAS,IAAI;YAC5M,OAAO,IAAI,UAAU,CAAC,UAAU,EAAE;gBAChC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,WAAW,MAAM,CAAC,UAAU,KAAK,MAAM,CAAC,WAAW,iCAAiC;oBAAC,UAAU,CAAC,UAAU;oBAAE,SAAS,IAAI;iBAAC;YAC/K,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,SAAS,IAAI;YACvC;QACF;QAEA,OAAO;IACT;AACF;AAEA,SAAS,SAAS,IAAI,EAAE,SAAS;IAC/B,IAAI,CAAC,GAAG,YAAY,YAAY,EAAE,SAAS,CAAC,GAAG,YAAY,eAAe,EAAE,SAAS,CAAC,GAAG,YAAY,iBAAiB,EAAE,OAAO;QAC7H,OAAO,KAAK,SAAS,EAAE,CAAC,UAAU;IACpC;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4883, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\n/**\n * Unique directive names\n *\n * A GraphQL document is only valid if all defined directives have unique names.\n */\nfunction UniqueDirectiveNamesRule(context) {\n  var knownDirectiveNames = Object.create(null);\n  var schema = context.getSchema();\n  return {\n    DirectiveDefinition: function DirectiveDefinition(node) {\n      var directiveName = node.name.value;\n\n      if (schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName)) {\n        context.reportError(new _GraphQLError.GraphQLError(\"Directive \\\"@\".concat(directiveName, \"\\\" already exists in the schema. It cannot be redefined.\"), node.name));\n        return;\n      }\n\n      if (knownDirectiveNames[directiveName]) {\n        context.reportError(new _GraphQLError.GraphQLError(\"There can be only one directive named \\\"@\".concat(directiveName, \"\\\".\"), [knownDirectiveNames[directiveName], node.name]));\n      } else {\n        knownDirectiveNames[directiveName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,wBAAwB,GAAG;AAEnC,IAAI;AAEJ;;;;CAIC,GACD,SAAS,yBAAyB,OAAO;IACvC,IAAI,sBAAsB,OAAO,MAAM,CAAC;IACxC,IAAI,SAAS,QAAQ,SAAS;IAC9B,OAAO;QACL,qBAAqB,SAAS,oBAAoB,IAAI;YACpD,IAAI,gBAAgB,KAAK,IAAI,CAAC,KAAK;YAEnC,IAAI,WAAW,QAAQ,WAAW,KAAK,IAAI,KAAK,IAAI,OAAO,YAAY,CAAC,gBAAgB;gBACtF,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,gBAAgB,MAAM,CAAC,eAAe,6DAA6D,KAAK,IAAI;gBAC/J;YACF;YAEA,IAAI,mBAAmB,CAAC,cAAc,EAAE;gBACtC,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,4CAA4C,MAAM,CAAC,eAAe,QAAQ;oBAAC,mBAAmB,CAAC,cAAc;oBAAE,KAAK,IAAI;iBAAC;YAC9K,OAAO;gBACL,mBAAmB,CAAC,cAAc,GAAG,KAAK,IAAI;YAChD;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4920, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;\n\nvar _inspect = _interopRequireDefault(require(\"../../jsutils/inspect\"));\n\nvar _invariant = _interopRequireDefault(require(\"../../jsutils/invariant\"));\n\nvar _didYouMean = _interopRequireDefault(require(\"../../jsutils/didYouMean\"));\n\nvar _suggestionList = _interopRequireDefault(require(\"../../jsutils/suggestionList\"));\n\nvar _GraphQLError = require(\"../../error/GraphQLError\");\n\nvar _kinds = require(\"../../language/kinds\");\n\nvar _predicates = require(\"../../language/predicates\");\n\nvar _definition = require(\"../../type/definition\");\n\nvar _defKindToExtKind;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nfunction PossibleTypeExtensionsRule(context) {\n  var schema = context.getSchema();\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n\n  function checkExtension(node) {\n    var typeName = node.name.value;\n    var defNode = definedTypes[typeName];\n    var existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    var expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        var kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(new _GraphQLError.GraphQLError(\"Cannot extend non-\".concat(kindStr, \" type \\\"\").concat(typeName, \"\\\".\"), defNode ? [defNode, node] : node));\n      }\n    } else {\n      var allTypeNames = Object.keys(definedTypes);\n\n      if (schema) {\n        allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));\n      }\n\n      var suggestedTypes = (0, _suggestionList.default)(typeName, allTypeNames);\n      context.reportError(new _GraphQLError.GraphQLError(\"Cannot extend type \\\"\".concat(typeName, \"\\\" because it is not defined.\") + (0, _didYouMean.default)(suggestedTypes), node.name));\n    }\n  }\n}\n\nvar defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, _kinds.Kind.SCALAR_TYPE_DEFINITION, _kinds.Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.OBJECT_TYPE_DEFINITION, _kinds.Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.INTERFACE_TYPE_DEFINITION, _kinds.Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.UNION_TYPE_DEFINITION, _kinds.Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.ENUM_TYPE_DEFINITION, _kinds.Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION, _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);\n\nfunction typeToExtKind(type) {\n  if ((0, _definition.isScalarType)(type)) {\n    return _kinds.Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isObjectType)(type)) {\n    return _kinds.Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isInterfaceType)(type)) {\n    return _kinds.Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isUnionType)(type)) {\n    return _kinds.Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isEnumType)(type)) {\n    return _kinds.Kind.ENUM_TYPE_EXTENSION;\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || (0, _invariant.default)(0, 'Unexpected type: ' + (0, _inspect.default)(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case _kinds.Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case _kinds.Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case _kinds.Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case _kinds.Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case _kinds.Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || (0, _invariant.default)(0, 'Unexpected kind: ' + (0, _inspect.default)(kind));\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,0BAA0B,GAAG;AAErC,IAAI,WAAW;AAEf,IAAI,aAAa;AAEjB,IAAI,cAAc;AAElB,IAAI,kBAAkB;AAEtB,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F,SAAS,gBAAgB,GAAG,EAAE,GAAG,EAAE,KAAK;IAAI,IAAI,OAAO,KAAK;QAAE,OAAO,cAAc,CAAC,KAAK,KAAK;YAAE,OAAO;YAAO,YAAY;YAAM,cAAc;YAAM,UAAU;QAAK;IAAI,OAAO;QAAE,GAAG,CAAC,IAAI,GAAG;IAAO;IAAE,OAAO;AAAK;AAEhN;;;;CAIC,GACD,SAAS,2BAA2B,OAAO;IACzC,IAAI,SAAS,QAAQ,SAAS;IAC9B,IAAI,eAAe,OAAO,MAAM,CAAC;IAEjC,IAAK,IAAI,MAAM,GAAG,yBAAyB,QAAQ,WAAW,GAAG,WAAW,EAAE,MAAM,uBAAuB,MAAM,EAAE,MAAO;QACxH,IAAI,MAAM,sBAAsB,CAAC,IAAI;QAErC,IAAI,CAAC,GAAG,YAAY,oBAAoB,EAAE,MAAM;YAC9C,YAAY,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG;QACjC;IACF;IAEA,OAAO;QACL,qBAAqB;QACrB,qBAAqB;QACrB,wBAAwB;QACxB,oBAAoB;QACpB,mBAAmB;QACnB,0BAA0B;IAC5B;;;IAEA,SAAS,eAAe,IAAI;QAC1B,IAAI,WAAW,KAAK,IAAI,CAAC,KAAK;QAC9B,IAAI,UAAU,YAAY,CAAC,SAAS;QACpC,IAAI,eAAe,WAAW,QAAQ,WAAW,KAAK,IAAI,KAAK,IAAI,OAAO,OAAO,CAAC;QAClF,IAAI;QAEJ,IAAI,SAAS;YACX,eAAe,gBAAgB,CAAC,QAAQ,IAAI,CAAC;QAC/C,OAAO,IAAI,cAAc;YACvB,eAAe,cAAc;QAC/B;QAEA,IAAI,cAAc;YAChB,IAAI,iBAAiB,KAAK,IAAI,EAAE;gBAC9B,IAAI,UAAU,wBAAwB,KAAK,IAAI;gBAC/C,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,qBAAqB,MAAM,CAAC,SAAS,YAAY,MAAM,CAAC,UAAU,QAAQ,UAAU;oBAAC;oBAAS;iBAAK,GAAG;YAC3J;QACF,OAAO;YACL,IAAI,eAAe,OAAO,IAAI,CAAC;YAE/B,IAAI,QAAQ;gBACV,eAAe,aAAa,MAAM,CAAC,OAAO,IAAI,CAAC,OAAO,UAAU;YAClE;YAEA,IAAI,iBAAiB,CAAC,GAAG,gBAAgB,OAAO,EAAE,UAAU;YAC5D,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,wBAAwB,MAAM,CAAC,UAAU,mCAAmC,CAAC,GAAG,YAAY,OAAO,EAAE,iBAAiB,KAAK,IAAI;QACpL;IACF;AACF;AAEA,IAAI,mBAAmB,CAAC,oBAAoB,CAAC,GAAG,gBAAgB,mBAAmB,OAAO,IAAI,CAAC,sBAAsB,EAAE,OAAO,IAAI,CAAC,qBAAqB,GAAG,gBAAgB,mBAAmB,OAAO,IAAI,CAAC,sBAAsB,EAAE,OAAO,IAAI,CAAC,qBAAqB,GAAG,gBAAgB,mBAAmB,OAAO,IAAI,CAAC,yBAAyB,EAAE,OAAO,IAAI,CAAC,wBAAwB,GAAG,gBAAgB,mBAAmB,OAAO,IAAI,CAAC,qBAAqB,EAAE,OAAO,IAAI,CAAC,oBAAoB,GAAG,gBAAgB,mBAAmB,OAAO,IAAI,CAAC,oBAAoB,EAAE,OAAO,IAAI,CAAC,mBAAmB,GAAG,gBAAgB,mBAAmB,OAAO,IAAI,CAAC,4BAA4B,EAAE,OAAO,IAAI,CAAC,2BAA2B,GAAG,iBAAiB;AAE/sB,SAAS,cAAc,IAAI;IACzB,IAAI,CAAC,GAAG,YAAY,YAAY,EAAE,OAAO;QACvC,OAAO,OAAO,IAAI,CAAC,qBAAqB;IAC1C;IAEA,IAAI,CAAC,GAAG,YAAY,YAAY,EAAE,OAAO;QACvC,OAAO,OAAO,IAAI,CAAC,qBAAqB;IAC1C;IAEA,IAAI,CAAC,GAAG,YAAY,eAAe,EAAE,OAAO;QAC1C,OAAO,OAAO,IAAI,CAAC,wBAAwB;IAC7C;IAEA,IAAI,CAAC,GAAG,YAAY,WAAW,EAAE,OAAO;QACtC,OAAO,OAAO,IAAI,CAAC,oBAAoB;IACzC;IAEA,IAAI,CAAC,GAAG,YAAY,UAAU,EAAE,OAAO;QACrC,OAAO,OAAO,IAAI,CAAC,mBAAmB;IACxC,EAAE,kFAAkF;IAGpF,IAAI,CAAC,GAAG,YAAY,iBAAiB,EAAE,OAAO;QAC5C,OAAO,OAAO,IAAI,CAAC,2BAA2B;IAChD,EAAE,gFAAgF;IAGlF,SAAS,CAAC,GAAG,WAAW,OAAO,EAAE,GAAG,sBAAsB,CAAC,GAAG,SAAS,OAAO,EAAE;AAClF;AAEA,SAAS,wBAAwB,IAAI;IACnC,OAAQ;QACN,KAAK,OAAO,IAAI,CAAC,qBAAqB;YACpC,OAAO;QAET,KAAK,OAAO,IAAI,CAAC,qBAAqB;YACpC,OAAO;QAET,KAAK,OAAO,IAAI,CAAC,wBAAwB;YACvC,OAAO;QAET,KAAK,OAAO,IAAI,CAAC,oBAAoB;YACnC,OAAO;QAET,KAAK,OAAO,IAAI,CAAC,mBAAmB;YAClC,OAAO;QAET,KAAK,OAAO,IAAI,CAAC,2BAA2B;YAC1C,OAAO;IACX,EAAE,gFAAgF;IAGlF,SAAS,CAAC,GAAG,WAAW,OAAO,EAAE,GAAG,sBAAsB,CAAC,GAAG,SAAS,OAAO,EAAE;AAClF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5047, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/specifiedRules.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.specifiedSDLRules = exports.specifiedRules = void 0;\n\nvar _ExecutableDefinitionsRule = require(\"./rules/ExecutableDefinitionsRule\");\n\nvar _UniqueOperationNamesRule = require(\"./rules/UniqueOperationNamesRule\");\n\nvar _LoneAnonymousOperationRule = require(\"./rules/LoneAnonymousOperationRule\");\n\nvar _SingleFieldSubscriptionsRule = require(\"./rules/SingleFieldSubscriptionsRule\");\n\nvar _KnownTypeNamesRule = require(\"./rules/KnownTypeNamesRule\");\n\nvar _FragmentsOnCompositeTypesRule = require(\"./rules/FragmentsOnCompositeTypesRule\");\n\nvar _VariablesAreInputTypesRule = require(\"./rules/VariablesAreInputTypesRule\");\n\nvar _ScalarLeafsRule = require(\"./rules/ScalarLeafsRule\");\n\nvar _FieldsOnCorrectTypeRule = require(\"./rules/FieldsOnCorrectTypeRule\");\n\nvar _UniqueFragmentNamesRule = require(\"./rules/UniqueFragmentNamesRule\");\n\nvar _KnownFragmentNamesRule = require(\"./rules/KnownFragmentNamesRule\");\n\nvar _NoUnusedFragmentsRule = require(\"./rules/NoUnusedFragmentsRule\");\n\nvar _PossibleFragmentSpreadsRule = require(\"./rules/PossibleFragmentSpreadsRule\");\n\nvar _NoFragmentCyclesRule = require(\"./rules/NoFragmentCyclesRule\");\n\nvar _UniqueVariableNamesRule = require(\"./rules/UniqueVariableNamesRule\");\n\nvar _NoUndefinedVariablesRule = require(\"./rules/NoUndefinedVariablesRule\");\n\nvar _NoUnusedVariablesRule = require(\"./rules/NoUnusedVariablesRule\");\n\nvar _KnownDirectivesRule = require(\"./rules/KnownDirectivesRule\");\n\nvar _UniqueDirectivesPerLocationRule = require(\"./rules/UniqueDirectivesPerLocationRule\");\n\nvar _KnownArgumentNamesRule = require(\"./rules/KnownArgumentNamesRule\");\n\nvar _UniqueArgumentNamesRule = require(\"./rules/UniqueArgumentNamesRule\");\n\nvar _ValuesOfCorrectTypeRule = require(\"./rules/ValuesOfCorrectTypeRule\");\n\nvar _ProvidedRequiredArgumentsRule = require(\"./rules/ProvidedRequiredArgumentsRule\");\n\nvar _VariablesInAllowedPositionRule = require(\"./rules/VariablesInAllowedPositionRule\");\n\nvar _OverlappingFieldsCanBeMergedRule = require(\"./rules/OverlappingFieldsCanBeMergedRule\");\n\nvar _UniqueInputFieldNamesRule = require(\"./rules/UniqueInputFieldNamesRule\");\n\nvar _LoneSchemaDefinitionRule = require(\"./rules/LoneSchemaDefinitionRule\");\n\nvar _UniqueOperationTypesRule = require(\"./rules/UniqueOperationTypesRule\");\n\nvar _UniqueTypeNamesRule = require(\"./rules/UniqueTypeNamesRule\");\n\nvar _UniqueEnumValueNamesRule = require(\"./rules/UniqueEnumValueNamesRule\");\n\nvar _UniqueFieldDefinitionNamesRule = require(\"./rules/UniqueFieldDefinitionNamesRule\");\n\nvar _UniqueDirectiveNamesRule = require(\"./rules/UniqueDirectiveNamesRule\");\n\nvar _PossibleTypeExtensionsRule = require(\"./rules/PossibleTypeExtensionsRule\");\n\n// Spec Section: \"Executable Definitions\"\n// Spec Section: \"Operation Name Uniqueness\"\n// Spec Section: \"Lone Anonymous Operation\"\n// Spec Section: \"Subscriptions with Single Root Field\"\n// Spec Section: \"Fragment Spread Type Existence\"\n// Spec Section: \"Fragments on Composite Types\"\n// Spec Section: \"Variables are Input Types\"\n// Spec Section: \"Leaf Field Selections\"\n// Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n// Spec Section: \"Fragment Name Uniqueness\"\n// Spec Section: \"Fragment spread target defined\"\n// Spec Section: \"Fragments must be used\"\n// Spec Section: \"Fragment spread is possible\"\n// Spec Section: \"Fragments must not form cycles\"\n// Spec Section: \"Variable Uniqueness\"\n// Spec Section: \"All Variable Used Defined\"\n// Spec Section: \"All Variables Used\"\n// Spec Section: \"Directives Are Defined\"\n// Spec Section: \"Directives Are Unique Per Location\"\n// Spec Section: \"Argument Names\"\n// Spec Section: \"Argument Uniqueness\"\n// Spec Section: \"Value Type Correctness\"\n// Spec Section: \"Argument Optionality\"\n// Spec Section: \"All Variable Usages Are Allowed\"\n// Spec Section: \"Field Selection Merging\"\n// Spec Section: \"Input Object Field Uniqueness\"\n// SDL-specific validation rules\n\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n *\n * The order of the rules in this list has been adjusted to lead to the\n * most clear output when encountering multiple validation errors.\n */\nvar specifiedRules = Object.freeze([_ExecutableDefinitionsRule.ExecutableDefinitionsRule, _UniqueOperationNamesRule.UniqueOperationNamesRule, _LoneAnonymousOperationRule.LoneAnonymousOperationRule, _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule, _KnownTypeNamesRule.KnownTypeNamesRule, _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule, _VariablesAreInputTypesRule.VariablesAreInputTypesRule, _ScalarLeafsRule.ScalarLeafsRule, _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule, _UniqueFragmentNamesRule.UniqueFragmentNamesRule, _KnownFragmentNamesRule.KnownFragmentNamesRule, _NoUnusedFragmentsRule.NoUnusedFragmentsRule, _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule, _NoFragmentCyclesRule.NoFragmentCyclesRule, _UniqueVariableNamesRule.UniqueVariableNamesRule, _NoUndefinedVariablesRule.NoUndefinedVariablesRule, _NoUnusedVariablesRule.NoUnusedVariablesRule, _KnownDirectivesRule.KnownDirectivesRule, _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule, _KnownArgumentNamesRule.KnownArgumentNamesRule, _UniqueArgumentNamesRule.UniqueArgumentNamesRule, _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule, _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule, _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule, _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule, _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule]);\n/**\n * @internal\n */\n\nexports.specifiedRules = specifiedRules;\nvar specifiedSDLRules = Object.freeze([_LoneSchemaDefinitionRule.LoneSchemaDefinitionRule, _UniqueOperationTypesRule.UniqueOperationTypesRule, _UniqueTypeNamesRule.UniqueTypeNamesRule, _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule, _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule, _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule, _KnownTypeNamesRule.KnownTypeNamesRule, _KnownDirectivesRule.KnownDirectivesRule, _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule, _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule, _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule, _UniqueArgumentNamesRule.UniqueArgumentNamesRule, _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule, _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule]);\nexports.specifiedSDLRules = specifiedSDLRules;\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,iBAAiB,GAAG,QAAQ,cAAc,GAAG,KAAK;AAE1D,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,yCAAyC;AACzC,4CAA4C;AAC5C,2CAA2C;AAC3C,uDAAuD;AACvD,iDAAiD;AACjD,+CAA+C;AAC/C,4CAA4C;AAC5C,wCAAwC;AACxC,4EAA4E;AAC5E,2CAA2C;AAC3C,iDAAiD;AACjD,yCAAyC;AACzC,8CAA8C;AAC9C,iDAAiD;AACjD,sCAAsC;AACtC,4CAA4C;AAC5C,qCAAqC;AACrC,yCAAyC;AACzC,qDAAqD;AACrD,iCAAiC;AACjC,sCAAsC;AACtC,yCAAyC;AACzC,uCAAuC;AACvC,kDAAkD;AAClD,0CAA0C;AAC1C,gDAAgD;AAChD,gCAAgC;AAEhC;;;;;CAKC,GACD,IAAI,iBAAiB,OAAO,MAAM,CAAC;IAAC,2BAA2B,yBAAyB;IAAE,0BAA0B,wBAAwB;IAAE,4BAA4B,0BAA0B;IAAE,8BAA8B,4BAA4B;IAAE,oBAAoB,kBAAkB;IAAE,+BAA+B,6BAA6B;IAAE,4BAA4B,0BAA0B;IAAE,iBAAiB,eAAe;IAAE,yBAAyB,uBAAuB;IAAE,yBAAyB,uBAAuB;IAAE,wBAAwB,sBAAsB;IAAE,uBAAuB,qBAAqB;IAAE,6BAA6B,2BAA2B;IAAE,sBAAsB,oBAAoB;IAAE,yBAAyB,uBAAuB;IAAE,0BAA0B,wBAAwB;IAAE,uBAAuB,qBAAqB;IAAE,qBAAqB,mBAAmB;IAAE,iCAAiC,+BAA+B;IAAE,wBAAwB,sBAAsB;IAAE,yBAAyB,uBAAuB;IAAE,yBAAyB,uBAAuB;IAAE,+BAA+B,6BAA6B;IAAE,gCAAgC,8BAA8B;IAAE,kCAAkC,gCAAgC;IAAE,2BAA2B,yBAAyB;CAAC;AACr3C;;CAEC,GAED,QAAQ,cAAc,GAAG;AACzB,IAAI,oBAAoB,OAAO,MAAM,CAAC;IAAC,0BAA0B,wBAAwB;IAAE,0BAA0B,wBAAwB;IAAE,qBAAqB,mBAAmB;IAAE,0BAA0B,wBAAwB;IAAE,gCAAgC,8BAA8B;IAAE,0BAA0B,wBAAwB;IAAE,oBAAoB,kBAAkB;IAAE,qBAAqB,mBAAmB;IAAE,iCAAiC,+BAA+B;IAAE,4BAA4B,0BAA0B;IAAE,wBAAwB,kCAAkC;IAAE,yBAAyB,uBAAuB;IAAE,2BAA2B,yBAAyB;IAAE,+BAA+B,yCAAyC;CAAC;AAC1xB,QAAQ,iBAAiB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5170, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/ValidationContext.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = void 0;\n\nvar _kinds = require(\"../language/kinds\");\n\nvar _visitor = require(\"../language/visitor\");\n\nvar _TypeInfo = require(\"../utilities/TypeInfo\");\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nvar ASTValidationContext = /*#__PURE__*/function () {\n  function ASTValidationContext(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  var _proto = ASTValidationContext.prototype;\n\n  _proto.reportError = function reportError(error) {\n    this._onError(error);\n  };\n\n  _proto.getDocument = function getDocument() {\n    return this._ast;\n  };\n\n  _proto.getFragment = function getFragment(name) {\n    var fragments = this._fragments;\n\n    if (!fragments) {\n      this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {\n        if (statement.kind === _kinds.Kind.FRAGMENT_DEFINITION) {\n          frags[statement.name.value] = statement;\n        }\n\n        return frags;\n      }, Object.create(null));\n    }\n\n    return fragments[name];\n  };\n\n  _proto.getFragmentSpreads = function getFragmentSpreads(node) {\n    var spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      var setsToVisit = [node];\n\n      while (setsToVisit.length !== 0) {\n        var set = setsToVisit.pop();\n\n        for (var _i2 = 0, _set$selections2 = set.selections; _i2 < _set$selections2.length; _i2++) {\n          var selection = _set$selections2[_i2];\n\n          if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  };\n\n  _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {\n    var fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      var collectedNames = Object.create(null);\n      var nodesToVisit = [operation.selectionSet];\n\n      while (nodesToVisit.length !== 0) {\n        var node = nodesToVisit.pop();\n\n        for (var _i4 = 0, _this$getFragmentSpre2 = this.getFragmentSpreads(node); _i4 < _this$getFragmentSpre2.length; _i4++) {\n          var spread = _this$getFragmentSpre2[_i4];\n          var fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            var fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  };\n\n  return ASTValidationContext;\n}();\n\nexports.ASTValidationContext = ASTValidationContext;\n\nvar SDLValidationContext = /*#__PURE__*/function (_ASTValidationContext) {\n  _inheritsLoose(SDLValidationContext, _ASTValidationContext);\n\n  function SDLValidationContext(ast, schema, onError) {\n    var _this;\n\n    _this = _ASTValidationContext.call(this, ast, onError) || this;\n    _this._schema = schema;\n    return _this;\n  }\n\n  var _proto2 = SDLValidationContext.prototype;\n\n  _proto2.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  return SDLValidationContext;\n}(ASTValidationContext);\n\nexports.SDLValidationContext = SDLValidationContext;\n\nvar ValidationContext = /*#__PURE__*/function (_ASTValidationContext2) {\n  _inheritsLoose(ValidationContext, _ASTValidationContext2);\n\n  function ValidationContext(schema, ast, typeInfo, onError) {\n    var _this2;\n\n    _this2 = _ASTValidationContext2.call(this, ast, onError) || this;\n    _this2._schema = schema;\n    _this2._typeInfo = typeInfo;\n    _this2._variableUsages = new Map();\n    _this2._recursiveVariableUsages = new Map();\n    return _this2;\n  }\n\n  var _proto3 = ValidationContext.prototype;\n\n  _proto3.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  _proto3.getVariableUsages = function getVariableUsages(node) {\n    var usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      var newUsages = [];\n      var typeInfo = new _TypeInfo.TypeInfo(this._schema);\n      (0, _visitor.visit)(node, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {\n        VariableDefinition: function VariableDefinition() {\n          return false;\n        },\n        Variable: function Variable(variable) {\n          newUsages.push({\n            node: variable,\n            type: typeInfo.getInputType(),\n            defaultValue: typeInfo.getDefaultValue()\n          });\n        }\n      }));\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  };\n\n  _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {\n    var usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (var _i6 = 0, _this$getRecursivelyR2 = this.getRecursivelyReferencedFragments(operation); _i6 < _this$getRecursivelyR2.length; _i6++) {\n        var frag = _this$getRecursivelyR2[_i6];\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  };\n\n  _proto3.getType = function getType() {\n    return this._typeInfo.getType();\n  };\n\n  _proto3.getParentType = function getParentType() {\n    return this._typeInfo.getParentType();\n  };\n\n  _proto3.getInputType = function getInputType() {\n    return this._typeInfo.getInputType();\n  };\n\n  _proto3.getParentInputType = function getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  };\n\n  _proto3.getFieldDef = function getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  };\n\n  _proto3.getDirective = function getDirective() {\n    return this._typeInfo.getDirective();\n  };\n\n  _proto3.getArgument = function getArgument() {\n    return this._typeInfo.getArgument();\n  };\n\n  _proto3.getEnumValue = function getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  };\n\n  return ValidationContext;\n}(ASTValidationContext);\n\nexports.ValidationContext = ValidationContext;\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,iBAAiB,GAAG,QAAQ,oBAAoB,GAAG,QAAQ,oBAAoB,GAAG,KAAK;AAE/F,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,SAAS,eAAe,QAAQ,EAAE,UAAU;IAAI,SAAS,SAAS,GAAG,OAAO,MAAM,CAAC,WAAW,SAAS;IAAG,SAAS,SAAS,CAAC,WAAW,GAAG;IAAU,SAAS,SAAS,GAAG;AAAY;AAEtL;;;;CAIC,GACD,IAAI,uBAAuB,WAAW,GAAE;IACtC,SAAS,qBAAqB,GAAG,EAAE,OAAO;QACxC,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,gBAAgB,GAAG,IAAI;QAC5B,IAAI,CAAC,+BAA+B,GAAG,IAAI;QAC3C,IAAI,CAAC,QAAQ,GAAG;IAClB;IAEA,IAAI,SAAS,qBAAqB,SAAS;IAE3C,OAAO,WAAW,GAAG,SAAS,YAAY,KAAK;QAC7C,IAAI,CAAC,QAAQ,CAAC;IAChB;IAEA,OAAO,WAAW,GAAG,SAAS;QAC5B,OAAO,IAAI,CAAC,IAAI;IAClB;IAEA,OAAO,WAAW,GAAG,SAAS,YAAY,IAAI;QAC5C,IAAI,YAAY,IAAI,CAAC,UAAU;QAE/B,IAAI,CAAC,WAAW;YACd,IAAI,CAAC,UAAU,GAAG,YAAY,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,SAAU,KAAK,EAAE,SAAS;gBAC5F,IAAI,UAAU,IAAI,KAAK,OAAO,IAAI,CAAC,mBAAmB,EAAE;oBACtD,KAAK,CAAC,UAAU,IAAI,CAAC,KAAK,CAAC,GAAG;gBAChC;gBAEA,OAAO;YACT,GAAG,OAAO,MAAM,CAAC;QACnB;QAEA,OAAO,SAAS,CAAC,KAAK;IACxB;IAEA,OAAO,kBAAkB,GAAG,SAAS,mBAAmB,IAAI;QAC1D,IAAI,UAAU,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC;QAExC,IAAI,CAAC,SAAS;YACZ,UAAU,EAAE;YACZ,IAAI,cAAc;gBAAC;aAAK;YAExB,MAAO,YAAY,MAAM,KAAK,EAAG;gBAC/B,IAAI,MAAM,YAAY,GAAG;gBAEzB,IAAK,IAAI,MAAM,GAAG,mBAAmB,IAAI,UAAU,EAAE,MAAM,iBAAiB,MAAM,EAAE,MAAO;oBACzF,IAAI,YAAY,gBAAgB,CAAC,IAAI;oBAErC,IAAI,UAAU,IAAI,KAAK,OAAO,IAAI,CAAC,eAAe,EAAE;wBAClD,QAAQ,IAAI,CAAC;oBACf,OAAO,IAAI,UAAU,YAAY,EAAE;wBACjC,YAAY,IAAI,CAAC,UAAU,YAAY;oBACzC;gBACF;YACF;YAEA,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,MAAM;QAClC;QAEA,OAAO;IACT;IAEA,OAAO,iCAAiC,GAAG,SAAS,kCAAkC,SAAS;QAC7F,IAAI,YAAY,IAAI,CAAC,+BAA+B,CAAC,GAAG,CAAC;QAEzD,IAAI,CAAC,WAAW;YACd,YAAY,EAAE;YACd,IAAI,iBAAiB,OAAO,MAAM,CAAC;YACnC,IAAI,eAAe;gBAAC,UAAU,YAAY;aAAC;YAE3C,MAAO,aAAa,MAAM,KAAK,EAAG;gBAChC,IAAI,OAAO,aAAa,GAAG;gBAE3B,IAAK,IAAI,MAAM,GAAG,yBAAyB,IAAI,CAAC,kBAAkB,CAAC,OAAO,MAAM,uBAAuB,MAAM,EAAE,MAAO;oBACpH,IAAI,SAAS,sBAAsB,CAAC,IAAI;oBACxC,IAAI,WAAW,OAAO,IAAI,CAAC,KAAK;oBAEhC,IAAI,cAAc,CAAC,SAAS,KAAK,MAAM;wBACrC,cAAc,CAAC,SAAS,GAAG;wBAC3B,IAAI,WAAW,IAAI,CAAC,WAAW,CAAC;wBAEhC,IAAI,UAAU;4BACZ,UAAU,IAAI,CAAC;4BACf,aAAa,IAAI,CAAC,SAAS,YAAY;wBACzC;oBACF;gBACF;YACF;YAEA,IAAI,CAAC,+BAA+B,CAAC,GAAG,CAAC,WAAW;QACtD;QAEA,OAAO;IACT;IAEA,OAAO;AACT;AAEA,QAAQ,oBAAoB,GAAG;AAE/B,IAAI,uBAAuB,WAAW,GAAE,SAAU,qBAAqB;IACrE,eAAe,sBAAsB;IAErC,SAAS,qBAAqB,GAAG,EAAE,MAAM,EAAE,OAAO;QAChD,IAAI;QAEJ,QAAQ,sBAAsB,IAAI,CAAC,IAAI,EAAE,KAAK,YAAY,IAAI;QAC9D,MAAM,OAAO,GAAG;QAChB,OAAO;IACT;IAEA,IAAI,UAAU,qBAAqB,SAAS;IAE5C,QAAQ,SAAS,GAAG,SAAS;QAC3B,OAAO,IAAI,CAAC,OAAO;IACrB;IAEA,OAAO;AACT,EAAE;AAEF,QAAQ,oBAAoB,GAAG;AAE/B,IAAI,oBAAoB,WAAW,GAAE,SAAU,sBAAsB;IACnE,eAAe,mBAAmB;IAElC,SAAS,kBAAkB,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAE,OAAO;QACvD,IAAI;QAEJ,SAAS,uBAAuB,IAAI,CAAC,IAAI,EAAE,KAAK,YAAY,IAAI;QAChE,OAAO,OAAO,GAAG;QACjB,OAAO,SAAS,GAAG;QACnB,OAAO,eAAe,GAAG,IAAI;QAC7B,OAAO,wBAAwB,GAAG,IAAI;QACtC,OAAO;IACT;IAEA,IAAI,UAAU,kBAAkB,SAAS;IAEzC,QAAQ,SAAS,GAAG,SAAS;QAC3B,OAAO,IAAI,CAAC,OAAO;IACrB;IAEA,QAAQ,iBAAiB,GAAG,SAAS,kBAAkB,IAAI;QACzD,IAAI,SAAS,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC;QAEtC,IAAI,CAAC,QAAQ;YACX,IAAI,YAAY,EAAE;YAClB,IAAI,WAAW,IAAI,UAAU,QAAQ,CAAC,IAAI,CAAC,OAAO;YAClD,CAAC,GAAG,SAAS,KAAK,EAAE,MAAM,CAAC,GAAG,UAAU,iBAAiB,EAAE,UAAU;gBACnE,oBAAoB,SAAS;oBAC3B,OAAO;gBACT;gBACA,UAAU,SAAS,SAAS,QAAQ;oBAClC,UAAU,IAAI,CAAC;wBACb,MAAM;wBACN,MAAM,SAAS,YAAY;wBAC3B,cAAc,SAAS,eAAe;oBACxC;gBACF;YACF;YACA,SAAS;YAET,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,MAAM;QACjC;QAEA,OAAO;IACT;IAEA,QAAQ,0BAA0B,GAAG,SAAS,2BAA2B,SAAS;QAChF,IAAI,SAAS,IAAI,CAAC,wBAAwB,CAAC,GAAG,CAAC;QAE/C,IAAI,CAAC,QAAQ;YACX,SAAS,IAAI,CAAC,iBAAiB,CAAC;YAEhC,IAAK,IAAI,MAAM,GAAG,yBAAyB,IAAI,CAAC,iCAAiC,CAAC,YAAY,MAAM,uBAAuB,MAAM,EAAE,MAAO;gBACxI,IAAI,OAAO,sBAAsB,CAAC,IAAI;gBACtC,SAAS,OAAO,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC;YAChD;YAEA,IAAI,CAAC,wBAAwB,CAAC,GAAG,CAAC,WAAW;QAC/C;QAEA,OAAO;IACT;IAEA,QAAQ,OAAO,GAAG,SAAS;QACzB,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO;IAC/B;IAEA,QAAQ,aAAa,GAAG,SAAS;QAC/B,OAAO,IAAI,CAAC,SAAS,CAAC,aAAa;IACrC;IAEA,QAAQ,YAAY,GAAG,SAAS;QAC9B,OAAO,IAAI,CAAC,SAAS,CAAC,YAAY;IACpC;IAEA,QAAQ,kBAAkB,GAAG,SAAS;QACpC,OAAO,IAAI,CAAC,SAAS,CAAC,kBAAkB;IAC1C;IAEA,QAAQ,WAAW,GAAG,SAAS;QAC7B,OAAO,IAAI,CAAC,SAAS,CAAC,WAAW;IACnC;IAEA,QAAQ,YAAY,GAAG,SAAS;QAC9B,OAAO,IAAI,CAAC,SAAS,CAAC,YAAY;IACpC;IAEA,QAAQ,WAAW,GAAG,SAAS;QAC7B,OAAO,IAAI,CAAC,SAAS,CAAC,WAAW;IACnC;IAEA,QAAQ,YAAY,GAAG,SAAS;QAC9B,OAAO,IAAI,CAAC,SAAS,CAAC,YAAY;IACpC;IAEA,OAAO;AACT,EAAE;AAEF,QAAQ,iBAAiB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5362, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/validate.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validate = validate;\nexports.validateSDL = validateSDL;\nexports.assertValidSDL = assertValidSDL;\nexports.assertValidSDLExtension = assertValidSDLExtension;\n\nvar _devAssert = _interopRequireDefault(require(\"../jsutils/devAssert\"));\n\nvar _GraphQLError = require(\"../error/GraphQLError\");\n\nvar _visitor = require(\"../language/visitor\");\n\nvar _validate = require(\"../type/validate\");\n\nvar _TypeInfo = require(\"../utilities/TypeInfo\");\n\nvar _specifiedRules = require(\"./specifiedRules\");\n\nvar _ValidationContext = require(\"./ValidationContext\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\nfunction validate(schema, documentAST) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _specifiedRules.specifiedRules;\n  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _TypeInfo.TypeInfo(schema);\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    maxErrors: undefined\n  };\n  documentAST || (0, _devAssert.default)(0, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  (0, _validate.assertValidSchema)(schema);\n  var abortObj = Object.freeze({});\n  var errors = [];\n  var context = new _ValidationContext.ValidationContext(schema, documentAST, typeInfo, function (error) {\n    if (options.maxErrors != null && errors.length >= options.maxErrors) {\n      errors.push(new _GraphQLError.GraphQLError('Too many validation errors, error limit reached. Validation aborted.'));\n      throw abortObj;\n    }\n\n    errors.push(error);\n  }); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  var visitor = (0, _visitor.visitInParallel)(rules.map(function (rule) {\n    return rule(context);\n  })); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    (0, _visitor.visit)(documentAST, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\n\nfunction validateSDL(documentAST, schemaToExtend) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _specifiedRules.specifiedSDLRules;\n  var errors = [];\n  var context = new _ValidationContext.SDLValidationContext(documentAST, schemaToExtend, function (error) {\n    errors.push(error);\n  });\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\n\nfunction assertValidSDL(documentAST) {\n  var errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\n\nfunction assertValidSDLExtension(documentAST, schema) {\n  var errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5472, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NoDeprecatedCustomRule = NoDeprecatedCustomRule;\n\nvar _GraphQLError = require(\"../../../error/GraphQLError\");\n\nvar _definition = require(\"../../../type/definition\");\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nfunction NoDeprecatedCustomRule(context) {\n  return {\n    Field: function Field(node) {\n      var fieldDef = context.getFieldDef();\n      var parentType = context.getParentType();\n\n      if (parentType && (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason) != null) {\n        context.reportError(new _GraphQLError.GraphQLError(\"The field \".concat(parentType.name, \".\").concat(fieldDef.name, \" is deprecated. \") + fieldDef.deprecationReason, node));\n      }\n    },\n    EnumValue: function EnumValue(node) {\n      var type = (0, _definition.getNamedType)(context.getInputType());\n      var enumValue = context.getEnumValue();\n\n      if (type && (enumValue === null || enumValue === void 0 ? void 0 : enumValue.deprecationReason) != null) {\n        context.reportError(new _GraphQLError.GraphQLError(\"The enum value \\\"\".concat(type.name, \".\").concat(enumValue.name, \"\\\" is deprecated. \") + enumValue.deprecationReason, node));\n      }\n    }\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,sBAAsB,GAAG;AAEjC,IAAI;AAEJ,IAAI;AAEJ;;;;;;;;;CASC,GACD,SAAS,uBAAuB,OAAO;IACrC,OAAO;QACL,OAAO,SAAS,MAAM,IAAI;YACxB,IAAI,WAAW,QAAQ,WAAW;YAClC,IAAI,aAAa,QAAQ,aAAa;YAEtC,IAAI,cAAc,CAAC,aAAa,QAAQ,aAAa,KAAK,IAAI,KAAK,IAAI,SAAS,iBAAiB,KAAK,MAAM;gBAC1G,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,aAAa,MAAM,CAAC,WAAW,IAAI,EAAE,KAAK,MAAM,CAAC,SAAS,IAAI,EAAE,sBAAsB,SAAS,iBAAiB,EAAE;YACvK;QACF;QACA,WAAW,SAAS,UAAU,IAAI;YAChC,IAAI,OAAO,CAAC,GAAG,YAAY,YAAY,EAAE,QAAQ,YAAY;YAC7D,IAAI,YAAY,QAAQ,YAAY;YAEpC,IAAI,QAAQ,CAAC,cAAc,QAAQ,cAAc,KAAK,IAAI,KAAK,IAAI,UAAU,iBAAiB,KAAK,MAAM;gBACvG,QAAQ,WAAW,CAAC,IAAI,cAAc,YAAY,CAAC,oBAAoB,MAAM,CAAC,KAAK,IAAI,EAAE,KAAK,MAAM,CAAC,UAAU,IAAI,EAAE,wBAAwB,UAAU,iBAAiB,EAAE;YAC5K;QACF;IACF;AACF","ignoreList":[0],"debugId":null}}]
}