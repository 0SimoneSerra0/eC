{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/assertValidName.mjs"],"sourcesContent":["import devAssert from \"../jsutils/devAssert.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nvar NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/**\n * Upholds the spec rules about naming.\n */\n\nexport function assertValidName(name) {\n  var error = isValidNameError(name);\n\n  if (error) {\n    throw error;\n  }\n\n  return name;\n}\n/**\n * Returns an Error if a name is invalid.\n */\n\nexport function isValidNameError(name) {\n  typeof name === 'string' || devAssert(0, 'Expected name to be a string.');\n\n  if (name.length > 1 && name[0] === '_' && name[1] === '_') {\n    return new GraphQLError(\"Name \\\"\".concat(name, \"\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\"));\n  }\n\n  if (!NAME_RX.test(name)) {\n    return new GraphQLError(\"Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but \\\"\".concat(name, \"\\\" does not.\"));\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACA,IAAI,UAAU;AAKP,SAAS,gBAAgB,IAAI;IAClC,IAAI,QAAQ,iBAAiB;IAE7B,IAAI,OAAO;QACT,MAAM;IACR;IAEA,OAAO;AACT;AAKO,SAAS,iBAAiB,IAAI;IACnC,OAAO,SAAS,YAAY,CAAA,GAAA,kJAAA,CAAA,UAAS,AAAD,EAAE,GAAG;IAEzC,IAAI,KAAK,MAAM,GAAG,KAAK,IAAI,CAAC,EAAE,KAAK,OAAO,IAAI,CAAC,EAAE,KAAK,KAAK;QACzD,OAAO,IAAI,mJAAA,CAAA,eAAY,CAAC,UAAU,MAAM,CAAC,MAAM;IACjD;IAEA,IAAI,CAAC,QAAQ,IAAI,CAAC,OAAO;QACvB,OAAO,IAAI,mJAAA,CAAA,eAAY,CAAC,qDAAqD,MAAM,CAAC,MAAM;IAC5F;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/valueFromASTUntyped.mjs"],"sourcesContent":["import inspect from \"../jsutils/inspect.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport keyValMap from \"../jsutils/keyValMap.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * Unlike `valueFromAST()`, no type is provided. The resulting JavaScript value\n * will reflect the provided GraphQL value AST.\n *\n * | GraphQL Value        | JavaScript Value |\n * | -------------------- | ---------------- |\n * | Input Object         | Object           |\n * | List                 | Array            |\n * | Boolean              | Boolean          |\n * | String / Enum        | String           |\n * | Int / Float          | Number           |\n * | Null                 | null             |\n *\n */\nexport function valueFromASTUntyped(valueNode, variables) {\n  switch (valueNode.kind) {\n    case Kind.NULL:\n      return null;\n\n    case Kind.INT:\n      return parseInt(valueNode.value, 10);\n\n    case Kind.FLOAT:\n      return parseFloat(valueNode.value);\n\n    case Kind.STRING:\n    case Kind.ENUM:\n    case Kind.BOOLEAN:\n      return valueNode.value;\n\n    case Kind.LIST:\n      return valueNode.values.map(function (node) {\n        return valueFromASTUntyped(node, variables);\n      });\n\n    case Kind.OBJECT:\n      return keyValMap(valueNode.fields, function (field) {\n        return field.name.value;\n      }, function (field) {\n        return valueFromASTUntyped(field.value, variables);\n      });\n\n    case Kind.VARIABLE:\n      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];\n  } // istanbul ignore next (Not reachable. All possible value nodes have been considered)\n\n\n  false || invariant(0, 'Unexpected value node: ' + inspect(valueNode));\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AAkBO,SAAS,oBAAoB,SAAS,EAAE,SAAS;IACtD,OAAQ,UAAU,IAAI;QACpB,KAAK,+IAAA,CAAA,OAAI,CAAC,IAAI;YACZ,OAAO;QAET,KAAK,+IAAA,CAAA,OAAI,CAAC,GAAG;YACX,OAAO,SAAS,UAAU,KAAK,EAAE;QAEnC,KAAK,+IAAA,CAAA,OAAI,CAAC,KAAK;YACb,OAAO,WAAW,UAAU,KAAK;QAEnC,KAAK,+IAAA,CAAA,OAAI,CAAC,MAAM;QAChB,KAAK,+IAAA,CAAA,OAAI,CAAC,IAAI;QACd,KAAK,+IAAA,CAAA,OAAI,CAAC,OAAO;YACf,OAAO,UAAU,KAAK;QAExB,KAAK,+IAAA,CAAA,OAAI,CAAC,IAAI;YACZ,OAAO,UAAU,MAAM,CAAC,GAAG,CAAC,SAAU,IAAI;gBACxC,OAAO,oBAAoB,MAAM;YACnC;QAEF,KAAK,+IAAA,CAAA,OAAI,CAAC,MAAM;YACd,OAAO,CAAA,GAAA,kJAAA,CAAA,UAAS,AAAD,EAAE,UAAU,MAAM,EAAE,SAAU,KAAK;gBAChD,OAAO,MAAM,IAAI,CAAC,KAAK;YACzB,GAAG,SAAU,KAAK;gBAChB,OAAO,oBAAoB,MAAM,KAAK,EAAE;YAC1C;QAEF,KAAK,+IAAA,CAAA,OAAI,CAAC,QAAQ;YAChB,OAAO,cAAc,QAAQ,cAAc,KAAK,IAAI,KAAK,IAAI,SAAS,CAAC,UAAU,IAAI,CAAC,KAAK,CAAC;IAChG,EAAE,sFAAsF;IAGxF,SAAS,CAAA,GAAA,kJAAA,CAAA,UAAS,AAAD,EAAE,GAAG,4BAA4B,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;AAC5D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/typeComparators.mjs"],"sourcesContent":["import { isInterfaceType, isObjectType, isListType, isNonNullType, isAbstractType } from \"../type/definition.mjs\";\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\n\nexport function isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  } // If either type is non-null, the other must also be non-null.\n\n\n  if (isNonNullType(typeA) && isNonNullType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // If either type is a list, the other must also be a list.\n\n\n  if (isListType(typeA) && isListType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // Otherwise the types are not equal.\n\n\n  return false;\n}\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\nexport function isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  } // If superType is non-null, maybeSubType must also be non-null.\n\n\n  if (isNonNullType(superType)) {\n    if (isNonNullType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if (isNonNullType(maybeSubType)) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  } // If superType type is a list, maybeSubType type must also be a list.\n\n\n  if (isListType(superType)) {\n    if (isListType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if (isListType(maybeSubType)) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  } // If superType type is an abstract type, check if it is super type of maybeSubType.\n  // Otherwise, the child type is not a valid subtype of the parent type.\n\n\n  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);\n}\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\n\nexport function doTypesOverlap(schema, typeA, typeB) {\n  // Equivalent types overlap\n  if (typeA === typeB) {\n    return true;\n  }\n\n  if (isAbstractType(typeA)) {\n    if (isAbstractType(typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema.getPossibleTypes(typeA).some(function (type) {\n        return schema.isSubType(typeB, type);\n      });\n    } // Determine if the latter type is a possible concrete type of the former.\n\n\n    return schema.isSubType(typeA, typeB);\n  }\n\n  if (isAbstractType(typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isSubType(typeB, typeA);\n  } // Otherwise the types do not overlap.\n\n\n  return false;\n}\n"],"names":[],"mappings":";;;;;AAAA;;AAKO,SAAS,YAAY,KAAK,EAAE,KAAK;IACtC,8BAA8B;IAC9B,IAAI,UAAU,OAAO;QACnB,OAAO;IACT,EAAE,+DAA+D;IAGjE,IAAI,CAAA,GAAA,gJAAA,CAAA,gBAAa,AAAD,EAAE,UAAU,CAAA,GAAA,gJAAA,CAAA,gBAAa,AAAD,EAAE,QAAQ;QAChD,OAAO,YAAY,MAAM,MAAM,EAAE,MAAM,MAAM;IAC/C,EAAE,2DAA2D;IAG7D,IAAI,CAAA,GAAA,gJAAA,CAAA,aAAU,AAAD,EAAE,UAAU,CAAA,GAAA,gJAAA,CAAA,aAAU,AAAD,EAAE,QAAQ;QAC1C,OAAO,YAAY,MAAM,MAAM,EAAE,MAAM,MAAM;IAC/C,EAAE,qCAAqC;IAGvC,OAAO;AACT;AAMO,SAAS,gBAAgB,MAAM,EAAE,YAAY,EAAE,SAAS;IAC7D,qCAAqC;IACrC,IAAI,iBAAiB,WAAW;QAC9B,OAAO;IACT,EAAE,gEAAgE;IAGlE,IAAI,CAAA,GAAA,gJAAA,CAAA,gBAAa,AAAD,EAAE,YAAY;QAC5B,IAAI,CAAA,GAAA,gJAAA,CAAA,gBAAa,AAAD,EAAE,eAAe;YAC/B,OAAO,gBAAgB,QAAQ,aAAa,MAAM,EAAE,UAAU,MAAM;QACtE;QAEA,OAAO;IACT;IAEA,IAAI,CAAA,GAAA,gJAAA,CAAA,gBAAa,AAAD,EAAE,eAAe;QAC/B,sEAAsE;QACtE,OAAO,gBAAgB,QAAQ,aAAa,MAAM,EAAE;IACtD,EAAE,sEAAsE;IAGxE,IAAI,CAAA,GAAA,gJAAA,CAAA,aAAU,AAAD,EAAE,YAAY;QACzB,IAAI,CAAA,GAAA,gJAAA,CAAA,aAAU,AAAD,EAAE,eAAe;YAC5B,OAAO,gBAAgB,QAAQ,aAAa,MAAM,EAAE,UAAU,MAAM;QACtE;QAEA,OAAO;IACT;IAEA,IAAI,CAAA,GAAA,gJAAA,CAAA,aAAU,AAAD,EAAE,eAAe;QAC5B,oEAAoE;QACpE,OAAO;IACT,EAAE,oFAAoF;IACtF,uEAAuE;IAGvE,OAAO,CAAA,GAAA,gJAAA,CAAA,iBAAc,AAAD,EAAE,cAAc,CAAC,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD,EAAE,iBAAiB,CAAA,GAAA,gJAAA,CAAA,eAAY,AAAD,EAAE,aAAa,KAAK,OAAO,SAAS,CAAC,WAAW;AACnI;AAWO,SAAS,eAAe,MAAM,EAAE,KAAK,EAAE,KAAK;IACjD,2BAA2B;IAC3B,IAAI,UAAU,OAAO;QACnB,OAAO;IACT;IAEA,IAAI,CAAA,GAAA,gJAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ;QACzB,IAAI,CAAA,GAAA,gJAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ;YACzB,0EAA0E;YAC1E,2CAA2C;YAC3C,OAAO,OAAO,gBAAgB,CAAC,OAAO,IAAI,CAAC,SAAU,IAAI;gBACvD,OAAO,OAAO,SAAS,CAAC,OAAO;YACjC;QACF,EAAE,0EAA0E;QAG5E,OAAO,OAAO,SAAS,CAAC,OAAO;IACjC;IAEA,IAAI,CAAA,GAAA,gJAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ;QACzB,0EAA0E;QAC1E,OAAO,OAAO,SAAS,CAAC,OAAO;IACjC,EAAE,sCAAsC;IAGxC,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 149, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/astFromValue.mjs"],"sourcesContent":["import isFinite from \"../polyfills/isFinite.mjs\";\nimport arrayFrom from \"../polyfills/arrayFrom.mjs\";\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport isCollection from \"../jsutils/isCollection.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { GraphQLID } from \"../type/scalars.mjs\";\nimport { isLeafType, isEnumType, isInputObjectType, isListType, isNonNullType } from \"../type/definition.mjs\";\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using suggested GraphQLInputType. For example:\n *\n *     astFromValue(\"value\", GraphQLString)\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * JavaScript values.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String / Enum Value  |\n * | Number        | Int / Float          |\n * | Mixed         | Enum Value           |\n * | null          | NullValue            |\n *\n */\n\nexport function astFromValue(value, type) {\n  if (isNonNullType(type)) {\n    var astValue = astFromValue(value, type.ofType);\n\n    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {\n      return null;\n    }\n\n    return astValue;\n  } // only explicit null, not undefined, NaN\n\n\n  if (value === null) {\n    return {\n      kind: Kind.NULL\n    };\n  } // undefined\n\n\n  if (value === undefined) {\n    return null;\n  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n  // the value is not an array, convert the value using the list's item type.\n\n\n  if (isListType(type)) {\n    var itemType = type.ofType;\n\n    if (isCollection(value)) {\n      var valuesNodes = []; // Since we transpile for-of in loose mode it doesn't support iterators\n      // and it's required to first convert iteratable into array\n\n      for (var _i2 = 0, _arrayFrom2 = arrayFrom(value); _i2 < _arrayFrom2.length; _i2++) {\n        var item = _arrayFrom2[_i2];\n        var itemNode = astFromValue(item, itemType);\n\n        if (itemNode != null) {\n          valuesNodes.push(itemNode);\n        }\n      }\n\n      return {\n        kind: Kind.LIST,\n        values: valuesNodes\n      };\n    }\n\n    return astFromValue(value, itemType);\n  } // Populate the fields of the input object by creating ASTs from each value\n  // in the JavaScript object according to the fields in the input type.\n\n\n  if (isInputObjectType(type)) {\n    if (!isObjectLike(value)) {\n      return null;\n    }\n\n    var fieldNodes = [];\n\n    for (var _i4 = 0, _objectValues2 = objectValues(type.getFields()); _i4 < _objectValues2.length; _i4++) {\n      var field = _objectValues2[_i4];\n      var fieldValue = astFromValue(value[field.name], field.type);\n\n      if (fieldValue) {\n        fieldNodes.push({\n          kind: Kind.OBJECT_FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: field.name\n          },\n          value: fieldValue\n        });\n      }\n    }\n\n    return {\n      kind: Kind.OBJECT,\n      fields: fieldNodes\n    };\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isLeafType(type)) {\n    // Since value is an internally represented value, it must be serialized\n    // to an externally represented value before converting into an AST.\n    var serialized = type.serialize(value);\n\n    if (serialized == null) {\n      return null;\n    } // Others serialize based on their corresponding JavaScript scalar types.\n\n\n    if (typeof serialized === 'boolean') {\n      return {\n        kind: Kind.BOOLEAN,\n        value: serialized\n      };\n    } // JavaScript numbers can be Int or Float values.\n\n\n    if (typeof serialized === 'number' && isFinite(serialized)) {\n      var stringNum = String(serialized);\n      return integerStringRegExp.test(stringNum) ? {\n        kind: Kind.INT,\n        value: stringNum\n      } : {\n        kind: Kind.FLOAT,\n        value: stringNum\n      };\n    }\n\n    if (typeof serialized === 'string') {\n      // Enum types use Enum literals.\n      if (isEnumType(type)) {\n        return {\n          kind: Kind.ENUM,\n          value: serialized\n        };\n      } // ID types can use Int literals.\n\n\n      if (type === GraphQLID && integerStringRegExp.test(serialized)) {\n        return {\n          kind: Kind.INT,\n          value: serialized\n        };\n      }\n\n      return {\n        kind: Kind.STRING,\n        value: serialized\n      };\n    }\n\n    throw new TypeError(\"Cannot convert value to AST: \".concat(inspect(serialized), \".\"));\n  } // istanbul ignore next (Not reachable. All possible input types have been considered)\n\n\n  false || invariant(0, 'Unexpected input type: ' + inspect(type));\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\n\nvar integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 288, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/typeFromAST.mjs"],"sourcesContent":["import inspect from \"../jsutils/inspect.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { GraphQLList, GraphQLNonNull } from \"../type/definition.mjs\";\n/**\n * Given a Schema and an AST node describing a type, return a GraphQLType\n * definition which applies to that type. For example, if provided the parsed\n * AST node for `[User]`, a GraphQLList instance will be returned, containing\n * the type called \"User\" found in the schema. If a type called \"User\" is not\n * found in the schema, then undefined will be returned.\n */\n\n/* eslint-disable no-redeclare */\n\nexport function typeFromAST(schema, typeNode) {\n  /* eslint-enable no-redeclare */\n  var innerType;\n\n  if (typeNode.kind === Kind.LIST_TYPE) {\n    innerType = typeFromAST(schema, typeNode.type);\n    return innerType && GraphQLList(innerType);\n  }\n\n  if (typeNode.kind === Kind.NON_NULL_TYPE) {\n    innerType = typeFromAST(schema, typeNode.type);\n    return innerType && GraphQLNonNull(innerType);\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (typeNode.kind === Kind.NAMED_TYPE) {\n    return schema.getType(typeNode.name.value);\n  } // istanbul ignore next (Not reachable. All possible type nodes have been considered)\n\n\n  false || invariant(0, 'Unexpected type node: ' + inspect(typeNode));\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AAWO,SAAS,YAAY,MAAM,EAAE,QAAQ;IAC1C,8BAA8B,GAC9B,IAAI;IAEJ,IAAI,SAAS,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,SAAS,EAAE;QACpC,YAAY,YAAY,QAAQ,SAAS,IAAI;QAC7C,OAAO,aAAa,CAAA,GAAA,gJAAA,CAAA,cAAW,AAAD,EAAE;IAClC;IAEA,IAAI,SAAS,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,aAAa,EAAE;QACxC,YAAY,YAAY,QAAQ,SAAS,IAAI;QAC7C,OAAO,aAAa,CAAA,GAAA,gJAAA,CAAA,iBAAc,AAAD,EAAE;IACrC,EAAE,kFAAkF;IAGpF,IAAI,SAAS,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,UAAU,EAAE;QACrC,OAAO,OAAO,OAAO,CAAC,SAAS,IAAI,CAAC,KAAK;IAC3C,EAAE,qFAAqF;IAGvF,SAAS,CAAA,GAAA,kJAAA,CAAA,UAAS,AAAD,EAAE,GAAG,2BAA2B,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;AAC3D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 318, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/TypeInfo.mjs"],"sourcesContent":["import find from \"../polyfills/find.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { isNode } from \"../language/ast.mjs\";\nimport { getVisitFn } from \"../language/visitor.mjs\";\nimport { isObjectType, isInterfaceType, isEnumType, isInputObjectType, isListType, isCompositeType, isInputType, isOutputType, getNullableType, getNamedType } from \"../type/definition.mjs\";\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from \"../type/introspection.mjs\";\nimport { typeFromAST } from \"./typeFromAST.mjs\";\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\nexport var TypeInfo = /*#__PURE__*/function () {\n  function TypeInfo(schema, // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant code bases. You should never need to use it.\n  // It may disappear in the future.\n  getFieldDefFn, // Initial type may be provided in rare cases to facilitate traversals\n  // beginning somewhere other than documents.\n  initialType) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;\n\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  var _proto = TypeInfo.prototype;\n\n  _proto.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  _proto.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  _proto.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  _proto.getParentInputType = function getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  };\n\n  _proto.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  _proto.getDefaultValue = function getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  };\n\n  _proto.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  _proto.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  _proto.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  };\n\n  _proto.enter = function enter(node) {\n    var schema = this._schema; // Note: many of the types below are explicitly typed as \"mixed\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        {\n          var namedType = getNamedType(this.getType());\n\n          this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);\n\n          break;\n        }\n\n      case Kind.FIELD:\n        {\n          var parentType = this.getParentType();\n          var fieldDef;\n          var fieldType;\n\n          if (parentType) {\n            fieldDef = this._getFieldDef(schema, parentType, node);\n\n            if (fieldDef) {\n              fieldType = fieldDef.type;\n            }\n          }\n\n          this._fieldDefStack.push(fieldDef);\n\n          this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n\n          break;\n        }\n\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n        {\n          var type;\n\n          switch (node.operation) {\n            case 'query':\n              type = schema.getQueryType();\n              break;\n\n            case 'mutation':\n              type = schema.getMutationType();\n              break;\n\n            case 'subscription':\n              type = schema.getSubscriptionType();\n              break;\n          }\n\n          this._typeStack.push(isObjectType(type) ? type : undefined);\n\n          break;\n        }\n\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        {\n          var typeConditionAST = node.typeCondition;\n          var outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n\n          this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n\n          break;\n        }\n\n      case Kind.VARIABLE_DEFINITION:\n        {\n          var inputType = typeFromAST(schema, node.type);\n\n          this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);\n\n          break;\n        }\n\n      case Kind.ARGUMENT:\n        {\n          var _this$getDirective;\n\n          var argDef;\n          var argType;\n          var fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();\n\n          if (fieldOrDirective) {\n            argDef = find(fieldOrDirective.args, function (arg) {\n              return arg.name === node.name.value;\n            });\n\n            if (argDef) {\n              argType = argDef.type;\n            }\n          }\n\n          this._argument = argDef;\n\n          this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n          this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n\n          break;\n        }\n\n      case Kind.LIST:\n        {\n          var listType = getNullableType(this.getInputType());\n          var itemType = isListType(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n          this._defaultValueStack.push(undefined);\n\n          this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n\n          break;\n        }\n\n      case Kind.OBJECT_FIELD:\n        {\n          var objectType = getNamedType(this.getInputType());\n          var inputFieldType;\n          var inputField;\n\n          if (isInputObjectType(objectType)) {\n            inputField = objectType.getFields()[node.name.value];\n\n            if (inputField) {\n              inputFieldType = inputField.type;\n            }\n          }\n\n          this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n\n          this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);\n\n          break;\n        }\n\n      case Kind.ENUM:\n        {\n          var enumType = getNamedType(this.getInputType());\n          var enumValue;\n\n          if (isEnumType(enumType)) {\n            enumValue = enumType.getValue(node.value);\n          }\n\n          this._enumValue = enumValue;\n          break;\n        }\n    }\n  };\n\n  _proto.leave = function leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n\n  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 605, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/getOperationRootType.mjs"],"sourcesContent":["import { GraphQLError } from \"../error/GraphQLError.mjs\";\n\n/**\n * Extracts the root type of the operation from the schema.\n */\nexport function getOperationRootType(schema, operation) {\n  if (operation.operation === 'query') {\n    var queryType = schema.getQueryType();\n\n    if (!queryType) {\n      throw new GraphQLError('Schema does not define the required query root type.', operation);\n    }\n\n    return queryType;\n  }\n\n  if (operation.operation === 'mutation') {\n    var mutationType = schema.getMutationType();\n\n    if (!mutationType) {\n      throw new GraphQLError('Schema is not configured for mutations.', operation);\n    }\n\n    return mutationType;\n  }\n\n  if (operation.operation === 'subscription') {\n    var subscriptionType = schema.getSubscriptionType();\n\n    if (!subscriptionType) {\n      throw new GraphQLError('Schema is not configured for subscriptions.', operation);\n    }\n\n    return subscriptionType;\n  }\n\n  throw new GraphQLError('Can only have query, mutation and subscription operations.', operation);\n}\n"],"names":[],"mappings":";;;AAAA;;AAKO,SAAS,qBAAqB,MAAM,EAAE,SAAS;IACpD,IAAI,UAAU,SAAS,KAAK,SAAS;QACnC,IAAI,YAAY,OAAO,YAAY;QAEnC,IAAI,CAAC,WAAW;YACd,MAAM,IAAI,mJAAA,CAAA,eAAY,CAAC,wDAAwD;QACjF;QAEA,OAAO;IACT;IAEA,IAAI,UAAU,SAAS,KAAK,YAAY;QACtC,IAAI,eAAe,OAAO,eAAe;QAEzC,IAAI,CAAC,cAAc;YACjB,MAAM,IAAI,mJAAA,CAAA,eAAY,CAAC,2CAA2C;QACpE;QAEA,OAAO;IACT;IAEA,IAAI,UAAU,SAAS,KAAK,gBAAgB;QAC1C,IAAI,mBAAmB,OAAO,mBAAmB;QAEjD,IAAI,CAAC,kBAAkB;YACrB,MAAM,IAAI,mJAAA,CAAA,eAAY,CAAC,+CAA+C;QACxE;QAEA,OAAO;IACT;IAEA,MAAM,IAAI,mJAAA,CAAA,eAAY,CAAC,8DAA8D;AACvF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 638, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/valueFromAST.mjs"],"sourcesContent":["import objectValues from \"../polyfills/objectValues.mjs\";\nimport keyMap from \"../jsutils/keyMap.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { isLeafType, isInputObjectType, isListType, isNonNullType } from \"../type/definition.mjs\";\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Mixed         |\n * | NullValue            | null          |\n *\n */\n\nexport function valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n\n  if (valueNode.kind === Kind.VARIABLE) {\n    var variableName = valueNode.name.value;\n\n    if (variables == null || variables[variableName] === undefined) {\n      // No valid return value.\n      return;\n    }\n\n    var variableValue = variables[variableName];\n\n    if (variableValue === null && isNonNullType(type)) {\n      return; // Invalid: intentionally return no value.\n    } // Note: This does no further checking that this variable is correct.\n    // This assumes that this query has been validated and the variable\n    // usage here is of the correct type.\n\n\n    return variableValue;\n  }\n\n  if (isNonNullType(type)) {\n    if (valueNode.kind === Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n\n  if (valueNode.kind === Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n\n  if (isListType(type)) {\n    var itemType = type.ofType;\n\n    if (valueNode.kind === Kind.LIST) {\n      var coercedValues = [];\n\n      for (var _i2 = 0, _valueNode$values2 = valueNode.values; _i2 < _valueNode$values2.length; _i2++) {\n        var itemNode = _valueNode$values2[_i2];\n\n        if (isMissingVariable(itemNode, variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if (isNonNullType(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(null);\n        } else {\n          var itemValue = valueFromAST(itemNode, itemType, variables);\n\n          if (itemValue === undefined) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(itemValue);\n        }\n      }\n\n      return coercedValues;\n    }\n\n    var coercedValue = valueFromAST(valueNode, itemType, variables);\n\n    if (coercedValue === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return [coercedValue];\n  }\n\n  if (isInputObjectType(type)) {\n    if (valueNode.kind !== Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    var coercedObj = Object.create(null);\n    var fieldNodes = keyMap(valueNode.fields, function (field) {\n      return field.name.value;\n    });\n\n    for (var _i4 = 0, _objectValues2 = objectValues(type.getFields()); _i4 < _objectValues2.length; _i4++) {\n      var field = _objectValues2[_i4];\n      var fieldNode = fieldNodes[field.name];\n\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== undefined) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n\n        continue;\n      }\n\n      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n\n      if (fieldValue === undefined) {\n        return; // Invalid: intentionally return no value.\n      }\n\n      coercedObj[field.name] = fieldValue;\n    }\n\n    return coercedObj;\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isLeafType(type)) {\n    // Scalars and Enums fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    var result;\n\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    if (result === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return result;\n  } // istanbul ignore next (Not reachable. All possible input types have been considered)\n\n\n  false || invariant(0, 'Unexpected input type: ' + inspect(type));\n} // Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\n\nfunction isMissingVariable(valueNode, variables) {\n  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 766, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/coerceInputValue.mjs"],"sourcesContent":["import arrayFrom from \"../polyfills/arrayFrom.mjs\";\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport didYouMean from \"../jsutils/didYouMean.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport isCollection from \"../jsutils/isCollection.mjs\";\nimport suggestionList from \"../jsutils/suggestionList.mjs\";\nimport printPathArray from \"../jsutils/printPathArray.mjs\";\nimport { addPath, pathToArray } from \"../jsutils/Path.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { isLeafType, isInputObjectType, isListType, isNonNullType } from \"../type/definition.mjs\";\n\n/**\n * Coerces a JavaScript value given a GraphQL Input Type.\n */\nexport function coerceInputValue(inputValue, type) {\n  var onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOnError;\n  return coerceInputValueImpl(inputValue, type, onError);\n}\n\nfunction defaultOnError(path, invalidValue, error) {\n  var errorPrefix = 'Invalid value ' + inspect(invalidValue);\n\n  if (path.length > 0) {\n    errorPrefix += \" at \\\"value\".concat(printPathArray(path), \"\\\"\");\n  }\n\n  error.message = errorPrefix + ': ' + error.message;\n  throw error;\n}\n\nfunction coerceInputValueImpl(inputValue, type, onError, path) {\n  if (isNonNullType(type)) {\n    if (inputValue != null) {\n      return coerceInputValueImpl(inputValue, type.ofType, onError, path);\n    }\n\n    onError(pathToArray(path), inputValue, new GraphQLError(\"Expected non-nullable type \\\"\".concat(inspect(type), \"\\\" not to be null.\")));\n    return;\n  }\n\n  if (inputValue == null) {\n    // Explicitly return the value null.\n    return null;\n  }\n\n  if (isListType(type)) {\n    var itemType = type.ofType;\n\n    if (isCollection(inputValue)) {\n      return arrayFrom(inputValue, function (itemValue, index) {\n        var itemPath = addPath(path, index, undefined);\n        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);\n      });\n    } // Lists accept a non-list value as a list of one.\n\n\n    return [coerceInputValueImpl(inputValue, itemType, onError, path)];\n  }\n\n  if (isInputObjectType(type)) {\n    if (!isObjectLike(inputValue)) {\n      onError(pathToArray(path), inputValue, new GraphQLError(\"Expected type \\\"\".concat(type.name, \"\\\" to be an object.\")));\n      return;\n    }\n\n    var coercedValue = {};\n    var fieldDefs = type.getFields();\n\n    for (var _i2 = 0, _objectValues2 = objectValues(fieldDefs); _i2 < _objectValues2.length; _i2++) {\n      var field = _objectValues2[_i2];\n      var fieldValue = inputValue[field.name];\n\n      if (fieldValue === undefined) {\n        if (field.defaultValue !== undefined) {\n          coercedValue[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          var typeStr = inspect(field.type);\n          onError(pathToArray(path), inputValue, new GraphQLError(\"Field \\\"\".concat(field.name, \"\\\" of required type \\\"\").concat(typeStr, \"\\\" was not provided.\")));\n        }\n\n        continue;\n      }\n\n      coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, addPath(path, field.name, type.name));\n    } // Ensure every provided field is defined.\n\n\n    for (var _i4 = 0, _Object$keys2 = Object.keys(inputValue); _i4 < _Object$keys2.length; _i4++) {\n      var fieldName = _Object$keys2[_i4];\n\n      if (!fieldDefs[fieldName]) {\n        var suggestions = suggestionList(fieldName, Object.keys(type.getFields()));\n        onError(pathToArray(path), inputValue, new GraphQLError(\"Field \\\"\".concat(fieldName, \"\\\" is not defined by type \\\"\").concat(type.name, \"\\\".\") + didYouMean(suggestions)));\n      }\n    }\n\n    return coercedValue;\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isLeafType(type)) {\n    var parseResult; // Scalars and Enums determine if a input value is valid via parseValue(),\n    // which can throw to indicate failure. If it throws, maintain a reference\n    // to the original error.\n\n    try {\n      parseResult = type.parseValue(inputValue);\n    } catch (error) {\n      if (error instanceof GraphQLError) {\n        onError(pathToArray(path), inputValue, error);\n      } else {\n        onError(pathToArray(path), inputValue, new GraphQLError(\"Expected type \\\"\".concat(type.name, \"\\\". \") + error.message, undefined, undefined, undefined, undefined, error));\n      }\n\n      return;\n    }\n\n    if (parseResult === undefined) {\n      onError(pathToArray(path), inputValue, new GraphQLError(\"Expected type \\\"\".concat(type.name, \"\\\".\")));\n    }\n\n    return parseResult;\n  } // istanbul ignore next (Not reachable. All possible input types have been considered)\n\n\n  false || invariant(0, 'Unexpected input type: ' + inspect(type));\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 884, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/getIntrospectionQuery.mjs"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexport function getIntrospectionQuery(options) {\n  var optionsWithDefault = _objectSpread({\n    descriptions: true,\n    specifiedByUrl: false,\n    directiveIsRepeatable: false,\n    schemaDescription: false\n  }, options);\n\n  var descriptions = optionsWithDefault.descriptions ? 'description' : '';\n  var specifiedByUrl = optionsWithDefault.specifiedByUrl ? 'specifiedByUrl' : '';\n  var directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? 'isRepeatable' : '';\n  var schemaDescription = optionsWithDefault.schemaDescription ? descriptions : '';\n  return \"\\n    query IntrospectionQuery {\\n      __schema {\\n        \".concat(schemaDescription, \"\\n        queryType { name }\\n        mutationType { name }\\n        subscriptionType { name }\\n        types {\\n          ...FullType\\n        }\\n        directives {\\n          name\\n          \").concat(descriptions, \"\\n          \").concat(directiveIsRepeatable, \"\\n          locations\\n          args {\\n            ...InputValue\\n          }\\n        }\\n      }\\n    }\\n\\n    fragment FullType on __Type {\\n      kind\\n      name\\n      \").concat(descriptions, \"\\n      \").concat(specifiedByUrl, \"\\n      fields(includeDeprecated: true) {\\n        name\\n        \").concat(descriptions, \"\\n        args {\\n          ...InputValue\\n        }\\n        type {\\n          ...TypeRef\\n        }\\n        isDeprecated\\n        deprecationReason\\n      }\\n      inputFields {\\n        ...InputValue\\n      }\\n      interfaces {\\n        ...TypeRef\\n      }\\n      enumValues(includeDeprecated: true) {\\n        name\\n        \").concat(descriptions, \"\\n        isDeprecated\\n        deprecationReason\\n      }\\n      possibleTypes {\\n        ...TypeRef\\n      }\\n    }\\n\\n    fragment InputValue on __InputValue {\\n      name\\n      \").concat(descriptions, \"\\n      type { ...TypeRef }\\n      defaultValue\\n    }\\n\\n    fragment TypeRef on __Type {\\n      kind\\n      name\\n      ofType {\\n        kind\\n        name\\n        ofType {\\n          kind\\n          name\\n          ofType {\\n            kind\\n            name\\n            ofType {\\n              kind\\n              name\\n              ofType {\\n                kind\\n                name\\n                ofType {\\n                  kind\\n                  name\\n                  ofType {\\n                    kind\\n                    name\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  \");\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,QAAQ,MAAM,EAAE,cAAc;IAAI,IAAI,OAAO,OAAO,IAAI,CAAC;IAAS,IAAI,OAAO,qBAAqB,EAAE;QAAE,IAAI,UAAU,OAAO,qBAAqB,CAAC;QAAS,IAAI,gBAAgB,UAAU,QAAQ,MAAM,CAAC,SAAU,GAAG;YAAI,OAAO,OAAO,wBAAwB,CAAC,QAAQ,KAAK,UAAU;QAAE;QAAI,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM;IAAU;IAAE,OAAO;AAAM;AAEpV,SAAS,cAAc,MAAM;IAAI,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;QAAE,IAAI,SAAS,SAAS,CAAC,EAAE,IAAI,OAAO,SAAS,CAAC,EAAE,GAAG,CAAC;QAAG,IAAI,IAAI,GAAG;YAAE,QAAQ,OAAO,SAAS,MAAM,OAAO,CAAC,SAAU,GAAG;gBAAI,gBAAgB,QAAQ,KAAK,MAAM,CAAC,IAAI;YAAG;QAAI,OAAO,IAAI,OAAO,yBAAyB,EAAE;YAAE,OAAO,gBAAgB,CAAC,QAAQ,OAAO,yBAAyB,CAAC;QAAU,OAAO;YAAE,QAAQ,OAAO,SAAS,OAAO,CAAC,SAAU,GAAG;gBAAI,OAAO,cAAc,CAAC,QAAQ,KAAK,OAAO,wBAAwB,CAAC,QAAQ;YAAO;QAAI;IAAE;IAAE,OAAO;AAAQ;AAErhB,SAAS,gBAAgB,GAAG,EAAE,GAAG,EAAE,KAAK;IAAI,IAAI,OAAO,KAAK;QAAE,OAAO,cAAc,CAAC,KAAK,KAAK;YAAE,OAAO;YAAO,YAAY;YAAM,cAAc;YAAM,UAAU;QAAK;IAAI,OAAO;QAAE,GAAG,CAAC,IAAI,GAAG;IAAO;IAAE,OAAO;AAAK;AAEzM,SAAS,sBAAsB,OAAO;IAC3C,IAAI,qBAAqB,cAAc;QACrC,cAAc;QACd,gBAAgB;QAChB,uBAAuB;QACvB,mBAAmB;IACrB,GAAG;IAEH,IAAI,eAAe,mBAAmB,YAAY,GAAG,gBAAgB;IACrE,IAAI,iBAAiB,mBAAmB,cAAc,GAAG,mBAAmB;IAC5E,IAAI,wBAAwB,mBAAmB,qBAAqB,GAAG,iBAAiB;IACxF,IAAI,oBAAoB,mBAAmB,iBAAiB,GAAG,eAAe;IAC9E,OAAO,+DAA+D,MAAM,CAAC,mBAAmB,uMAAuM,MAAM,CAAC,cAAc,gBAAgB,MAAM,CAAC,uBAAuB,mLAAmL,MAAM,CAAC,cAAc,YAAY,MAAM,CAAC,gBAAgB,qEAAqE,MAAM,CAAC,cAAc,8UAA8U,MAAM,CAAC,cAAc,0LAA0L,MAAM,CAAC,cAAc;AACnuC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 945, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/getOperationAST.mjs"],"sourcesContent":["import { Kind } from \"../language/kinds.mjs\";\n/**\n * Returns an operation AST given a document AST and optionally an operation\n * name. If a name is not provided, an operation is only returned if only one is\n * provided in the document.\n */\n\nexport function getOperationAST(documentAST, operationName) {\n  var operation = null;\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var definition = _documentAST$definiti2[_i2];\n\n    if (definition.kind === Kind.OPERATION_DEFINITION) {\n      var _definition$name;\n\n      if (operationName == null) {\n        // If no operation name was provided, only return an Operation if there\n        // is one defined in the document. Upon encountering the second, return\n        // null.\n        if (operation) {\n          return null;\n        }\n\n        operation = definition;\n      } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {\n        return definition;\n      }\n    }\n  }\n\n  return operation;\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,gBAAgB,WAAW,EAAE,aAAa;IACxD,IAAI,YAAY;IAEhB,IAAK,IAAI,MAAM,GAAG,yBAAyB,YAAY,WAAW,EAAE,MAAM,uBAAuB,MAAM,EAAE,MAAO;QAC9G,IAAI,aAAa,sBAAsB,CAAC,IAAI;QAE5C,IAAI,WAAW,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,oBAAoB,EAAE;YACjD,IAAI;YAEJ,IAAI,iBAAiB,MAAM;gBACzB,uEAAuE;gBACvE,uEAAuE;gBACvE,QAAQ;gBACR,IAAI,WAAW;oBACb,OAAO;gBACT;gBAEA,YAAY;YACd,OAAO,IAAI,CAAC,CAAC,mBAAmB,WAAW,IAAI,MAAM,QAAQ,qBAAqB,KAAK,IAAI,KAAK,IAAI,iBAAiB,KAAK,MAAM,eAAe;gBAC7I,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 975, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/introspectionFromSchema.mjs"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport invariant from \"../jsutils/invariant.mjs\";\nimport { parse } from \"../language/parser.mjs\";\nimport { executeSync } from \"../execution/execute.mjs\";\nimport { getIntrospectionQuery } from \"./getIntrospectionQuery.mjs\";\n/**\n * Build an IntrospectionQuery from a GraphQLSchema\n *\n * IntrospectionQuery is useful for utilities that care about type and field\n * relationships, but do not need to traverse through those relationships.\n *\n * This is the inverse of buildClientSchema. The primary use case is outside\n * of the server context, for instance when doing schema comparisons.\n */\n\nexport function introspectionFromSchema(schema, options) {\n  var optionsWithDefaults = _objectSpread({\n    directiveIsRepeatable: true,\n    schemaDescription: true\n  }, options);\n\n  var document = parse(getIntrospectionQuery(optionsWithDefaults));\n  var result = executeSync({\n    schema: schema,\n    document: document\n  });\n  !result.errors && result.data || invariant(0);\n  return result.data;\n}\n"],"names":[],"mappings":";;;AAMA;AACA;AACA;AACA;AATA,SAAS,QAAQ,MAAM,EAAE,cAAc;IAAI,IAAI,OAAO,OAAO,IAAI,CAAC;IAAS,IAAI,OAAO,qBAAqB,EAAE;QAAE,IAAI,UAAU,OAAO,qBAAqB,CAAC;QAAS,IAAI,gBAAgB,UAAU,QAAQ,MAAM,CAAC,SAAU,GAAG;YAAI,OAAO,OAAO,wBAAwB,CAAC,QAAQ,KAAK,UAAU;QAAE;QAAI,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM;IAAU;IAAE,OAAO;AAAM;AAEpV,SAAS,cAAc,MAAM;IAAI,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;QAAE,IAAI,SAAS,SAAS,CAAC,EAAE,IAAI,OAAO,SAAS,CAAC,EAAE,GAAG,CAAC;QAAG,IAAI,IAAI,GAAG;YAAE,QAAQ,OAAO,SAAS,MAAM,OAAO,CAAC,SAAU,GAAG;gBAAI,gBAAgB,QAAQ,KAAK,MAAM,CAAC,IAAI;YAAG;QAAI,OAAO,IAAI,OAAO,yBAAyB,EAAE;YAAE,OAAO,gBAAgB,CAAC,QAAQ,OAAO,yBAAyB,CAAC;QAAU,OAAO;YAAE,QAAQ,OAAO,SAAS,OAAO,CAAC,SAAU,GAAG;gBAAI,OAAO,cAAc,CAAC,QAAQ,KAAK,OAAO,wBAAwB,CAAC,QAAQ;YAAO;QAAI;IAAE;IAAE,OAAO;AAAQ;AAErhB,SAAS,gBAAgB,GAAG,EAAE,GAAG,EAAE,KAAK;IAAI,IAAI,OAAO,KAAK;QAAE,OAAO,cAAc,CAAC,KAAK,KAAK;YAAE,OAAO;YAAO,YAAY;YAAM,cAAc;YAAM,UAAU;QAAK;IAAI,OAAO;QAAE,GAAG,CAAC,IAAI,GAAG;IAAO;IAAE,OAAO;AAAK;;;;;AAgBzM,SAAS,wBAAwB,MAAM,EAAE,OAAO;IACrD,IAAI,sBAAsB,cAAc;QACtC,uBAAuB;QACvB,mBAAmB;IACrB,GAAG;IAEH,IAAI,WAAW,CAAA,GAAA,gJAAA,CAAA,QAAK,AAAD,EAAE,CAAA,GAAA,gKAAA,CAAA,wBAAqB,AAAD,EAAE;IAC3C,IAAI,SAAS,CAAA,GAAA,kJAAA,CAAA,cAAW,AAAD,EAAE;QACvB,QAAQ;QACR,UAAU;IACZ;IACA,CAAC,OAAO,MAAM,IAAI,OAAO,IAAI,IAAI,CAAA,GAAA,kJAAA,CAAA,UAAS,AAAD,EAAE;IAC3C,OAAO,OAAO,IAAI;AACpB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1044, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/buildClientSchema.mjs"],"sourcesContent":["import objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport keyValMap from \"../jsutils/keyValMap.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport { parseValue } from \"../language/parser.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLDirective } from \"../type/directives.mjs\";\nimport { specifiedScalarTypes } from \"../type/scalars.mjs\";\nimport { introspectionTypes, TypeKind } from \"../type/introspection.mjs\";\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from \"../type/definition.mjs\";\nimport { valueFromAST } from \"./valueFromAST.mjs\";\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(0, \"Invalid or incomplete introspection result. Ensure that you are passing \\\"data\\\" property of introspection response and no \\\"errors\\\" was returned alongside: \".concat(inspect(introspection), \".\")); // Get the schema from the introspection result.\n\n  var schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  var typeMap = keyValMap(schemaIntrospection.types, function (typeIntrospection) {\n    return typeIntrospection.name;\n  }, function (typeIntrospection) {\n    return buildType(typeIntrospection);\n  }); // Include standard types only if they are used.\n\n  for (var _i2 = 0, _ref2 = [].concat(specifiedScalarTypes, introspectionTypes); _i2 < _ref2.length; _i2++) {\n    var stdType = _ref2[_i2];\n\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: objectValues(typeMap),\n    directives: directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    var typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(\"Unknown type reference: \".concat(inspect(typeRef), \".\"));\n    }\n\n    var type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure that a full introspection query is used in order to build a client schema.\"));\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type != null && type.name != null && type.kind != null) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    var typeStr = inspect(type);\n    throw new Error(\"Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: \".concat(typeStr, \".\"));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByUrl: scalarIntrospection.specifiedByUrl\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      var implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\"Introspection result missing interfaces: \".concat(implementingIntrospectionStr, \".\"));\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(objectIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(interfaceIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      var unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\"Introspection result missing possibleTypes: \".concat(unionIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      var enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\"Introspection result missing enumValues: \".concat(enumIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      var inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\"Introspection result missing inputFields: \".concat(inputObjectIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\"Introspection result missing fields: \".concat(inspect(typeIntrospection), \".\"));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, buildField);\n  }\n\n  function buildField(fieldIntrospection) {\n    var type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide output type for fields, but received: \".concat(typeStr, \".\"));\n    }\n\n    if (!fieldIntrospection.args) {\n      var fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\"Introspection result missing field args: \".concat(fieldIntrospectionStr, \".\"));\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type: type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide input type for arguments, but received: \".concat(typeStr, \".\"));\n    }\n\n    var defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      var directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\"Introspection result missing directive args: \".concat(directiveIntrospectionStr, \".\"));\n    }\n\n    if (!directiveIntrospection.locations) {\n      var _directiveIntrospectionStr = inspect(directiveIntrospection);\n\n      throw new Error(\"Introspection result missing directive locations: \".concat(_directiveIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAcO,SAAS,kBAAkB,aAAa,EAAE,OAAO;IACtD,CAAA,GAAA,qJAAA,CAAA,UAAY,AAAD,EAAE,kBAAkB,CAAA,GAAA,qJAAA,CAAA,UAAY,AAAD,EAAE,cAAc,QAAQ,KAAK,CAAA,GAAA,kJAAA,CAAA,UAAS,AAAD,EAAE,GAAG,iKAAiK,MAAM,CAAC,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE,gBAAgB,OAAO,gDAAgD;IAE3U,IAAI,sBAAsB,cAAc,QAAQ,EAAE,mEAAmE;IAErH,IAAI,UAAU,CAAA,GAAA,kJAAA,CAAA,UAAS,AAAD,EAAE,oBAAoB,KAAK,EAAE,SAAU,iBAAiB;QAC5E,OAAO,kBAAkB,IAAI;IAC/B,GAAG,SAAU,iBAAiB;QAC5B,OAAO,UAAU;IACnB,IAAI,gDAAgD;IAEpD,IAAK,IAAI,MAAM,GAAG,QAAQ,EAAE,CAAC,MAAM,CAAC,6IAAA,CAAA,uBAAoB,EAAE,mJAAA,CAAA,qBAAkB,GAAG,MAAM,MAAM,MAAM,EAAE,MAAO;QACxG,IAAI,UAAU,KAAK,CAAC,IAAI;QAExB,IAAI,OAAO,CAAC,QAAQ,IAAI,CAAC,EAAE;YACzB,OAAO,CAAC,QAAQ,IAAI,CAAC,GAAG;QAC1B;IACF,EAAE,wDAAwD;IAG1D,IAAI,YAAY,oBAAoB,SAAS,GAAG,cAAc,oBAAoB,SAAS,IAAI;IAC/F,IAAI,eAAe,oBAAoB,YAAY,GAAG,cAAc,oBAAoB,YAAY,IAAI;IACxG,IAAI,mBAAmB,oBAAoB,gBAAgB,GAAG,cAAc,oBAAoB,gBAAgB,IAAI,MAAM,uEAAuE;IACjM,mCAAmC;IAEnC,IAAI,aAAa,oBAAoB,UAAU,GAAG,oBAAoB,UAAU,CAAC,GAAG,CAAC,kBAAkB,EAAE,EAAE,qDAAqD;IAEhK,OAAO,IAAI,4IAAA,CAAA,gBAAa,CAAC;QACvB,aAAa,oBAAoB,WAAW;QAC5C,OAAO;QACP,UAAU;QACV,cAAc;QACd,OAAO,CAAA,GAAA,uJAAA,CAAA,UAAY,AAAD,EAAE;QACpB,YAAY;QACZ,aAAa,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,WAAW;IACpF,IAAI,4EAA4E;;;IAChF,6DAA6D;IAE7D,SAAS,QAAQ,OAAO;QACtB,IAAI,QAAQ,IAAI,KAAK,mJAAA,CAAA,WAAQ,CAAC,IAAI,EAAE;YAClC,IAAI,UAAU,QAAQ,MAAM;YAE5B,IAAI,CAAC,SAAS;gBACZ,MAAM,IAAI,MAAM;YAClB;YAEA,OAAO,CAAA,GAAA,gJAAA,CAAA,cAAW,AAAD,EAAE,QAAQ;QAC7B;QAEA,IAAI,QAAQ,IAAI,KAAK,mJAAA,CAAA,WAAQ,CAAC,QAAQ,EAAE;YACtC,IAAI,cAAc,QAAQ,MAAM;YAEhC,IAAI,CAAC,aAAa;gBAChB,MAAM,IAAI,MAAM;YAClB;YAEA,IAAI,eAAe,QAAQ;YAC3B,OAAO,CAAA,GAAA,gJAAA,CAAA,iBAAc,AAAD,EAAE,CAAA,GAAA,gJAAA,CAAA,qBAAkB,AAAD,EAAE;QAC3C;QAEA,OAAO,aAAa;IACtB;IAEA,SAAS,aAAa,OAAO;QAC3B,IAAI,WAAW,QAAQ,IAAI;QAE3B,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,MAAM,2BAA2B,MAAM,CAAC,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE,UAAU;QACtE;QAEA,IAAI,OAAO,OAAO,CAAC,SAAS;QAE5B,IAAI,CAAC,MAAM;YACT,MAAM,IAAI,MAAM,+CAA+C,MAAM,CAAC,UAAU;QAClF;QAEA,OAAO;IACT;IAEA,SAAS,cAAc,OAAO;QAC5B,OAAO,CAAA,GAAA,gJAAA,CAAA,mBAAgB,AAAD,EAAE,aAAa;IACvC;IAEA,SAAS,iBAAiB,OAAO;QAC/B,OAAO,CAAA,GAAA,gJAAA,CAAA,sBAAmB,AAAD,EAAE,aAAa;IAC1C,EAAE,6DAA6D;IAC/D,wBAAwB;IAGxB,SAAS,UAAU,IAAI;QACrB,IAAI,QAAQ,QAAQ,KAAK,IAAI,IAAI,QAAQ,KAAK,IAAI,IAAI,MAAM;YAC1D,OAAQ,KAAK,IAAI;gBACf,KAAK,mJAAA,CAAA,WAAQ,CAAC,MAAM;oBAClB,OAAO,eAAe;gBAExB,KAAK,mJAAA,CAAA,WAAQ,CAAC,MAAM;oBAClB,OAAO,eAAe;gBAExB,KAAK,mJAAA,CAAA,WAAQ,CAAC,SAAS;oBACrB,OAAO,kBAAkB;gBAE3B,KAAK,mJAAA,CAAA,WAAQ,CAAC,KAAK;oBACjB,OAAO,cAAc;gBAEvB,KAAK,mJAAA,CAAA,WAAQ,CAAC,IAAI;oBAChB,OAAO,aAAa;gBAEtB,KAAK,mJAAA,CAAA,WAAQ,CAAC,YAAY;oBACxB,OAAO,oBAAoB;YAC/B;QACF;QAEA,IAAI,UAAU,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;QACtB,MAAM,IAAI,MAAM,iIAAiI,MAAM,CAAC,SAAS;IACnK;IAEA,SAAS,eAAe,mBAAmB;QACzC,OAAO,IAAI,gJAAA,CAAA,oBAAiB,CAAC;YAC3B,MAAM,oBAAoB,IAAI;YAC9B,aAAa,oBAAoB,WAAW;YAC5C,gBAAgB,oBAAoB,cAAc;QACpD;IACF;IAEA,SAAS,yBAAyB,yBAAyB;QACzD,wEAAwE;QACxE,mCAAmC;QACnC,IAAI,0BAA0B,UAAU,KAAK,QAAQ,0BAA0B,IAAI,KAAK,mJAAA,CAAA,WAAQ,CAAC,SAAS,EAAE;YAC1G,OAAO,EAAE;QACX;QAEA,IAAI,CAAC,0BAA0B,UAAU,EAAE;YACzC,IAAI,+BAA+B,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;YAC3C,MAAM,IAAI,MAAM,4CAA4C,MAAM,CAAC,8BAA8B;QACnG;QAEA,OAAO,0BAA0B,UAAU,CAAC,GAAG,CAAC;IAClD;IAEA,SAAS,eAAe,mBAAmB;QACzC,OAAO,IAAI,gJAAA,CAAA,oBAAiB,CAAC;YAC3B,MAAM,oBAAoB,IAAI;YAC9B,aAAa,oBAAoB,WAAW;YAC5C,YAAY,SAAS;gBACnB,OAAO,yBAAyB;YAClC;YACA,QAAQ,SAAS;gBACf,OAAO,iBAAiB;YAC1B;QACF;IACF;IAEA,SAAS,kBAAkB,sBAAsB;QAC/C,OAAO,IAAI,gJAAA,CAAA,uBAAoB,CAAC;YAC9B,MAAM,uBAAuB,IAAI;YACjC,aAAa,uBAAuB,WAAW;YAC/C,YAAY,SAAS;gBACnB,OAAO,yBAAyB;YAClC;YACA,QAAQ,SAAS;gBACf,OAAO,iBAAiB;YAC1B;QACF;IACF;IAEA,SAAS,cAAc,kBAAkB;QACvC,IAAI,CAAC,mBAAmB,aAAa,EAAE;YACrC,IAAI,wBAAwB,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;YACpC,MAAM,IAAI,MAAM,+CAA+C,MAAM,CAAC,uBAAuB;QAC/F;QAEA,OAAO,IAAI,gJAAA,CAAA,mBAAgB,CAAC;YAC1B,MAAM,mBAAmB,IAAI;YAC7B,aAAa,mBAAmB,WAAW;YAC3C,OAAO,SAAS;gBACd,OAAO,mBAAmB,aAAa,CAAC,GAAG,CAAC;YAC9C;QACF;IACF;IAEA,SAAS,aAAa,iBAAiB;QACrC,IAAI,CAAC,kBAAkB,UAAU,EAAE;YACjC,IAAI,uBAAuB,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;YACnC,MAAM,IAAI,MAAM,4CAA4C,MAAM,CAAC,sBAAsB;QAC3F;QAEA,OAAO,IAAI,gJAAA,CAAA,kBAAe,CAAC;YACzB,MAAM,kBAAkB,IAAI;YAC5B,aAAa,kBAAkB,WAAW;YAC1C,QAAQ,CAAA,GAAA,kJAAA,CAAA,UAAS,AAAD,EAAE,kBAAkB,UAAU,EAAE,SAAU,kBAAkB;gBAC1E,OAAO,mBAAmB,IAAI;YAChC,GAAG,SAAU,kBAAkB;gBAC7B,OAAO;oBACL,aAAa,mBAAmB,WAAW;oBAC3C,mBAAmB,mBAAmB,iBAAiB;gBACzD;YACF;QACF;IACF;IAEA,SAAS,oBAAoB,wBAAwB;QACnD,IAAI,CAAC,yBAAyB,WAAW,EAAE;YACzC,IAAI,8BAA8B,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;YAC1C,MAAM,IAAI,MAAM,6CAA6C,MAAM,CAAC,6BAA6B;QACnG;QAEA,OAAO,IAAI,gJAAA,CAAA,yBAAsB,CAAC;YAChC,MAAM,yBAAyB,IAAI;YACnC,aAAa,yBAAyB,WAAW;YACjD,QAAQ,SAAS;gBACf,OAAO,sBAAsB,yBAAyB,WAAW;YACnE;QACF;IACF;IAEA,SAAS,iBAAiB,iBAAiB;QACzC,IAAI,CAAC,kBAAkB,MAAM,EAAE;YAC7B,MAAM,IAAI,MAAM,wCAAwC,MAAM,CAAC,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE,oBAAoB;QAC7F;QAEA,OAAO,CAAA,GAAA,kJAAA,CAAA,UAAS,AAAD,EAAE,kBAAkB,MAAM,EAAE,SAAU,kBAAkB;YACrE,OAAO,mBAAmB,IAAI;QAChC,GAAG;IACL;IAEA,SAAS,WAAW,kBAAkB;QACpC,IAAI,OAAO,QAAQ,mBAAmB,IAAI;QAE1C,IAAI,CAAC,CAAA,GAAA,gJAAA,CAAA,eAAY,AAAD,EAAE,OAAO;YACvB,IAAI,UAAU,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;YACtB,MAAM,IAAI,MAAM,oEAAoE,MAAM,CAAC,SAAS;QACtG;QAEA,IAAI,CAAC,mBAAmB,IAAI,EAAE;YAC5B,IAAI,wBAAwB,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;YACpC,MAAM,IAAI,MAAM,4CAA4C,MAAM,CAAC,uBAAuB;QAC5F;QAEA,OAAO;YACL,aAAa,mBAAmB,WAAW;YAC3C,mBAAmB,mBAAmB,iBAAiB;YACvD,MAAM;YACN,MAAM,sBAAsB,mBAAmB,IAAI;QACrD;IACF;IAEA,SAAS,sBAAsB,wBAAwB;QACrD,OAAO,CAAA,GAAA,kJAAA,CAAA,UAAS,AAAD,EAAE,0BAA0B,SAAU,UAAU;YAC7D,OAAO,WAAW,IAAI;QACxB,GAAG;IACL;IAEA,SAAS,gBAAgB,uBAAuB;QAC9C,IAAI,OAAO,QAAQ,wBAAwB,IAAI;QAE/C,IAAI,CAAC,CAAA,GAAA,gJAAA,CAAA,cAAW,AAAD,EAAE,OAAO;YACtB,IAAI,UAAU,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;YACtB,MAAM,IAAI,MAAM,sEAAsE,MAAM,CAAC,SAAS;QACxG;QAEA,IAAI,eAAe,wBAAwB,YAAY,IAAI,OAAO,CAAA,GAAA,uJAAA,CAAA,eAAY,AAAD,EAAE,CAAA,GAAA,gJAAA,CAAA,aAAU,AAAD,EAAE,wBAAwB,YAAY,GAAG,QAAQ;QACzI,OAAO;YACL,aAAa,wBAAwB,WAAW;YAChD,MAAM;YACN,cAAc;QAChB;IACF;IAEA,SAAS,eAAe,sBAAsB;QAC5C,IAAI,CAAC,uBAAuB,IAAI,EAAE;YAChC,IAAI,4BAA4B,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;YACxC,MAAM,IAAI,MAAM,gDAAgD,MAAM,CAAC,2BAA2B;QACpG;QAEA,IAAI,CAAC,uBAAuB,SAAS,EAAE;YACrC,IAAI,6BAA6B,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;YAEzC,MAAM,IAAI,MAAM,qDAAqD,MAAM,CAAC,4BAA4B;QAC1G;QAEA,OAAO,IAAI,gJAAA,CAAA,mBAAgB,CAAC;YAC1B,MAAM,uBAAuB,IAAI;YACjC,aAAa,uBAAuB,WAAW;YAC/C,cAAc,uBAAuB,YAAY;YACjD,WAAW,uBAAuB,SAAS,CAAC,KAAK;YACjD,MAAM,sBAAsB,uBAAuB,IAAI;QACzD;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1310, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/extendSchema.mjs"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport keyMap from \"../jsutils/keyMap.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport mapValue from \"../jsutils/mapValue.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { TokenKind } from \"../language/tokenKind.mjs\";\nimport { dedentBlockStringValue } from \"../language/blockString.mjs\";\nimport { isTypeDefinitionNode, isTypeExtensionNode } from \"../language/predicates.mjs\";\nimport { assertValidSDLExtension } from \"../validation/validate.mjs\";\nimport { getDirectiveValues } from \"../execution/values.mjs\";\nimport { assertSchema, GraphQLSchema } from \"../type/schema.mjs\";\nimport { specifiedScalarTypes, isSpecifiedScalarType } from \"../type/scalars.mjs\";\nimport { introspectionTypes, isIntrospectionType } from \"../type/introspection.mjs\";\nimport { GraphQLDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective } from \"../type/directives.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from \"../type/definition.mjs\";\nimport { valueFromAST } from \"./valueFromAST.mjs\";\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n\n  var schemaConfig = schema.toConfig();\n  var extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nexport function extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n\n  // Collect the type definitions and extensions found in the document.\n  var typeDefs = [];\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      var extendedTypeName = def.name.value;\n      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {\n    return schemaConfig;\n  }\n\n  var typeMap = Object.create(null);\n\n  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {\n    var existingType = _schemaConfig$types2[_i4];\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (var _i6 = 0; _i6 < typeDefs.length; _i6++) {\n    var _stdTypeMap$name;\n\n    var typeNode = typeDefs[_i6];\n    var name = typeNode.name.value;\n    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);\n  }\n\n  var operationTypes = _objectSpread(_objectSpread({\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)\n  }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions)); // Then produce and return a Schema config with these types.\n\n\n  return _objectSpread(_objectSpread({\n    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value\n  }, operationTypes), {}, {\n    types: objectValues(typeMap),\n    directives: [].concat(schemaConfig.directives.map(replaceDirective), directiveDefs.map(buildDirective)),\n    extensions: undefined,\n    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {\n      args: mapValue(config.args, extendArg)\n    }));\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if (isScalarType(type)) {\n      return extendScalarType(type);\n    }\n\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n\n    if (isEnumType(type)) {\n      return extendEnumType(type);\n    } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n    if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n    false || invariant(0, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];\n    return new GraphQLInputObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, function (field) {\n          return _objectSpread(_objectSpread({}, field), {}, {\n            type: replaceType(field.type)\n          });\n        })), buildInputFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];\n    return new GraphQLEnumType(_objectSpread(_objectSpread({}, config), {}, {\n      values: _objectSpread(_objectSpread({}, config.values), buildEnumValueMap(extensions)),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];\n    var specifiedByUrl = config.specifiedByUrl;\n\n    for (var _i8 = 0; _i8 < extensions.length; _i8++) {\n      var _getSpecifiedByUrl;\n\n      var extensionNode = extensions[_i8];\n      specifiedByUrl = (_getSpecifiedByUrl = getSpecifiedByUrl(extensionNode)) !== null && _getSpecifiedByUrl !== void 0 ? _getSpecifiedByUrl : specifiedByUrl;\n    }\n\n    return new GraphQLScalarType(_objectSpread(_objectSpread({}, config), {}, {\n      specifiedByUrl: specifiedByUrl,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];\n    return new GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];\n    return new GraphQLInterfaceType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];\n    return new GraphQLUnionType(_objectSpread(_objectSpread({}, config), {}, {\n      types: function types() {\n        return [].concat(type.getTypes().map(replaceNamedType), buildUnionTypes(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendField(field) {\n    return _objectSpread(_objectSpread({}, field), {}, {\n      type: replaceType(field.type),\n      args: mapValue(field.args, extendArg)\n    });\n  }\n\n  function extendArg(arg) {\n    return _objectSpread(_objectSpread({}, arg), {}, {\n      type: replaceType(arg.type)\n    });\n  }\n\n  function getOperationTypes(nodes) {\n    var opTypes = {};\n\n    for (var _i10 = 0; _i10 < nodes.length; _i10++) {\n      var _node$operationTypes;\n\n      var node = nodes[_i10];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n\n      for (var _i12 = 0; _i12 < operationTypesNodes.length; _i12++) {\n        var operationType = operationTypesNodes[_i12];\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    } // Note: While this could make early assertions to get the correctly\n    // typed values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    var name = node.name.value;\n    var type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(name, \"\\\".\"));\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var locations = node.locations.map(function (_ref) {\n      var value = _ref.value;\n      return value;\n    });\n    return new GraphQLDirective({\n      name: node.name.value,\n      description: getDescription(node, options),\n      locations: locations,\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    var fieldConfigMap = Object.create(null);\n\n    for (var _i14 = 0; _i14 < nodes.length; _i14++) {\n      var _node$fields;\n\n      var node = nodes[_i14];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n\n      for (var _i16 = 0; _i16 < nodeFields.length; _i16++) {\n        var field = nodeFields[_i16];\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description: getDescription(field, options),\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    var argsNodes = args !== null && args !== void 0 ? args : [];\n    var argConfigMap = Object.create(null);\n\n    for (var _i18 = 0; _i18 < argsNodes.length; _i18++) {\n      var arg = argsNodes[_i18];\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      var type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type: type,\n        description: getDescription(arg, options),\n        defaultValue: valueFromAST(arg.defaultValue, type),\n        astNode: arg\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    var inputFieldMap = Object.create(null);\n\n    for (var _i20 = 0; _i20 < nodes.length; _i20++) {\n      var _node$fields2;\n\n      var node = nodes[_i20];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];\n\n      for (var _i22 = 0; _i22 < fieldsNodes.length; _i22++) {\n        var field = fieldsNodes[_i22];\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        var type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type: type,\n          description: getDescription(field, options),\n          defaultValue: valueFromAST(field.defaultValue, type),\n          astNode: field\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    var enumValueMap = Object.create(null);\n\n    for (var _i24 = 0; _i24 < nodes.length; _i24++) {\n      var _node$values;\n\n      var node = nodes[_i24];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n\n      for (var _i26 = 0; _i26 < valuesNodes.length; _i26++) {\n        var value = valuesNodes[_i26];\n        enumValueMap[value.name.value] = {\n          description: getDescription(value, options),\n          deprecationReason: getDeprecationReason(value),\n          astNode: value\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    var interfaces = [];\n\n    for (var _i28 = 0; _i28 < nodes.length; _i28++) {\n      var _node$interfaces;\n\n      var node = nodes[_i28];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var interfacesNodes = (_node$interfaces = node.interfaces) !== null && _node$interfaces !== void 0 ? _node$interfaces : [];\n\n      for (var _i30 = 0; _i30 < interfacesNodes.length; _i30++) {\n        var type = interfacesNodes[_i30];\n        // Note: While this could make assertions to get the correctly typed\n        // values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable\n        // results.\n        interfaces.push(getNamedType(type));\n      }\n    }\n\n    return interfaces;\n  }\n\n  function buildUnionTypes(nodes) {\n    var types = [];\n\n    for (var _i32 = 0; _i32 < nodes.length; _i32++) {\n      var _node$types;\n\n      var node = nodes[_i32];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var typeNodes = (_node$types = node.types) !== null && _node$types !== void 0 ? _node$types : [];\n\n      for (var _i34 = 0; _i34 < typeNodes.length; _i34++) {\n        var type = typeNodes[_i34];\n        // Note: While this could make assertions to get the correctly typed\n        // values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable\n        // results.\n        types.push(getNamedType(type));\n      }\n    }\n\n    return types;\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    var name = astNode.name.value;\n    var description = getDescription(astNode, options);\n    var extensionNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        {\n          var extensionASTNodes = extensionNodes;\n          var allNodes = [astNode].concat(extensionASTNodes);\n          return new GraphQLObjectType({\n            name: name,\n            description: description,\n            interfaces: function interfaces() {\n              return buildInterfaces(allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes = extensionNodes;\n\n          var _allNodes = [astNode].concat(_extensionASTNodes);\n\n          return new GraphQLInterfaceType({\n            name: name,\n            description: description,\n            interfaces: function interfaces() {\n              return buildInterfaces(_allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(_allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes\n          });\n        }\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes2 = extensionNodes;\n\n          var _allNodes2 = [astNode].concat(_extensionASTNodes2);\n\n          return new GraphQLEnumType({\n            name: name,\n            description: description,\n            values: buildEnumValueMap(_allNodes2),\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes2\n          });\n        }\n\n      case Kind.UNION_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes3 = extensionNodes;\n\n          var _allNodes3 = [astNode].concat(_extensionASTNodes3);\n\n          return new GraphQLUnionType({\n            name: name,\n            description: description,\n            types: function types() {\n              return buildUnionTypes(_allNodes3);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes3\n          });\n        }\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes4 = extensionNodes;\n          return new GraphQLScalarType({\n            name: name,\n            description: description,\n            specifiedByUrl: getSpecifiedByUrl(astNode),\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes4\n          });\n        }\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes5 = extensionNodes;\n\n          var _allNodes4 = [astNode].concat(_extensionASTNodes5);\n\n          return new GraphQLInputObjectType({\n            name: name,\n            description: description,\n            fields: function fields() {\n              return buildInputFieldMap(_allNodes4);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes5\n          });\n        }\n    } // istanbul ignore next (Not reachable. All possible type definition nodes have been considered)\n\n\n    false || invariant(0, 'Unexpected type definition node: ' + inspect(astNode));\n  }\n}\nvar stdTypeMap = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n  return type.name;\n});\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByUrl.\n */\n\n\nfunction getSpecifiedByUrl(node) {\n  var specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);\n  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if ((options === null || options === void 0 ? void 0 : options.commentDescriptions) === true) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token != null && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1918, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/buildASTSchema.mjs"],"sourcesContent":["import devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { parse } from \"../language/parser.mjs\";\nimport { assertValidSDL } from \"../validation/validate.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective } from \"../type/directives.mjs\";\nimport { extendSchemaImpl } from \"./extendSchema.mjs\";\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDL(documentAST);\n  }\n\n  var emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: undefined,\n    extensionASTNodes: [],\n    assumeValid: false\n  };\n  var config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n      var type = _config$types2[_i2];\n\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  var directives = config.directives; // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'specifiedBy';\n  })) {\n    directives.push(GraphQLSpecifiedByDirective);\n  }\n\n  return new GraphQLSchema(config);\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  var document = parse(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,\n    allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,\n    experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables\n  });\n  return buildASTSchema(document, {\n    commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAkBO,SAAS,eAAe,WAAW,EAAE,OAAO;IACjD,eAAe,QAAQ,YAAY,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,QAAQ,IAAI,CAAA,GAAA,kJAAA,CAAA,UAAS,AAAD,EAAE,GAAG;IAE1E,IAAI,CAAC,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,WAAW,MAAM,QAAQ,CAAC,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,cAAc,MAAM,MAAM;QAC3K,CAAA,GAAA,oJAAA,CAAA,iBAAc,AAAD,EAAE;IACjB;IAEA,IAAI,oBAAoB;QACtB,aAAa;QACb,OAAO,EAAE;QACT,YAAY,EAAE;QACd,YAAY;QACZ,mBAAmB,EAAE;QACrB,aAAa;IACf;IACA,IAAI,SAAS,CAAA,GAAA,uJAAA,CAAA,mBAAgB,AAAD,EAAE,mBAAmB,aAAa;IAE9D,IAAI,OAAO,OAAO,IAAI,MAAM;QAC1B,IAAK,IAAI,MAAM,GAAG,iBAAiB,OAAO,KAAK,EAAE,MAAM,eAAe,MAAM,EAAE,MAAO;YACnF,IAAI,OAAO,cAAc,CAAC,IAAI;YAE9B,OAAQ,KAAK,IAAI;gBACf,oEAAoE;gBACpE,qEAAqE;gBACrE,yEAAyE;gBACzE,KAAK;oBACH,OAAO,KAAK,GAAG;oBACf;gBAEF,KAAK;oBACH,OAAO,QAAQ,GAAG;oBAClB;gBAEF,KAAK;oBACH,OAAO,YAAY,GAAG;oBACtB;YACJ;QACF;IACF;IAEA,IAAI,aAAa,OAAO,UAAU,EAAE,kEAAkE;IAEtG,IAAI,CAAC,WAAW,IAAI,CAAC,SAAU,SAAS;QACtC,OAAO,UAAU,IAAI,KAAK;IAC5B,IAAI;QACF,WAAW,IAAI,CAAC,gJAAA,CAAA,uBAAoB;IACtC;IAEA,IAAI,CAAC,WAAW,IAAI,CAAC,SAAU,SAAS;QACtC,OAAO,UAAU,IAAI,KAAK;IAC5B,IAAI;QACF,WAAW,IAAI,CAAC,gJAAA,CAAA,0BAAuB;IACzC;IAEA,IAAI,CAAC,WAAW,IAAI,CAAC,SAAU,SAAS;QACtC,OAAO,UAAU,IAAI,KAAK;IAC5B,IAAI;QACF,WAAW,IAAI,CAAC,gJAAA,CAAA,6BAA0B;IAC5C;IAEA,IAAI,CAAC,WAAW,IAAI,CAAC,SAAU,SAAS;QACtC,OAAO,UAAU,IAAI,KAAK;IAC5B,IAAI;QACF,WAAW,IAAI,CAAC,gJAAA,CAAA,8BAA2B;IAC7C;IAEA,OAAO,IAAI,4IAAA,CAAA,gBAAa,CAAC;AAC3B;AAMO,SAAS,YAAY,MAAM,EAAE,OAAO;IACzC,IAAI,WAAW,CAAA,GAAA,gJAAA,CAAA,QAAK,AAAD,EAAE,QAAQ;QAC3B,YAAY,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,UAAU;QAChF,2BAA2B,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,yBAAyB;QAC9G,oCAAoC,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,kCAAkC;QAChI,+BAA+B,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,6BAA6B;IACxH;IACA,OAAO,eAAe,UAAU;QAC9B,qBAAqB,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,mBAAmB;QAClG,gBAAgB,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,cAAc;QACxF,aAAa,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,WAAW;IACpF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2009, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/lexicographicSortSchema.mjs"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport keyValMap from \"../jsutils/keyValMap.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLDirective } from \"../type/directives.mjs\";\nimport { isIntrospectionType } from \"../type/introspection.mjs\";\nimport { GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, isListType, isNonNullType, isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType } from \"../type/definition.mjs\";\n/**\n * Sort GraphQLSchema.\n *\n * This function returns a sorted copy of the given GraphQLSchema.\n */\n\nexport function lexicographicSortSchema(schema) {\n  var schemaConfig = schema.toConfig();\n  var typeMap = keyValMap(sortByName(schemaConfig.types), function (type) {\n    return type.name;\n  }, sortNamedType);\n  return new GraphQLSchema(_objectSpread(_objectSpread({}, schemaConfig), {}, {\n    types: objectValues(typeMap),\n    directives: sortByName(schemaConfig.directives).map(sortDirective),\n    query: replaceMaybeType(schemaConfig.query),\n    mutation: replaceMaybeType(schemaConfig.mutation),\n    subscription: replaceMaybeType(schemaConfig.subscription)\n  }));\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n\n  function replaceMaybeType(maybeType) {\n    return maybeType && replaceNamedType(maybeType);\n  }\n\n  function sortDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {\n      locations: sortBy(config.locations, function (x) {\n        return x;\n      }),\n      args: sortArgs(config.args)\n    }));\n  }\n\n  function sortArgs(args) {\n    return sortObjMap(args, function (arg) {\n      return _objectSpread(_objectSpread({}, arg), {}, {\n        type: replaceType(arg.type)\n      });\n    });\n  }\n\n  function sortFields(fieldsMap) {\n    return sortObjMap(fieldsMap, function (field) {\n      return _objectSpread(_objectSpread({}, field), {}, {\n        type: replaceType(field.type),\n        args: sortArgs(field.args)\n      });\n    });\n  }\n\n  function sortInputFields(fieldsMap) {\n    return sortObjMap(fieldsMap, function (field) {\n      return _objectSpread(_objectSpread({}, field), {}, {\n        type: replaceType(field.type)\n      });\n    });\n  }\n\n  function sortTypes(arr) {\n    return sortByName(arr).map(replaceNamedType);\n  }\n\n  function sortNamedType(type) {\n    if (isScalarType(type) || isIntrospectionType(type)) {\n      return type;\n    }\n\n    if (isObjectType(type)) {\n      var config = type.toConfig();\n      return new GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n        interfaces: function interfaces() {\n          return sortTypes(config.interfaces);\n        },\n        fields: function fields() {\n          return sortFields(config.fields);\n        }\n      }));\n    }\n\n    if (isInterfaceType(type)) {\n      var _config = type.toConfig();\n\n      return new GraphQLInterfaceType(_objectSpread(_objectSpread({}, _config), {}, {\n        interfaces: function interfaces() {\n          return sortTypes(_config.interfaces);\n        },\n        fields: function fields() {\n          return sortFields(_config.fields);\n        }\n      }));\n    }\n\n    if (isUnionType(type)) {\n      var _config2 = type.toConfig();\n\n      return new GraphQLUnionType(_objectSpread(_objectSpread({}, _config2), {}, {\n        types: function types() {\n          return sortTypes(_config2.types);\n        }\n      }));\n    }\n\n    if (isEnumType(type)) {\n      var _config3 = type.toConfig();\n\n      return new GraphQLEnumType(_objectSpread(_objectSpread({}, _config3), {}, {\n        values: sortObjMap(_config3.values)\n      }));\n    } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n    if (isInputObjectType(type)) {\n      var _config4 = type.toConfig();\n\n      return new GraphQLInputObjectType(_objectSpread(_objectSpread({}, _config4), {}, {\n        fields: function fields() {\n          return sortInputFields(_config4.fields);\n        }\n      }));\n    } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n    false || invariant(0, 'Unexpected type: ' + inspect(type));\n  }\n}\n\nfunction sortObjMap(map, sortValueFn) {\n  var sortedMap = Object.create(null);\n  var sortedKeys = sortBy(Object.keys(map), function (x) {\n    return x;\n  });\n\n  for (var _i2 = 0; _i2 < sortedKeys.length; _i2++) {\n    var key = sortedKeys[_i2];\n    var value = map[key];\n    sortedMap[key] = sortValueFn ? sortValueFn(value) : value;\n  }\n\n  return sortedMap;\n}\n\nfunction sortByName(array) {\n  return sortBy(array, function (obj) {\n    return obj.name;\n  });\n}\n\nfunction sortBy(array, mapToKey) {\n  return array.slice().sort(function (obj1, obj2) {\n    var key1 = mapToKey(obj1);\n    var key2 = mapToKey(obj2);\n    return key1.localeCompare(key2);\n  });\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2210, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/printSchema.mjs"],"sourcesContent":["import objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport { print } from \"../language/printer.mjs\";\nimport { printBlockString } from \"../language/blockString.mjs\";\nimport { isIntrospectionType } from \"../type/introspection.mjs\";\nimport { GraphQLString, isSpecifiedScalarType } from \"../type/scalars.mjs\";\nimport { DEFAULT_DEPRECATION_REASON, isSpecifiedDirective } from \"../type/directives.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType } from \"../type/definition.mjs\";\nimport { astFromValue } from \"./astFromValue.mjs\";\n\n/**\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function printSchema(schema, options) {\n  return printFilteredSchema(schema, function (n) {\n    return !isSpecifiedDirective(n);\n  }, isDefinedType, options);\n}\nexport function printIntrospectionSchema(schema, options) {\n  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType, options);\n}\n\nfunction isDefinedType(type) {\n  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);\n}\n\nfunction printFilteredSchema(schema, directiveFilter, typeFilter, options) {\n  var directives = schema.getDirectives().filter(directiveFilter);\n  var types = objectValues(schema.getTypeMap()).filter(typeFilter);\n  return [printSchemaDefinition(schema)].concat(directives.map(function (directive) {\n    return printDirective(directive, options);\n  }), types.map(function (type) {\n    return printType(type, options);\n  })).filter(Boolean).join('\\n\\n') + '\\n';\n}\n\nfunction printSchemaDefinition(schema) {\n  if (schema.description == null && isSchemaOfCommonNames(schema)) {\n    return;\n  }\n\n  var operationTypes = [];\n  var queryType = schema.getQueryType();\n\n  if (queryType) {\n    operationTypes.push(\"  query: \".concat(queryType.name));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType) {\n    operationTypes.push(\"  mutation: \".concat(mutationType.name));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    operationTypes.push(\"  subscription: \".concat(subscriptionType.name));\n  }\n\n  return printDescription({}, schema) + \"schema {\\n\".concat(operationTypes.join('\\n'), \"\\n}\");\n}\n/**\n * GraphQL schema define root types for each type of operation. These types are\n * the same as any other type and can be named in any manner, however there is\n * a common naming convention:\n *\n *   schema {\n *     query: Query\n *     mutation: Mutation\n *   }\n *\n * When using this naming convention, the schema description can be omitted.\n */\n\n\nfunction isSchemaOfCommonNames(schema) {\n  var queryType = schema.getQueryType();\n\n  if (queryType && queryType.name !== 'Query') {\n    return false;\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && mutationType.name !== 'Mutation') {\n    return false;\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && subscriptionType.name !== 'Subscription') {\n    return false;\n  }\n\n  return true;\n}\n\nexport function printType(type, options) {\n  if (isScalarType(type)) {\n    return printScalar(type, options);\n  }\n\n  if (isObjectType(type)) {\n    return printObject(type, options);\n  }\n\n  if (isInterfaceType(type)) {\n    return printInterface(type, options);\n  }\n\n  if (isUnionType(type)) {\n    return printUnion(type, options);\n  }\n\n  if (isEnumType(type)) {\n    return printEnum(type, options);\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isInputObjectType(type)) {\n    return printInputObject(type, options);\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected type: ' + inspect(type));\n}\n\nfunction printScalar(type, options) {\n  return printDescription(options, type) + \"scalar \".concat(type.name) + printSpecifiedByUrl(type);\n}\n\nfunction printImplementedInterfaces(type) {\n  var interfaces = type.getInterfaces();\n  return interfaces.length ? ' implements ' + interfaces.map(function (i) {\n    return i.name;\n  }).join(' & ') : '';\n}\n\nfunction printObject(type, options) {\n  return printDescription(options, type) + \"type \".concat(type.name) + printImplementedInterfaces(type) + printFields(options, type);\n}\n\nfunction printInterface(type, options) {\n  return printDescription(options, type) + \"interface \".concat(type.name) + printImplementedInterfaces(type) + printFields(options, type);\n}\n\nfunction printUnion(type, options) {\n  var types = type.getTypes();\n  var possibleTypes = types.length ? ' = ' + types.join(' | ') : '';\n  return printDescription(options, type) + 'union ' + type.name + possibleTypes;\n}\n\nfunction printEnum(type, options) {\n  var values = type.getValues().map(function (value, i) {\n    return printDescription(options, value, '  ', !i) + '  ' + value.name + printDeprecated(value);\n  });\n  return printDescription(options, type) + \"enum \".concat(type.name) + printBlock(values);\n}\n\nfunction printInputObject(type, options) {\n  var fields = objectValues(type.getFields()).map(function (f, i) {\n    return printDescription(options, f, '  ', !i) + '  ' + printInputValue(f);\n  });\n  return printDescription(options, type) + \"input \".concat(type.name) + printBlock(fields);\n}\n\nfunction printFields(options, type) {\n  var fields = objectValues(type.getFields()).map(function (f, i) {\n    return printDescription(options, f, '  ', !i) + '  ' + f.name + printArgs(options, f.args, '  ') + ': ' + String(f.type) + printDeprecated(f);\n  });\n  return printBlock(fields);\n}\n\nfunction printBlock(items) {\n  return items.length !== 0 ? ' {\\n' + items.join('\\n') + '\\n}' : '';\n}\n\nfunction printArgs(options, args) {\n  var indentation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n  if (args.length === 0) {\n    return '';\n  } // If every arg does not have a description, print them on one line.\n\n\n  if (args.every(function (arg) {\n    return !arg.description;\n  })) {\n    return '(' + args.map(printInputValue).join(', ') + ')';\n  }\n\n  return '(\\n' + args.map(function (arg, i) {\n    return printDescription(options, arg, '  ' + indentation, !i) + '  ' + indentation + printInputValue(arg);\n  }).join('\\n') + '\\n' + indentation + ')';\n}\n\nfunction printInputValue(arg) {\n  var defaultAST = astFromValue(arg.defaultValue, arg.type);\n  var argDecl = arg.name + ': ' + String(arg.type);\n\n  if (defaultAST) {\n    argDecl += \" = \".concat(print(defaultAST));\n  }\n\n  return argDecl;\n}\n\nfunction printDirective(directive, options) {\n  return printDescription(options, directive) + 'directive @' + directive.name + printArgs(options, directive.args) + (directive.isRepeatable ? ' repeatable' : '') + ' on ' + directive.locations.join(' | ');\n}\n\nfunction printDeprecated(fieldOrEnumVal) {\n  if (!fieldOrEnumVal.isDeprecated) {\n    return '';\n  }\n\n  var reason = fieldOrEnumVal.deprecationReason;\n  var reasonAST = astFromValue(reason, GraphQLString);\n\n  if (reasonAST && reason !== DEFAULT_DEPRECATION_REASON) {\n    return ' @deprecated(reason: ' + print(reasonAST) + ')';\n  }\n\n  return ' @deprecated';\n}\n\nfunction printSpecifiedByUrl(scalar) {\n  if (scalar.specifiedByUrl == null) {\n    return '';\n  }\n\n  var url = scalar.specifiedByUrl;\n  var urlAST = astFromValue(url, GraphQLString);\n  urlAST || invariant(0, 'Unexpected null value returned from `astFromValue` for specifiedByUrl');\n  return ' @specifiedBy(url: ' + print(urlAST) + ')';\n}\n\nfunction printDescription(options, def) {\n  var indentation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var firstInBlock = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var description = def.description;\n\n  if (description == null) {\n    return '';\n  }\n\n  if ((options === null || options === void 0 ? void 0 : options.commentDescriptions) === true) {\n    return printDescriptionWithComments(description, indentation, firstInBlock);\n  }\n\n  var preferMultipleLines = description.length > 70;\n  var blockString = printBlockString(description, '', preferMultipleLines);\n  var prefix = indentation && !firstInBlock ? '\\n' + indentation : indentation;\n  return prefix + blockString.replace(/\\n/g, '\\n' + indentation) + '\\n';\n}\n\nfunction printDescriptionWithComments(description, indentation, firstInBlock) {\n  var prefix = indentation && !firstInBlock ? '\\n' : '';\n  var comment = description.split('\\n').map(function (line) {\n    return indentation + (line !== '' ? '# ' + line : '#');\n  }).join('\\n');\n  return prefix + comment + '\\n';\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2435, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/concatAST.mjs"],"sourcesContent":["import flatMap from \"../polyfills/flatMap.mjs\";\n\n/**\n * Provided a collection of ASTs, presumably each from different files,\n * concatenate the ASTs together into batched AST, useful for validating many\n * GraphQL source files which together represent one conceptual application.\n */\nexport function concatAST(asts) {\n  return {\n    kind: 'Document',\n    definitions: flatMap(asts, function (ast) {\n      return ast.definitions;\n    })\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,UAAU,IAAI;IAC5B,OAAO;QACL,MAAM;QACN,aAAa,CAAA,GAAA,kJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,SAAU,GAAG;YACtC,OAAO,IAAI,WAAW;QACxB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2452, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/separateOperations.mjs"],"sourcesContent":["import { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null);\n  var fromName; // Populate metadata and build a dependency graph.\n\n  visit(documentAST, {\n    OperationDefinition: function OperationDefinition(node) {\n      fromName = opName(node);\n      operations.push(node);\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fromName = node.name.value;\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var toName = node.name.value;\n      var dependents = depGraph[fromName];\n\n      if (dependents === undefined) {\n        dependents = depGraph[fromName] = Object.create(null);\n      }\n\n      dependents[toName] = true;\n    }\n  }); // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  var separatedDocumentASTs = Object.create(null);\n\n  var _loop = function _loop(_i2) {\n    var operation = operations[_i2];\n    var operationName = opName(operation);\n    var dependencies = Object.create(null);\n    collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies[node.name.value];\n      })\n    };\n  };\n\n  for (var _i2 = 0; _i2 < operations.length; _i2++) {\n    _loop(_i2);\n  }\n\n  return separatedDocumentASTs;\n}\n\n// Provides the empty string for anonymous operations.\nfunction opName(operation) {\n  return operation.name ? operation.name.value : '';\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  var immediateDeps = depGraph[fromName];\n\n  if (immediateDeps) {\n    for (var _i4 = 0, _Object$keys2 = Object.keys(immediateDeps); _i4 < _Object$keys2.length; _i4++) {\n      var toName = _Object$keys2[_i4];\n\n      if (!collected[toName]) {\n        collected[toName] = true;\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAQO,SAAS,mBAAmB,WAAW;IAC5C,IAAI,aAAa,EAAE;IACnB,IAAI,WAAW,OAAO,MAAM,CAAC;IAC7B,IAAI,UAAU,kDAAkD;IAEhE,CAAA,GAAA,iJAAA,CAAA,QAAK,AAAD,EAAE,aAAa;QACjB,qBAAqB,SAAS,oBAAoB,IAAI;YACpD,WAAW,OAAO;YAClB,WAAW,IAAI,CAAC;QAClB;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,WAAW,KAAK,IAAI,CAAC,KAAK;QAC5B;QACA,gBAAgB,SAAS,eAAe,IAAI;YAC1C,IAAI,SAAS,KAAK,IAAI,CAAC,KAAK;YAC5B,IAAI,aAAa,QAAQ,CAAC,SAAS;YAEnC,IAAI,eAAe,WAAW;gBAC5B,aAAa,QAAQ,CAAC,SAAS,GAAG,OAAO,MAAM,CAAC;YAClD;YAEA,UAAU,CAAC,OAAO,GAAG;QACvB;IACF,IAAI,6EAA6E;IACjF,8CAA8C;IAE9C,IAAI,wBAAwB,OAAO,MAAM,CAAC;IAE1C,IAAI,QAAQ,SAAS,MAAM,GAAG;QAC5B,IAAI,YAAY,UAAU,CAAC,IAAI;QAC/B,IAAI,gBAAgB,OAAO;QAC3B,IAAI,eAAe,OAAO,MAAM,CAAC;QACjC,8BAA8B,cAAc,UAAU,gBAAgB,yEAAyE;QAC/I,qDAAqD;QAErD,qBAAqB,CAAC,cAAc,GAAG;YACrC,MAAM,+IAAA,CAAA,OAAI,CAAC,QAAQ;YACnB,aAAa,YAAY,WAAW,CAAC,MAAM,CAAC,SAAU,IAAI;gBACxD,OAAO,SAAS,aAAa,KAAK,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,mBAAmB,IAAI,YAAY,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC;YACtG;QACF;IACF;IAEA,IAAK,IAAI,MAAM,GAAG,MAAM,WAAW,MAAM,EAAE,MAAO;QAChD,MAAM;IACR;IAEA,OAAO;AACT;AAEA,sDAAsD;AACtD,SAAS,OAAO,SAAS;IACvB,OAAO,UAAU,IAAI,GAAG,UAAU,IAAI,CAAC,KAAK,GAAG;AACjD,EAAE,yEAAyE;AAC3E,wCAAwC;AAGxC,SAAS,8BAA8B,SAAS,EAAE,QAAQ,EAAE,QAAQ;IAClE,IAAI,gBAAgB,QAAQ,CAAC,SAAS;IAEtC,IAAI,eAAe;QACjB,IAAK,IAAI,MAAM,GAAG,gBAAgB,OAAO,IAAI,CAAC,gBAAgB,MAAM,cAAc,MAAM,EAAE,MAAO;YAC/F,IAAI,SAAS,aAAa,CAAC,IAAI;YAE/B,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE;gBACtB,SAAS,CAAC,OAAO,GAAG;gBACpB,8BAA8B,WAAW,UAAU;YACrD;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2521, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/stripIgnoredCharacters.mjs"],"sourcesContent":["import inspect from \"../jsutils/inspect.mjs\";\nimport { Source } from \"../language/source.mjs\";\nimport { TokenKind } from \"../language/tokenKind.mjs\";\nimport { Lexer, isPunctuatorTokenKind } from \"../language/lexer.mjs\";\nimport { dedentBlockStringValue, getBlockStringIndentation } from \"../language/blockString.mjs\";\n/**\n * Strips characters that are not significant to the validity or execution\n * of a GraphQL document:\n *   - UnicodeBOM\n *   - WhiteSpace\n *   - LineTerminator\n *   - Comment\n *   - Comma\n *   - BlockString indentation\n *\n * Note: It is required to have a delimiter character between neighboring\n * non-punctuator tokens and this function always uses single space as delimiter.\n *\n * It is guaranteed that both input and output documents if parsed would result\n * in the exact same AST except for nodes location.\n *\n * Warning: It is guaranteed that this function will always produce stable results.\n * However, it's not guaranteed that it will stay the same between different\n * releases due to bugfixes or changes in the GraphQL specification.\n *\n * Query example:\n *\n * query SomeQuery($foo: String!, $bar: String) {\n *   someField(foo: $foo, bar: $bar) {\n *     a\n *     b {\n *       c\n *       d\n *     }\n *   }\n * }\n *\n * Becomes:\n *\n * query SomeQuery($foo:String!$bar:String){someField(foo:$foo bar:$bar){a b{c d}}}\n *\n * SDL example:\n *\n * \"\"\"\n * Type description\n * \"\"\"\n * type Foo {\n *   \"\"\"\n *   Field description\n *   \"\"\"\n *   bar: String\n * }\n *\n * Becomes:\n *\n * \"\"\"Type description\"\"\" type Foo{\"\"\"Field description\"\"\" bar:String}\n */\n\nexport function stripIgnoredCharacters(source) {\n  var sourceObj = typeof source === 'string' ? new Source(source) : source;\n\n  if (!(sourceObj instanceof Source)) {\n    throw new TypeError(\"Must provide string or Source. Received: \".concat(inspect(sourceObj), \".\"));\n  }\n\n  var body = sourceObj.body;\n  var lexer = new Lexer(sourceObj);\n  var strippedBody = '';\n  var wasLastAddedTokenNonPunctuator = false;\n\n  while (lexer.advance().kind !== TokenKind.EOF) {\n    var currentToken = lexer.token;\n    var tokenKind = currentToken.kind;\n    /**\n     * Every two non-punctuator tokens should have space between them.\n     * Also prevent case of non-punctuator token following by spread resulting\n     * in invalid token (e.g. `1...` is invalid Float token).\n     */\n\n    var isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);\n\n    if (wasLastAddedTokenNonPunctuator) {\n      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {\n        strippedBody += ' ';\n      }\n    }\n\n    var tokenBody = body.slice(currentToken.start, currentToken.end);\n\n    if (tokenKind === TokenKind.BLOCK_STRING) {\n      strippedBody += dedentBlockString(tokenBody);\n    } else {\n      strippedBody += tokenBody;\n    }\n\n    wasLastAddedTokenNonPunctuator = isNonPunctuator;\n  }\n\n  return strippedBody;\n}\n\nfunction dedentBlockString(blockStr) {\n  // skip leading and trailing triple quotations\n  var rawStr = blockStr.slice(3, -3);\n  var body = dedentBlockStringValue(rawStr);\n  var lines = body.split(/\\r\\n|[\\n\\r]/g);\n\n  if (getBlockStringIndentation(lines) > 0) {\n    body = '\\n' + body;\n  }\n\n  var lastChar = body[body.length - 1];\n  var hasTrailingQuote = lastChar === '\"' && body.slice(-4) !== '\\\\\"\"\"';\n\n  if (hasTrailingQuote || lastChar === '\\\\') {\n    body += '\\n';\n  }\n\n  return '\"\"\"' + body + '\"\"\"';\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAsDO,SAAS,uBAAuB,MAAM;IAC3C,IAAI,YAAY,OAAO,WAAW,WAAW,IAAI,gJAAA,CAAA,SAAM,CAAC,UAAU;IAElE,IAAI,CAAC,CAAC,qBAAqB,gJAAA,CAAA,SAAM,GAAG;QAClC,MAAM,IAAI,UAAU,4CAA4C,MAAM,CAAC,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE,YAAY;IAC7F;IAEA,IAAI,OAAO,UAAU,IAAI;IACzB,IAAI,QAAQ,IAAI,+IAAA,CAAA,QAAK,CAAC;IACtB,IAAI,eAAe;IACnB,IAAI,iCAAiC;IAErC,MAAO,MAAM,OAAO,GAAG,IAAI,KAAK,mJAAA,CAAA,YAAS,CAAC,GAAG,CAAE;QAC7C,IAAI,eAAe,MAAM,KAAK;QAC9B,IAAI,YAAY,aAAa,IAAI;QACjC;;;;KAIC,GAED,IAAI,kBAAkB,CAAC,CAAA,GAAA,+IAAA,CAAA,wBAAqB,AAAD,EAAE,aAAa,IAAI;QAE9D,IAAI,gCAAgC;YAClC,IAAI,mBAAmB,aAAa,IAAI,KAAK,mJAAA,CAAA,YAAS,CAAC,MAAM,EAAE;gBAC7D,gBAAgB;YAClB;QACF;QAEA,IAAI,YAAY,KAAK,KAAK,CAAC,aAAa,KAAK,EAAE,aAAa,GAAG;QAE/D,IAAI,cAAc,mJAAA,CAAA,YAAS,CAAC,YAAY,EAAE;YACxC,gBAAgB,kBAAkB;QACpC,OAAO;YACL,gBAAgB;QAClB;QAEA,iCAAiC;IACnC;IAEA,OAAO;AACT;AAEA,SAAS,kBAAkB,QAAQ;IACjC,8CAA8C;IAC9C,IAAI,SAAS,SAAS,KAAK,CAAC,GAAG,CAAC;IAChC,IAAI,OAAO,CAAA,GAAA,qJAAA,CAAA,yBAAsB,AAAD,EAAE;IAClC,IAAI,QAAQ,KAAK,KAAK,CAAC;IAEvB,IAAI,CAAA,GAAA,qJAAA,CAAA,4BAAyB,AAAD,EAAE,SAAS,GAAG;QACxC,OAAO,OAAO;IAChB;IAEA,IAAI,WAAW,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE;IACpC,IAAI,mBAAmB,aAAa,OAAO,KAAK,KAAK,CAAC,CAAC,OAAO;IAE9D,IAAI,oBAAoB,aAAa,MAAM;QACzC,QAAQ;IACV;IAEA,OAAO,QAAQ,OAAO;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2585, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/findBreakingChanges.mjs"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport keyMap from \"../jsutils/keyMap.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport { print } from \"../language/printer.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\nimport { isSpecifiedScalarType } from \"../type/scalars.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isListType, isNamedType, isRequiredArgument, isRequiredInputField } from \"../type/definition.mjs\";\nimport { astFromValue } from \"./astFromValue.mjs\";\nexport var BreakingChangeType = Object.freeze({\n  TYPE_REMOVED: 'TYPE_REMOVED',\n  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',\n  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',\n  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',\n  REQUIRED_INPUT_FIELD_ADDED: 'REQUIRED_INPUT_FIELD_ADDED',\n  IMPLEMENTED_INTERFACE_REMOVED: 'IMPLEMENTED_INTERFACE_REMOVED',\n  FIELD_REMOVED: 'FIELD_REMOVED',\n  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',\n  REQUIRED_ARG_ADDED: 'REQUIRED_ARG_ADDED',\n  ARG_REMOVED: 'ARG_REMOVED',\n  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',\n  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',\n  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',\n  REQUIRED_DIRECTIVE_ARG_ADDED: 'REQUIRED_DIRECTIVE_ARG_ADDED',\n  DIRECTIVE_REPEATABLE_REMOVED: 'DIRECTIVE_REPEATABLE_REMOVED',\n  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED'\n});\nexport var DangerousChangeType = Object.freeze({\n  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',\n  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',\n  OPTIONAL_INPUT_FIELD_ADDED: 'OPTIONAL_INPUT_FIELD_ADDED',\n  OPTIONAL_ARG_ADDED: 'OPTIONAL_ARG_ADDED',\n  IMPLEMENTED_INTERFACE_ADDED: 'IMPLEMENTED_INTERFACE_ADDED',\n  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE'\n});\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  var breakingChanges = findSchemaChanges(oldSchema, newSchema).filter(function (change) {\n    return change.type in BreakingChangeType;\n  });\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  var dangerousChanges = findSchemaChanges(oldSchema, newSchema).filter(function (change) {\n    return change.type in DangerousChangeType;\n  });\n  return dangerousChanges;\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [].concat(findTypeChanges(oldSchema, newSchema), findDirectiveChanges(oldSchema, newSchema));\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  var schemaChanges = [];\n  var directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());\n\n  for (var _i2 = 0, _directivesDiff$remov2 = directivesDiff.removed; _i2 < _directivesDiff$remov2.length; _i2++) {\n    var oldDirective = _directivesDiff$remov2[_i2];\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: \"\".concat(oldDirective.name, \" was removed.\")\n    });\n  }\n\n  for (var _i4 = 0, _directivesDiff$persi2 = directivesDiff.persisted; _i4 < _directivesDiff$persi2.length; _i4++) {\n    var _ref2 = _directivesDiff$persi2[_i4];\n    var _oldDirective = _ref2[0];\n    var newDirective = _ref2[1];\n    var argsDiff = diff(_oldDirective.args, newDirective.args);\n\n    for (var _i6 = 0, _argsDiff$added2 = argsDiff.added; _i6 < _argsDiff$added2.length; _i6++) {\n      var newArg = _argsDiff$added2[_i6];\n\n      if (isRequiredArgument(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: \"A required arg \".concat(newArg.name, \" on directive \").concat(_oldDirective.name, \" was added.\")\n        });\n      }\n    }\n\n    for (var _i8 = 0, _argsDiff$removed2 = argsDiff.removed; _i8 < _argsDiff$removed2.length; _i8++) {\n      var oldArg = _argsDiff$removed2[_i8];\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: \"\".concat(oldArg.name, \" was removed from \").concat(_oldDirective.name, \".\")\n      });\n    }\n\n    if (_oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: \"Repeatable flag was removed from \".concat(_oldDirective.name, \".\")\n      });\n    }\n\n    for (var _i10 = 0, _oldDirective$locatio2 = _oldDirective.locations; _i10 < _oldDirective$locatio2.length; _i10++) {\n      var location = _oldDirective$locatio2[_i10];\n\n      if (newDirective.locations.indexOf(location) === -1) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: \"\".concat(location, \" was removed from \").concat(_oldDirective.name, \".\")\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  var schemaChanges = [];\n  var typesDiff = diff(objectValues(oldSchema.getTypeMap()), objectValues(newSchema.getTypeMap()));\n\n  for (var _i12 = 0, _typesDiff$removed2 = typesDiff.removed; _i12 < _typesDiff$removed2.length; _i12++) {\n    var oldType = _typesDiff$removed2[_i12];\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: isSpecifiedScalarType(oldType) ? \"Standard scalar \".concat(oldType.name, \" was removed because it is not referenced anymore.\") : \"\".concat(oldType.name, \" was removed.\")\n    });\n  }\n\n  for (var _i14 = 0, _typesDiff$persisted2 = typesDiff.persisted; _i14 < _typesDiff$persisted2.length; _i14++) {\n    var _ref4 = _typesDiff$persisted2[_i14];\n    var _oldType = _ref4[0];\n    var newType = _ref4[1];\n\n    if (isEnumType(_oldType) && isEnumType(newType)) {\n      schemaChanges.push.apply(schemaChanges, findEnumTypeChanges(_oldType, newType));\n    } else if (isUnionType(_oldType) && isUnionType(newType)) {\n      schemaChanges.push.apply(schemaChanges, findUnionTypeChanges(_oldType, newType));\n    } else if (isInputObjectType(_oldType) && isInputObjectType(newType)) {\n      schemaChanges.push.apply(schemaChanges, findInputObjectTypeChanges(_oldType, newType));\n    } else if (isObjectType(_oldType) && isObjectType(newType)) {\n      schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType).concat(findImplementedInterfacesChanges(_oldType, newType)));\n    } else if (isInterfaceType(_oldType) && isInterfaceType(newType)) {\n      schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType).concat(findImplementedInterfacesChanges(_oldType, newType)));\n    } else if (_oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: \"\".concat(_oldType.name, \" changed from \") + \"\".concat(typeKindName(_oldType), \" to \").concat(typeKindName(newType), \".\")\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var fieldsDiff = diff(objectValues(oldType.getFields()), objectValues(newType.getFields()));\n\n  for (var _i16 = 0, _fieldsDiff$added2 = fieldsDiff.added; _i16 < _fieldsDiff$added2.length; _i16++) {\n    var newField = _fieldsDiff$added2[_i16];\n\n    if (isRequiredInputField(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: \"A required field \".concat(newField.name, \" on input type \").concat(oldType.name, \" was added.\")\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: \"An optional field \".concat(newField.name, \" on input type \").concat(oldType.name, \" was added.\")\n      });\n    }\n  }\n\n  for (var _i18 = 0, _fieldsDiff$removed2 = fieldsDiff.removed; _i18 < _fieldsDiff$removed2.length; _i18++) {\n    var oldField = _fieldsDiff$removed2[_i18];\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" was removed.\")\n    });\n  }\n\n  for (var _i20 = 0, _fieldsDiff$persisted2 = fieldsDiff.persisted; _i20 < _fieldsDiff$persisted2.length; _i20++) {\n    var _ref6 = _fieldsDiff$persisted2[_i20];\n    var _oldField = _ref6[0];\n    var _newField = _ref6[1];\n    var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldField.type, _newField.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: \"\".concat(oldType.name, \".\").concat(_oldField.name, \" changed type from \") + \"\".concat(String(_oldField.type), \" to \").concat(String(_newField.type), \".\")\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (var _i22 = 0, _possibleTypesDiff$ad2 = possibleTypesDiff.added; _i22 < _possibleTypesDiff$ad2.length; _i22++) {\n    var newPossibleType = _possibleTypesDiff$ad2[_i22];\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: \"\".concat(newPossibleType.name, \" was added to union type \").concat(oldType.name, \".\")\n    });\n  }\n\n  for (var _i24 = 0, _possibleTypesDiff$re2 = possibleTypesDiff.removed; _i24 < _possibleTypesDiff$re2.length; _i24++) {\n    var oldPossibleType = _possibleTypesDiff$re2[_i24];\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: \"\".concat(oldPossibleType.name, \" was removed from union type \").concat(oldType.name, \".\")\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (var _i26 = 0, _valuesDiff$added2 = valuesDiff.added; _i26 < _valuesDiff$added2.length; _i26++) {\n    var newValue = _valuesDiff$added2[_i26];\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: \"\".concat(newValue.name, \" was added to enum type \").concat(oldType.name, \".\")\n    });\n  }\n\n  for (var _i28 = 0, _valuesDiff$removed2 = valuesDiff.removed; _i28 < _valuesDiff$removed2.length; _i28++) {\n    var oldValue = _valuesDiff$removed2[_i28];\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: \"\".concat(oldValue.name, \" was removed from enum type \").concat(oldType.name, \".\")\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  var schemaChanges = [];\n  var interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (var _i30 = 0, _interfacesDiff$added2 = interfacesDiff.added; _i30 < _interfacesDiff$added2.length; _i30++) {\n    var newInterface = _interfacesDiff$added2[_i30];\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: \"\".concat(newInterface.name, \" added to interfaces implemented by \").concat(oldType.name, \".\")\n    });\n  }\n\n  for (var _i32 = 0, _interfacesDiff$remov2 = interfacesDiff.removed; _i32 < _interfacesDiff$remov2.length; _i32++) {\n    var oldInterface = _interfacesDiff$remov2[_i32];\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: \"\".concat(oldType.name, \" no longer implements interface \").concat(oldInterface.name, \".\")\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  var schemaChanges = [];\n  var fieldsDiff = diff(objectValues(oldType.getFields()), objectValues(newType.getFields()));\n\n  for (var _i34 = 0, _fieldsDiff$removed4 = fieldsDiff.removed; _i34 < _fieldsDiff$removed4.length; _i34++) {\n    var oldField = _fieldsDiff$removed4[_i34];\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" was removed.\")\n    });\n  }\n\n  for (var _i36 = 0, _fieldsDiff$persisted4 = fieldsDiff.persisted; _i36 < _fieldsDiff$persisted4.length; _i36++) {\n    var _ref8 = _fieldsDiff$persisted4[_i36];\n    var _oldField2 = _ref8[0];\n    var newField = _ref8[1];\n    schemaChanges.push.apply(schemaChanges, findArgChanges(oldType, _oldField2, newField));\n    var isSafe = isChangeSafeForObjectOrInterfaceField(_oldField2.type, newField.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: \"\".concat(oldType.name, \".\").concat(_oldField2.name, \" changed type from \") + \"\".concat(String(_oldField2.type), \" to \").concat(String(newField.type), \".\")\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  var schemaChanges = [];\n  var argsDiff = diff(oldField.args, newField.args);\n\n  for (var _i38 = 0, _argsDiff$removed4 = argsDiff.removed; _i38 < _argsDiff$removed4.length; _i38++) {\n    var oldArg = _argsDiff$removed4[_i38];\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(oldArg.name, \" was removed.\")\n    });\n  }\n\n  for (var _i40 = 0, _argsDiff$persisted2 = argsDiff.persisted; _i40 < _argsDiff$persisted2.length; _i40++) {\n    var _ref10 = _argsDiff$persisted2[_i40];\n    var _oldArg = _ref10[0];\n    var newArg = _ref10[1];\n    var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldArg.type, newArg.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" has changed type from \") + \"\".concat(String(_oldArg.type), \" to \").concat(String(newArg.type), \".\")\n      });\n    } else if (_oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" defaultValue was removed.\")\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        var oldValueStr = stringifyValue(_oldArg.defaultValue, _oldArg.type);\n        var newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" has changed defaultValue from \").concat(oldValueStr, \" to \").concat(newValueStr, \".\")\n          });\n        }\n      }\n    }\n  }\n\n  for (var _i42 = 0, _argsDiff$added4 = argsDiff.added; _i42 < _argsDiff$added4.length; _i42++) {\n    var _newArg = _argsDiff$added4[_i42];\n\n    if (isRequiredArgument(_newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: \"A required arg \".concat(_newArg.name, \" on \").concat(oldType.name, \".\").concat(oldField.name, \" was added.\")\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: \"An optional arg \".concat(_newArg.name, \" on \").concat(oldType.name, \".\").concat(oldField.name, \" was added.\")\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return (// if they're both named types, see if their names are equivalent\n    isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n    isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  }\n\n  if (isNonNullType(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  } // if they're both named types, see if their names are equivalent\n\n\n  return isNamedType(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  } // istanbul ignore next (Not reachable. All possible named types have been considered)\n\n\n  false || invariant(0, 'Unexpected type: ' + inspect(type));\n}\n\nfunction stringifyValue(value, type) {\n  var ast = astFromValue(value, type);\n  ast != null || invariant(0);\n  var sortedAST = visit(ast, {\n    ObjectValue: function ObjectValue(objectNode) {\n      var fields = [].concat(objectNode.fields).sort(function (fieldA, fieldB) {\n        return fieldA.name.value.localeCompare(fieldB.name.value);\n      });\n      return _objectSpread(_objectSpread({}, objectNode), {}, {\n        fields: fields\n      });\n    }\n  });\n  return print(sortedAST);\n}\n\nfunction diff(oldArray, newArray) {\n  var added = [];\n  var removed = [];\n  var persisted = [];\n  var oldMap = keyMap(oldArray, function (_ref11) {\n    var name = _ref11.name;\n    return name;\n  });\n  var newMap = keyMap(newArray, function (_ref12) {\n    var name = _ref12.name;\n    return name;\n  });\n\n  for (var _i44 = 0; _i44 < oldArray.length; _i44++) {\n    var oldItem = oldArray[_i44];\n    var newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (var _i46 = 0; _i46 < newArray.length; _i46++) {\n    var _newItem = newArray[_i46];\n\n    if (oldMap[_newItem.name] === undefined) {\n      added.push(_newItem);\n    }\n  }\n\n  return {\n    added: added,\n    persisted: persisted,\n    removed: removed\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3050, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/findDeprecatedUsages.mjs"],"sourcesContent":["import { validate } from \"../validation/validate.mjs\";\nimport { NoDeprecatedCustomRule } from \"../validation/rules/custom/NoDeprecatedCustomRule.mjs\";\n/**\n * A validation rule which reports deprecated usages.\n *\n * Returns a list of GraphQLError instances describing each deprecated use.\n *\n * @deprecated Please use `validate` with `NoDeprecatedCustomRule` instead:\n *\n * ```\n * import { validate, NoDeprecatedCustomRule } from 'graphql'\n *\n * const errors = validate(schema, document, [NoDeprecatedCustomRule])\n * ```\n */\n\nexport function findDeprecatedUsages(schema, ast) {\n  return validate(schema, ast, [NoDeprecatedCustomRule]);\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAeO,SAAS,qBAAqB,MAAM,EAAE,GAAG;IAC9C,OAAO,CAAA,GAAA,oJAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,KAAK;QAAC,qLAAA,CAAA,yBAAsB;KAAC;AACvD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3068, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/valueFromASTUntyped.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.valueFromASTUntyped = valueFromASTUntyped;\n\nvar _inspect = _interopRequireDefault(require(\"../jsutils/inspect\"));\n\nvar _invariant = _interopRequireDefault(require(\"../jsutils/invariant\"));\n\nvar _keyValMap = _interopRequireDefault(require(\"../jsutils/keyValMap\"));\n\nvar _kinds = require(\"../language/kinds\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * Unlike `valueFromAST()`, no type is provided. The resulting JavaScript value\n * will reflect the provided GraphQL value AST.\n *\n * | GraphQL Value        | JavaScript Value |\n * | -------------------- | ---------------- |\n * | Input Object         | Object           |\n * | List                 | Array            |\n * | Boolean              | Boolean          |\n * | String / Enum        | String           |\n * | Int / Float          | Number           |\n * | Null                 | null             |\n *\n */\nfunction valueFromASTUntyped(valueNode, variables) {\n  switch (valueNode.kind) {\n    case _kinds.Kind.NULL:\n      return null;\n\n    case _kinds.Kind.INT:\n      return parseInt(valueNode.value, 10);\n\n    case _kinds.Kind.FLOAT:\n      return parseFloat(valueNode.value);\n\n    case _kinds.Kind.STRING:\n    case _kinds.Kind.ENUM:\n    case _kinds.Kind.BOOLEAN:\n      return valueNode.value;\n\n    case _kinds.Kind.LIST:\n      return valueNode.values.map(function (node) {\n        return valueFromASTUntyped(node, variables);\n      });\n\n    case _kinds.Kind.OBJECT:\n      return (0, _keyValMap.default)(valueNode.fields, function (field) {\n        return field.name.value;\n      }, function (field) {\n        return valueFromASTUntyped(field.value, variables);\n      });\n\n    case _kinds.Kind.VARIABLE:\n      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];\n  } // istanbul ignore next (Not reachable. All possible value nodes have been considered)\n\n\n  false || (0, _invariant.default)(0, 'Unexpected value node: ' + (0, _inspect.default)(valueNode));\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,mBAAmB,GAAG;AAE9B,IAAI,WAAW;AAEf,IAAI,aAAa;AAEjB,IAAI,aAAa;AAEjB,IAAI;AAEJ,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F;;;;;;;;;;;;;;;CAeC,GACD,SAAS,oBAAoB,SAAS,EAAE,SAAS;IAC/C,OAAQ,UAAU,IAAI;QACpB,KAAK,OAAO,IAAI,CAAC,IAAI;YACnB,OAAO;QAET,KAAK,OAAO,IAAI,CAAC,GAAG;YAClB,OAAO,SAAS,UAAU,KAAK,EAAE;QAEnC,KAAK,OAAO,IAAI,CAAC,KAAK;YACpB,OAAO,WAAW,UAAU,KAAK;QAEnC,KAAK,OAAO,IAAI,CAAC,MAAM;QACvB,KAAK,OAAO,IAAI,CAAC,IAAI;QACrB,KAAK,OAAO,IAAI,CAAC,OAAO;YACtB,OAAO,UAAU,KAAK;QAExB,KAAK,OAAO,IAAI,CAAC,IAAI;YACnB,OAAO,UAAU,MAAM,CAAC,GAAG,CAAC,SAAU,IAAI;gBACxC,OAAO,oBAAoB,MAAM;YACnC;QAEF,KAAK,OAAO,IAAI,CAAC,MAAM;YACrB,OAAO,CAAC,GAAG,WAAW,OAAO,EAAE,UAAU,MAAM,EAAE,SAAU,KAAK;gBAC9D,OAAO,MAAM,IAAI,CAAC,KAAK;YACzB,GAAG,SAAU,KAAK;gBAChB,OAAO,oBAAoB,MAAM,KAAK,EAAE;YAC1C;QAEF,KAAK,OAAO,IAAI,CAAC,QAAQ;YACvB,OAAO,cAAc,QAAQ,cAAc,KAAK,IAAI,KAAK,IAAI,SAAS,CAAC,UAAU,IAAI,CAAC,KAAK,CAAC;IAChG,EAAE,sFAAsF;IAGxF,SAAS,CAAC,GAAG,WAAW,OAAO,EAAE,GAAG,4BAA4B,CAAC,GAAG,SAAS,OAAO,EAAE;AACxF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3129, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/astFromValue.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.astFromValue = astFromValue;\n\nvar _isFinite = _interopRequireDefault(require(\"../polyfills/isFinite\"));\n\nvar _arrayFrom3 = _interopRequireDefault(require(\"../polyfills/arrayFrom\"));\n\nvar _objectValues3 = _interopRequireDefault(require(\"../polyfills/objectValues\"));\n\nvar _inspect = _interopRequireDefault(require(\"../jsutils/inspect\"));\n\nvar _invariant = _interopRequireDefault(require(\"../jsutils/invariant\"));\n\nvar _isObjectLike = _interopRequireDefault(require(\"../jsutils/isObjectLike\"));\n\nvar _isCollection = _interopRequireDefault(require(\"../jsutils/isCollection\"));\n\nvar _kinds = require(\"../language/kinds\");\n\nvar _scalars = require(\"../type/scalars\");\n\nvar _definition = require(\"../type/definition\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using suggested GraphQLInputType. For example:\n *\n *     astFromValue(\"value\", GraphQLString)\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * JavaScript values.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String / Enum Value  |\n * | Number        | Int / Float          |\n * | Mixed         | Enum Value           |\n * | null          | NullValue            |\n *\n */\nfunction astFromValue(value, type) {\n  if ((0, _definition.isNonNullType)(type)) {\n    var astValue = astFromValue(value, type.ofType);\n\n    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {\n      return null;\n    }\n\n    return astValue;\n  } // only explicit null, not undefined, NaN\n\n\n  if (value === null) {\n    return {\n      kind: _kinds.Kind.NULL\n    };\n  } // undefined\n\n\n  if (value === undefined) {\n    return null;\n  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n  // the value is not an array, convert the value using the list's item type.\n\n\n  if ((0, _definition.isListType)(type)) {\n    var itemType = type.ofType;\n\n    if ((0, _isCollection.default)(value)) {\n      var valuesNodes = []; // Since we transpile for-of in loose mode it doesn't support iterators\n      // and it's required to first convert iteratable into array\n\n      for (var _i2 = 0, _arrayFrom2 = (0, _arrayFrom3.default)(value); _i2 < _arrayFrom2.length; _i2++) {\n        var item = _arrayFrom2[_i2];\n        var itemNode = astFromValue(item, itemType);\n\n        if (itemNode != null) {\n          valuesNodes.push(itemNode);\n        }\n      }\n\n      return {\n        kind: _kinds.Kind.LIST,\n        values: valuesNodes\n      };\n    }\n\n    return astFromValue(value, itemType);\n  } // Populate the fields of the input object by creating ASTs from each value\n  // in the JavaScript object according to the fields in the input type.\n\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    if (!(0, _isObjectLike.default)(value)) {\n      return null;\n    }\n\n    var fieldNodes = [];\n\n    for (var _i4 = 0, _objectValues2 = (0, _objectValues3.default)(type.getFields()); _i4 < _objectValues2.length; _i4++) {\n      var field = _objectValues2[_i4];\n      var fieldValue = astFromValue(value[field.name], field.type);\n\n      if (fieldValue) {\n        fieldNodes.push({\n          kind: _kinds.Kind.OBJECT_FIELD,\n          name: {\n            kind: _kinds.Kind.NAME,\n            value: field.name\n          },\n          value: fieldValue\n        });\n      }\n    }\n\n    return {\n      kind: _kinds.Kind.OBJECT,\n      fields: fieldNodes\n    };\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if ((0, _definition.isLeafType)(type)) {\n    // Since value is an internally represented value, it must be serialized\n    // to an externally represented value before converting into an AST.\n    var serialized = type.serialize(value);\n\n    if (serialized == null) {\n      return null;\n    } // Others serialize based on their corresponding JavaScript scalar types.\n\n\n    if (typeof serialized === 'boolean') {\n      return {\n        kind: _kinds.Kind.BOOLEAN,\n        value: serialized\n      };\n    } // JavaScript numbers can be Int or Float values.\n\n\n    if (typeof serialized === 'number' && (0, _isFinite.default)(serialized)) {\n      var stringNum = String(serialized);\n      return integerStringRegExp.test(stringNum) ? {\n        kind: _kinds.Kind.INT,\n        value: stringNum\n      } : {\n        kind: _kinds.Kind.FLOAT,\n        value: stringNum\n      };\n    }\n\n    if (typeof serialized === 'string') {\n      // Enum types use Enum literals.\n      if ((0, _definition.isEnumType)(type)) {\n        return {\n          kind: _kinds.Kind.ENUM,\n          value: serialized\n        };\n      } // ID types can use Int literals.\n\n\n      if (type === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {\n        return {\n          kind: _kinds.Kind.INT,\n          value: serialized\n        };\n      }\n\n      return {\n        kind: _kinds.Kind.STRING,\n        value: serialized\n      };\n    }\n\n    throw new TypeError(\"Cannot convert value to AST: \".concat((0, _inspect.default)(serialized), \".\"));\n  } // istanbul ignore next (Not reachable. All possible input types have been considered)\n\n\n  false || (0, _invariant.default)(0, 'Unexpected input type: ' + (0, _inspect.default)(type));\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\n\n\nvar integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3286, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/assertValidName.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertValidName = assertValidName;\nexports.isValidNameError = isValidNameError;\n\nvar _devAssert = _interopRequireDefault(require(\"../jsutils/devAssert\"));\n\nvar _GraphQLError = require(\"../error/GraphQLError\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/**\n * Upholds the spec rules about naming.\n */\n\nfunction assertValidName(name) {\n  var error = isValidNameError(name);\n\n  if (error) {\n    throw error;\n  }\n\n  return name;\n}\n/**\n * Returns an Error if a name is invalid.\n */\n\n\nfunction isValidNameError(name) {\n  typeof name === 'string' || (0, _devAssert.default)(0, 'Expected name to be a string.');\n\n  if (name.length > 1 && name[0] === '_' && name[1] === '_') {\n    return new _GraphQLError.GraphQLError(\"Name \\\"\".concat(name, \"\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\"));\n  }\n\n  if (!NAME_RX.test(name)) {\n    return new _GraphQLError.GraphQLError(\"Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but \\\"\".concat(name, \"\\\" does not.\"));\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,eAAe,GAAG;AAC1B,QAAQ,gBAAgB,GAAG;AAE3B,IAAI,aAAa;AAEjB,IAAI;AAEJ,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F,IAAI,UAAU;AACd;;CAEC,GAED,SAAS,gBAAgB,IAAI;IAC3B,IAAI,QAAQ,iBAAiB;IAE7B,IAAI,OAAO;QACT,MAAM;IACR;IAEA,OAAO;AACT;AACA;;CAEC,GAGD,SAAS,iBAAiB,IAAI;IAC5B,OAAO,SAAS,YAAY,CAAC,GAAG,WAAW,OAAO,EAAE,GAAG;IAEvD,IAAI,KAAK,MAAM,GAAG,KAAK,IAAI,CAAC,EAAE,KAAK,OAAO,IAAI,CAAC,EAAE,KAAK,KAAK;QACzD,OAAO,IAAI,cAAc,YAAY,CAAC,UAAU,MAAM,CAAC,MAAM;IAC/D;IAEA,IAAI,CAAC,QAAQ,IAAI,CAAC,OAAO;QACvB,OAAO,IAAI,cAAc,YAAY,CAAC,qDAAqD,MAAM,CAAC,MAAM;IAC1G;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3325, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/typeComparators.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isEqualType = isEqualType;\nexports.isTypeSubTypeOf = isTypeSubTypeOf;\nexports.doTypesOverlap = doTypesOverlap;\n\nvar _definition = require(\"../type/definition\");\n\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\nfunction isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  } // If either type is non-null, the other must also be non-null.\n\n\n  if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // If either type is a list, the other must also be a list.\n\n\n  if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // Otherwise the types are not equal.\n\n\n  return false;\n}\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\n\nfunction isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  } // If superType is non-null, maybeSubType must also be non-null.\n\n\n  if ((0, _definition.isNonNullType)(superType)) {\n    if ((0, _definition.isNonNullType)(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if ((0, _definition.isNonNullType)(maybeSubType)) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  } // If superType type is a list, maybeSubType type must also be a list.\n\n\n  if ((0, _definition.isListType)(superType)) {\n    if ((0, _definition.isListType)(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if ((0, _definition.isListType)(maybeSubType)) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  } // If superType type is an abstract type, check if it is super type of maybeSubType.\n  // Otherwise, the child type is not a valid subtype of the parent type.\n\n\n  return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);\n}\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\n\n\nfunction doTypesOverlap(schema, typeA, typeB) {\n  // Equivalent types overlap\n  if (typeA === typeB) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(typeA)) {\n    if ((0, _definition.isAbstractType)(typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema.getPossibleTypes(typeA).some(function (type) {\n        return schema.isSubType(typeB, type);\n      });\n    } // Determine if the latter type is a possible concrete type of the former.\n\n\n    return schema.isSubType(typeA, typeB);\n  }\n\n  if ((0, _definition.isAbstractType)(typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isSubType(typeB, typeA);\n  } // Otherwise the types do not overlap.\n\n\n  return false;\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,WAAW,GAAG;AACtB,QAAQ,eAAe,GAAG;AAC1B,QAAQ,cAAc,GAAG;AAEzB,IAAI;AAEJ;;CAEC,GACD,SAAS,YAAY,KAAK,EAAE,KAAK;IAC/B,8BAA8B;IAC9B,IAAI,UAAU,OAAO;QACnB,OAAO;IACT,EAAE,+DAA+D;IAGjE,IAAI,CAAC,GAAG,YAAY,aAAa,EAAE,UAAU,CAAC,GAAG,YAAY,aAAa,EAAE,QAAQ;QAClF,OAAO,YAAY,MAAM,MAAM,EAAE,MAAM,MAAM;IAC/C,EAAE,2DAA2D;IAG7D,IAAI,CAAC,GAAG,YAAY,UAAU,EAAE,UAAU,CAAC,GAAG,YAAY,UAAU,EAAE,QAAQ;QAC5E,OAAO,YAAY,MAAM,MAAM,EAAE,MAAM,MAAM;IAC/C,EAAE,qCAAqC;IAGvC,OAAO;AACT;AACA;;;CAGC,GAGD,SAAS,gBAAgB,MAAM,EAAE,YAAY,EAAE,SAAS;IACtD,qCAAqC;IACrC,IAAI,iBAAiB,WAAW;QAC9B,OAAO;IACT,EAAE,gEAAgE;IAGlE,IAAI,CAAC,GAAG,YAAY,aAAa,EAAE,YAAY;QAC7C,IAAI,CAAC,GAAG,YAAY,aAAa,EAAE,eAAe;YAChD,OAAO,gBAAgB,QAAQ,aAAa,MAAM,EAAE,UAAU,MAAM;QACtE;QAEA,OAAO;IACT;IAEA,IAAI,CAAC,GAAG,YAAY,aAAa,EAAE,eAAe;QAChD,sEAAsE;QACtE,OAAO,gBAAgB,QAAQ,aAAa,MAAM,EAAE;IACtD,EAAE,sEAAsE;IAGxE,IAAI,CAAC,GAAG,YAAY,UAAU,EAAE,YAAY;QAC1C,IAAI,CAAC,GAAG,YAAY,UAAU,EAAE,eAAe;YAC7C,OAAO,gBAAgB,QAAQ,aAAa,MAAM,EAAE,UAAU,MAAM;QACtE;QAEA,OAAO;IACT;IAEA,IAAI,CAAC,GAAG,YAAY,UAAU,EAAE,eAAe;QAC7C,oEAAoE;QACpE,OAAO;IACT,EAAE,oFAAoF;IACtF,uEAAuE;IAGvE,OAAO,CAAC,GAAG,YAAY,cAAc,EAAE,cAAc,CAAC,CAAC,GAAG,YAAY,eAAe,EAAE,iBAAiB,CAAC,GAAG,YAAY,YAAY,EAAE,aAAa,KAAK,OAAO,SAAS,CAAC,WAAW;AACtL;AACA;;;;;;;;CAQC,GAGD,SAAS,eAAe,MAAM,EAAE,KAAK,EAAE,KAAK;IAC1C,2BAA2B;IAC3B,IAAI,UAAU,OAAO;QACnB,OAAO;IACT;IAEA,IAAI,CAAC,GAAG,YAAY,cAAc,EAAE,QAAQ;QAC1C,IAAI,CAAC,GAAG,YAAY,cAAc,EAAE,QAAQ;YAC1C,0EAA0E;YAC1E,2CAA2C;YAC3C,OAAO,OAAO,gBAAgB,CAAC,OAAO,IAAI,CAAC,SAAU,IAAI;gBACvD,OAAO,OAAO,SAAS,CAAC,OAAO;YACjC;QACF,EAAE,0EAA0E;QAG5E,OAAO,OAAO,SAAS,CAAC,OAAO;IACjC;IAEA,IAAI,CAAC,GAAG,YAAY,cAAc,EAAE,QAAQ;QAC1C,0EAA0E;QAC1E,OAAO,OAAO,SAAS,CAAC,OAAO;IACjC,EAAE,sCAAsC;IAGxC,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3413, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/typeFromAST.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeFromAST = typeFromAST;\n\nvar _inspect = _interopRequireDefault(require(\"../jsutils/inspect\"));\n\nvar _invariant = _interopRequireDefault(require(\"../jsutils/invariant\"));\n\nvar _kinds = require(\"../language/kinds\");\n\nvar _definition = require(\"../type/definition\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction typeFromAST(schema, typeNode) {\n  /* eslint-enable no-redeclare */\n  var innerType;\n\n  if (typeNode.kind === _kinds.Kind.LIST_TYPE) {\n    innerType = typeFromAST(schema, typeNode.type);\n    return innerType && (0, _definition.GraphQLList)(innerType);\n  }\n\n  if (typeNode.kind === _kinds.Kind.NON_NULL_TYPE) {\n    innerType = typeFromAST(schema, typeNode.type);\n    return innerType && (0, _definition.GraphQLNonNull)(innerType);\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (typeNode.kind === _kinds.Kind.NAMED_TYPE) {\n    return schema.getType(typeNode.name.value);\n  } // istanbul ignore next (Not reachable. All possible type nodes have been considered)\n\n\n  false || (0, _invariant.default)(0, 'Unexpected type node: ' + (0, _inspect.default)(typeNode));\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,WAAW,GAAG;AAEtB,IAAI,WAAW;AAEf,IAAI,aAAa;AAEjB,IAAI;AAEJ,IAAI;AAEJ,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F,SAAS,YAAY,MAAM,EAAE,QAAQ;IACnC,8BAA8B,GAC9B,IAAI;IAEJ,IAAI,SAAS,IAAI,KAAK,OAAO,IAAI,CAAC,SAAS,EAAE;QAC3C,YAAY,YAAY,QAAQ,SAAS,IAAI;QAC7C,OAAO,aAAa,CAAC,GAAG,YAAY,WAAW,EAAE;IACnD;IAEA,IAAI,SAAS,IAAI,KAAK,OAAO,IAAI,CAAC,aAAa,EAAE;QAC/C,YAAY,YAAY,QAAQ,SAAS,IAAI;QAC7C,OAAO,aAAa,CAAC,GAAG,YAAY,cAAc,EAAE;IACtD,EAAE,kFAAkF;IAGpF,IAAI,SAAS,IAAI,KAAK,OAAO,IAAI,CAAC,UAAU,EAAE;QAC5C,OAAO,OAAO,OAAO,CAAC,SAAS,IAAI,CAAC,KAAK;IAC3C,EAAE,qFAAqF;IAGvF,SAAS,CAAC,GAAG,WAAW,OAAO,EAAE,GAAG,2BAA2B,CAAC,GAAG,SAAS,OAAO,EAAE;AACvF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3447, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/getOperationRootType.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOperationRootType = getOperationRootType;\n\nvar _GraphQLError = require(\"../error/GraphQLError\");\n\n/**\n * Extracts the root type of the operation from the schema.\n */\nfunction getOperationRootType(schema, operation) {\n  if (operation.operation === 'query') {\n    var queryType = schema.getQueryType();\n\n    if (!queryType) {\n      throw new _GraphQLError.GraphQLError('Schema does not define the required query root type.', operation);\n    }\n\n    return queryType;\n  }\n\n  if (operation.operation === 'mutation') {\n    var mutationType = schema.getMutationType();\n\n    if (!mutationType) {\n      throw new _GraphQLError.GraphQLError('Schema is not configured for mutations.', operation);\n    }\n\n    return mutationType;\n  }\n\n  if (operation.operation === 'subscription') {\n    var subscriptionType = schema.getSubscriptionType();\n\n    if (!subscriptionType) {\n      throw new _GraphQLError.GraphQLError('Schema is not configured for subscriptions.', operation);\n    }\n\n    return subscriptionType;\n  }\n\n  throw new _GraphQLError.GraphQLError('Can only have query, mutation and subscription operations.', operation);\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,oBAAoB,GAAG;AAE/B,IAAI;AAEJ;;CAEC,GACD,SAAS,qBAAqB,MAAM,EAAE,SAAS;IAC7C,IAAI,UAAU,SAAS,KAAK,SAAS;QACnC,IAAI,YAAY,OAAO,YAAY;QAEnC,IAAI,CAAC,WAAW;YACd,MAAM,IAAI,cAAc,YAAY,CAAC,wDAAwD;QAC/F;QAEA,OAAO;IACT;IAEA,IAAI,UAAU,SAAS,KAAK,YAAY;QACtC,IAAI,eAAe,OAAO,eAAe;QAEzC,IAAI,CAAC,cAAc;YACjB,MAAM,IAAI,cAAc,YAAY,CAAC,2CAA2C;QAClF;QAEA,OAAO;IACT;IAEA,IAAI,UAAU,SAAS,KAAK,gBAAgB;QAC1C,IAAI,mBAAmB,OAAO,mBAAmB;QAEjD,IAAI,CAAC,kBAAkB;YACrB,MAAM,IAAI,cAAc,YAAY,CAAC,+CAA+C;QACtF;QAEA,OAAO;IACT;IAEA,MAAM,IAAI,cAAc,YAAY,CAAC,8DAA8D;AACrG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3484, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/valueFromAST.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.valueFromAST = valueFromAST;\n\nvar _objectValues3 = _interopRequireDefault(require(\"../polyfills/objectValues\"));\n\nvar _keyMap = _interopRequireDefault(require(\"../jsutils/keyMap\"));\n\nvar _inspect = _interopRequireDefault(require(\"../jsutils/inspect\"));\n\nvar _invariant = _interopRequireDefault(require(\"../jsutils/invariant\"));\n\nvar _kinds = require(\"../language/kinds\");\n\nvar _definition = require(\"../type/definition\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Mixed         |\n * | NullValue            | null          |\n *\n */\nfunction valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n\n  if (valueNode.kind === _kinds.Kind.VARIABLE) {\n    var variableName = valueNode.name.value;\n\n    if (variables == null || variables[variableName] === undefined) {\n      // No valid return value.\n      return;\n    }\n\n    var variableValue = variables[variableName];\n\n    if (variableValue === null && (0, _definition.isNonNullType)(type)) {\n      return; // Invalid: intentionally return no value.\n    } // Note: This does no further checking that this variable is correct.\n    // This assumes that this query has been validated and the variable\n    // usage here is of the correct type.\n\n\n    return variableValue;\n  }\n\n  if ((0, _definition.isNonNullType)(type)) {\n    if (valueNode.kind === _kinds.Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n\n  if (valueNode.kind === _kinds.Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n\n  if ((0, _definition.isListType)(type)) {\n    var itemType = type.ofType;\n\n    if (valueNode.kind === _kinds.Kind.LIST) {\n      var coercedValues = [];\n\n      for (var _i2 = 0, _valueNode$values2 = valueNode.values; _i2 < _valueNode$values2.length; _i2++) {\n        var itemNode = _valueNode$values2[_i2];\n\n        if (isMissingVariable(itemNode, variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if ((0, _definition.isNonNullType)(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(null);\n        } else {\n          var itemValue = valueFromAST(itemNode, itemType, variables);\n\n          if (itemValue === undefined) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(itemValue);\n        }\n      }\n\n      return coercedValues;\n    }\n\n    var coercedValue = valueFromAST(valueNode, itemType, variables);\n\n    if (coercedValue === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return [coercedValue];\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    if (valueNode.kind !== _kinds.Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    var coercedObj = Object.create(null);\n    var fieldNodes = (0, _keyMap.default)(valueNode.fields, function (field) {\n      return field.name.value;\n    });\n\n    for (var _i4 = 0, _objectValues2 = (0, _objectValues3.default)(type.getFields()); _i4 < _objectValues2.length; _i4++) {\n      var field = _objectValues2[_i4];\n      var fieldNode = fieldNodes[field.name];\n\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== undefined) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if ((0, _definition.isNonNullType)(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n\n        continue;\n      }\n\n      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n\n      if (fieldValue === undefined) {\n        return; // Invalid: intentionally return no value.\n      }\n\n      coercedObj[field.name] = fieldValue;\n    }\n\n    return coercedObj;\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if ((0, _definition.isLeafType)(type)) {\n    // Scalars and Enums fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    var result;\n\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    if (result === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return result;\n  } // istanbul ignore next (Not reachable. All possible input types have been considered)\n\n\n  false || (0, _invariant.default)(0, 'Unexpected input type: ' + (0, _inspect.default)(type));\n} // Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\n\n\nfunction isMissingVariable(valueNode, variables) {\n  return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3633, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/coerceInputValue.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.coerceInputValue = coerceInputValue;\n\nvar _arrayFrom = _interopRequireDefault(require(\"../polyfills/arrayFrom\"));\n\nvar _objectValues3 = _interopRequireDefault(require(\"../polyfills/objectValues\"));\n\nvar _inspect = _interopRequireDefault(require(\"../jsutils/inspect\"));\n\nvar _invariant = _interopRequireDefault(require(\"../jsutils/invariant\"));\n\nvar _didYouMean = _interopRequireDefault(require(\"../jsutils/didYouMean\"));\n\nvar _isObjectLike = _interopRequireDefault(require(\"../jsutils/isObjectLike\"));\n\nvar _isCollection = _interopRequireDefault(require(\"../jsutils/isCollection\"));\n\nvar _suggestionList = _interopRequireDefault(require(\"../jsutils/suggestionList\"));\n\nvar _printPathArray = _interopRequireDefault(require(\"../jsutils/printPathArray\"));\n\nvar _Path = require(\"../jsutils/Path\");\n\nvar _GraphQLError = require(\"../error/GraphQLError\");\n\nvar _definition = require(\"../type/definition\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Coerces a JavaScript value given a GraphQL Input Type.\n */\nfunction coerceInputValue(inputValue, type) {\n  var onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOnError;\n  return coerceInputValueImpl(inputValue, type, onError);\n}\n\nfunction defaultOnError(path, invalidValue, error) {\n  var errorPrefix = 'Invalid value ' + (0, _inspect.default)(invalidValue);\n\n  if (path.length > 0) {\n    errorPrefix += \" at \\\"value\".concat((0, _printPathArray.default)(path), \"\\\"\");\n  }\n\n  error.message = errorPrefix + ': ' + error.message;\n  throw error;\n}\n\nfunction coerceInputValueImpl(inputValue, type, onError, path) {\n  if ((0, _definition.isNonNullType)(type)) {\n    if (inputValue != null) {\n      return coerceInputValueImpl(inputValue, type.ofType, onError, path);\n    }\n\n    onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(\"Expected non-nullable type \\\"\".concat((0, _inspect.default)(type), \"\\\" not to be null.\")));\n    return;\n  }\n\n  if (inputValue == null) {\n    // Explicitly return the value null.\n    return null;\n  }\n\n  if ((0, _definition.isListType)(type)) {\n    var itemType = type.ofType;\n\n    if ((0, _isCollection.default)(inputValue)) {\n      return (0, _arrayFrom.default)(inputValue, function (itemValue, index) {\n        var itemPath = (0, _Path.addPath)(path, index, undefined);\n        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);\n      });\n    } // Lists accept a non-list value as a list of one.\n\n\n    return [coerceInputValueImpl(inputValue, itemType, onError, path)];\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    if (!(0, _isObjectLike.default)(inputValue)) {\n      onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(\"Expected type \\\"\".concat(type.name, \"\\\" to be an object.\")));\n      return;\n    }\n\n    var coercedValue = {};\n    var fieldDefs = type.getFields();\n\n    for (var _i2 = 0, _objectValues2 = (0, _objectValues3.default)(fieldDefs); _i2 < _objectValues2.length; _i2++) {\n      var field = _objectValues2[_i2];\n      var fieldValue = inputValue[field.name];\n\n      if (fieldValue === undefined) {\n        if (field.defaultValue !== undefined) {\n          coercedValue[field.name] = field.defaultValue;\n        } else if ((0, _definition.isNonNullType)(field.type)) {\n          var typeStr = (0, _inspect.default)(field.type);\n          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(\"Field \\\"\".concat(field.name, \"\\\" of required type \\\"\").concat(typeStr, \"\\\" was not provided.\")));\n        }\n\n        continue;\n      }\n\n      coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, (0, _Path.addPath)(path, field.name, type.name));\n    } // Ensure every provided field is defined.\n\n\n    for (var _i4 = 0, _Object$keys2 = Object.keys(inputValue); _i4 < _Object$keys2.length; _i4++) {\n      var fieldName = _Object$keys2[_i4];\n\n      if (!fieldDefs[fieldName]) {\n        var suggestions = (0, _suggestionList.default)(fieldName, Object.keys(type.getFields()));\n        onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(\"Field \\\"\".concat(fieldName, \"\\\" is not defined by type \\\"\").concat(type.name, \"\\\".\") + (0, _didYouMean.default)(suggestions)));\n      }\n    }\n\n    return coercedValue;\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if ((0, _definition.isLeafType)(type)) {\n    var parseResult; // Scalars and Enums determine if a input value is valid via parseValue(),\n    // which can throw to indicate failure. If it throws, maintain a reference\n    // to the original error.\n\n    try {\n      parseResult = type.parseValue(inputValue);\n    } catch (error) {\n      if (error instanceof _GraphQLError.GraphQLError) {\n        onError((0, _Path.pathToArray)(path), inputValue, error);\n      } else {\n        onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(\"Expected type \\\"\".concat(type.name, \"\\\". \") + error.message, undefined, undefined, undefined, undefined, error));\n      }\n\n      return;\n    }\n\n    if (parseResult === undefined) {\n      onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(\"Expected type \\\"\".concat(type.name, \"\\\".\")));\n    }\n\n    return parseResult;\n  } // istanbul ignore next (Not reachable. All possible input types have been considered)\n\n\n  false || (0, _invariant.default)(0, 'Unexpected input type: ' + (0, _inspect.default)(type));\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3749, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/getIntrospectionQuery.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getIntrospectionQuery = getIntrospectionQuery;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction getIntrospectionQuery(options) {\n  var optionsWithDefault = _objectSpread({\n    descriptions: true,\n    specifiedByUrl: false,\n    directiveIsRepeatable: false,\n    schemaDescription: false\n  }, options);\n\n  var descriptions = optionsWithDefault.descriptions ? 'description' : '';\n  var specifiedByUrl = optionsWithDefault.specifiedByUrl ? 'specifiedByUrl' : '';\n  var directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? 'isRepeatable' : '';\n  var schemaDescription = optionsWithDefault.schemaDescription ? descriptions : '';\n  return \"\\n    query IntrospectionQuery {\\n      __schema {\\n        \".concat(schemaDescription, \"\\n        queryType { name }\\n        mutationType { name }\\n        subscriptionType { name }\\n        types {\\n          ...FullType\\n        }\\n        directives {\\n          name\\n          \").concat(descriptions, \"\\n          \").concat(directiveIsRepeatable, \"\\n          locations\\n          args {\\n            ...InputValue\\n          }\\n        }\\n      }\\n    }\\n\\n    fragment FullType on __Type {\\n      kind\\n      name\\n      \").concat(descriptions, \"\\n      \").concat(specifiedByUrl, \"\\n      fields(includeDeprecated: true) {\\n        name\\n        \").concat(descriptions, \"\\n        args {\\n          ...InputValue\\n        }\\n        type {\\n          ...TypeRef\\n        }\\n        isDeprecated\\n        deprecationReason\\n      }\\n      inputFields {\\n        ...InputValue\\n      }\\n      interfaces {\\n        ...TypeRef\\n      }\\n      enumValues(includeDeprecated: true) {\\n        name\\n        \").concat(descriptions, \"\\n        isDeprecated\\n        deprecationReason\\n      }\\n      possibleTypes {\\n        ...TypeRef\\n      }\\n    }\\n\\n    fragment InputValue on __InputValue {\\n      name\\n      \").concat(descriptions, \"\\n      type { ...TypeRef }\\n      defaultValue\\n    }\\n\\n    fragment TypeRef on __Type {\\n      kind\\n      name\\n      ofType {\\n        kind\\n        name\\n        ofType {\\n          kind\\n          name\\n          ofType {\\n            kind\\n            name\\n            ofType {\\n              kind\\n              name\\n              ofType {\\n                kind\\n                name\\n                ofType {\\n                  kind\\n                  name\\n                  ofType {\\n                    kind\\n                    name\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  \");\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,qBAAqB,GAAG;AAEhC,SAAS,QAAQ,MAAM,EAAE,cAAc;IAAI,IAAI,OAAO,OAAO,IAAI,CAAC;IAAS,IAAI,OAAO,qBAAqB,EAAE;QAAE,IAAI,UAAU,OAAO,qBAAqB,CAAC;QAAS,IAAI,gBAAgB,UAAU,QAAQ,MAAM,CAAC,SAAU,GAAG;YAAI,OAAO,OAAO,wBAAwB,CAAC,QAAQ,KAAK,UAAU;QAAE;QAAI,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM;IAAU;IAAE,OAAO;AAAM;AAEpV,SAAS,cAAc,MAAM;IAAI,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;QAAE,IAAI,SAAS,SAAS,CAAC,EAAE,IAAI,OAAO,SAAS,CAAC,EAAE,GAAG,CAAC;QAAG,IAAI,IAAI,GAAG;YAAE,QAAQ,OAAO,SAAS,MAAM,OAAO,CAAC,SAAU,GAAG;gBAAI,gBAAgB,QAAQ,KAAK,MAAM,CAAC,IAAI;YAAG;QAAI,OAAO,IAAI,OAAO,yBAAyB,EAAE;YAAE,OAAO,gBAAgB,CAAC,QAAQ,OAAO,yBAAyB,CAAC;QAAU,OAAO;YAAE,QAAQ,OAAO,SAAS,OAAO,CAAC,SAAU,GAAG;gBAAI,OAAO,cAAc,CAAC,QAAQ,KAAK,OAAO,wBAAwB,CAAC,QAAQ;YAAO;QAAI;IAAE;IAAE,OAAO;AAAQ;AAErhB,SAAS,gBAAgB,GAAG,EAAE,GAAG,EAAE,KAAK;IAAI,IAAI,OAAO,KAAK;QAAE,OAAO,cAAc,CAAC,KAAK,KAAK;YAAE,OAAO;YAAO,YAAY;YAAM,cAAc;YAAM,UAAU;QAAK;IAAI,OAAO;QAAE,GAAG,CAAC,IAAI,GAAG;IAAO;IAAE,OAAO;AAAK;AAEhN,SAAS,sBAAsB,OAAO;IACpC,IAAI,qBAAqB,cAAc;QACrC,cAAc;QACd,gBAAgB;QAChB,uBAAuB;QACvB,mBAAmB;IACrB,GAAG;IAEH,IAAI,eAAe,mBAAmB,YAAY,GAAG,gBAAgB;IACrE,IAAI,iBAAiB,mBAAmB,cAAc,GAAG,mBAAmB;IAC5E,IAAI,wBAAwB,mBAAmB,qBAAqB,GAAG,iBAAiB;IACxF,IAAI,oBAAoB,mBAAmB,iBAAiB,GAAG,eAAe;IAC9E,OAAO,+DAA+D,MAAM,CAAC,mBAAmB,uMAAuM,MAAM,CAAC,cAAc,gBAAgB,MAAM,CAAC,uBAAuB,mLAAmL,MAAM,CAAC,cAAc,YAAY,MAAM,CAAC,gBAAgB,qEAAqE,MAAM,CAAC,cAAc,8UAA8U,MAAM,CAAC,cAAc,0LAA0L,MAAM,CAAC,cAAc;AACnuC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3813, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/getOperationAST.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOperationAST = getOperationAST;\n\nvar _kinds = require(\"../language/kinds\");\n\n/**\n * Returns an operation AST given a document AST and optionally an operation\n * name. If a name is not provided, an operation is only returned if only one is\n * provided in the document.\n */\nfunction getOperationAST(documentAST, operationName) {\n  var operation = null;\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var definition = _documentAST$definiti2[_i2];\n\n    if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {\n      var _definition$name;\n\n      if (operationName == null) {\n        // If no operation name was provided, only return an Operation if there\n        // is one defined in the document. Upon encountering the second, return\n        // null.\n        if (operation) {\n          return null;\n        }\n\n        operation = definition;\n      } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {\n        return definition;\n      }\n    }\n  }\n\n  return operation;\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,eAAe,GAAG;AAE1B,IAAI;AAEJ;;;;CAIC,GACD,SAAS,gBAAgB,WAAW,EAAE,aAAa;IACjD,IAAI,YAAY;IAEhB,IAAK,IAAI,MAAM,GAAG,yBAAyB,YAAY,WAAW,EAAE,MAAM,uBAAuB,MAAM,EAAE,MAAO;QAC9G,IAAI,aAAa,sBAAsB,CAAC,IAAI;QAE5C,IAAI,WAAW,IAAI,KAAK,OAAO,IAAI,CAAC,oBAAoB,EAAE;YACxD,IAAI;YAEJ,IAAI,iBAAiB,MAAM;gBACzB,uEAAuE;gBACvE,uEAAuE;gBACvE,QAAQ;gBACR,IAAI,WAAW;oBACb,OAAO;gBACT;gBAEA,YAAY;YACd,OAAO,IAAI,CAAC,CAAC,mBAAmB,WAAW,IAAI,MAAM,QAAQ,qBAAqB,KAAK,IAAI,KAAK,IAAI,iBAAiB,KAAK,MAAM,eAAe;gBAC7I,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3849, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/introspectionFromSchema.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.introspectionFromSchema = introspectionFromSchema;\n\nvar _invariant = _interopRequireDefault(require(\"../jsutils/invariant\"));\n\nvar _parser = require(\"../language/parser\");\n\nvar _execute = require(\"../execution/execute\");\n\nvar _getIntrospectionQuery = require(\"./getIntrospectionQuery\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Build an IntrospectionQuery from a GraphQLSchema\n *\n * IntrospectionQuery is useful for utilities that care about type and field\n * relationships, but do not need to traverse through those relationships.\n *\n * This is the inverse of buildClientSchema. The primary use case is outside\n * of the server context, for instance when doing schema comparisons.\n */\nfunction introspectionFromSchema(schema, options) {\n  var optionsWithDefaults = _objectSpread({\n    directiveIsRepeatable: true,\n    schemaDescription: true\n  }, options);\n\n  var document = (0, _parser.parse)((0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults));\n  var result = (0, _execute.executeSync)({\n    schema: schema,\n    document: document\n  });\n  !result.errors && result.data || (0, _invariant.default)(0);\n  return result.data;\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,uBAAuB,GAAG;AAElC,IAAI,aAAa;AAEjB,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F,SAAS,QAAQ,MAAM,EAAE,cAAc;IAAI,IAAI,OAAO,OAAO,IAAI,CAAC;IAAS,IAAI,OAAO,qBAAqB,EAAE;QAAE,IAAI,UAAU,OAAO,qBAAqB,CAAC;QAAS,IAAI,gBAAgB,UAAU,QAAQ,MAAM,CAAC,SAAU,GAAG;YAAI,OAAO,OAAO,wBAAwB,CAAC,QAAQ,KAAK,UAAU;QAAE;QAAI,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM;IAAU;IAAE,OAAO;AAAM;AAEpV,SAAS,cAAc,MAAM;IAAI,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;QAAE,IAAI,SAAS,SAAS,CAAC,EAAE,IAAI,OAAO,SAAS,CAAC,EAAE,GAAG,CAAC;QAAG,IAAI,IAAI,GAAG;YAAE,QAAQ,OAAO,SAAS,MAAM,OAAO,CAAC,SAAU,GAAG;gBAAI,gBAAgB,QAAQ,KAAK,MAAM,CAAC,IAAI;YAAG;QAAI,OAAO,IAAI,OAAO,yBAAyB,EAAE;YAAE,OAAO,gBAAgB,CAAC,QAAQ,OAAO,yBAAyB,CAAC;QAAU,OAAO;YAAE,QAAQ,OAAO,SAAS,OAAO,CAAC,SAAU,GAAG;gBAAI,OAAO,cAAc,CAAC,QAAQ,KAAK,OAAO,wBAAwB,CAAC,QAAQ;YAAO;QAAI;IAAE;IAAE,OAAO;AAAQ;AAErhB,SAAS,gBAAgB,GAAG,EAAE,GAAG,EAAE,KAAK;IAAI,IAAI,OAAO,KAAK;QAAE,OAAO,cAAc,CAAC,KAAK,KAAK;YAAE,OAAO;YAAO,YAAY;YAAM,cAAc;YAAM,UAAU;QAAK;IAAI,OAAO;QAAE,GAAG,CAAC,IAAI,GAAG;IAAO;IAAE,OAAO;AAAK;AAEhN;;;;;;;;CAQC,GACD,SAAS,wBAAwB,MAAM,EAAE,OAAO;IAC9C,IAAI,sBAAsB,cAAc;QACtC,uBAAuB;QACvB,mBAAmB;IACrB,GAAG;IAEH,IAAI,WAAW,CAAC,GAAG,QAAQ,KAAK,EAAE,CAAC,GAAG,uBAAuB,qBAAqB,EAAE;IACpF,IAAI,SAAS,CAAC,GAAG,SAAS,WAAW,EAAE;QACrC,QAAQ;QACR,UAAU;IACZ;IACA,CAAC,OAAO,MAAM,IAAI,OAAO,IAAI,IAAI,CAAC,GAAG,WAAW,OAAO,EAAE;IACzD,OAAO,OAAO,IAAI;AACpB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3930, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/buildClientSchema.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildClientSchema = buildClientSchema;\n\nvar _objectValues = _interopRequireDefault(require(\"../polyfills/objectValues\"));\n\nvar _inspect = _interopRequireDefault(require(\"../jsutils/inspect\"));\n\nvar _devAssert = _interopRequireDefault(require(\"../jsutils/devAssert\"));\n\nvar _keyValMap = _interopRequireDefault(require(\"../jsutils/keyValMap\"));\n\nvar _isObjectLike = _interopRequireDefault(require(\"../jsutils/isObjectLike\"));\n\nvar _parser = require(\"../language/parser\");\n\nvar _schema = require(\"../type/schema\");\n\nvar _directives = require(\"../type/directives\");\n\nvar _scalars = require(\"../type/scalars\");\n\nvar _introspection = require(\"../type/introspection\");\n\nvar _definition = require(\"../type/definition\");\n\nvar _valueFromAST = require(\"./valueFromAST\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\nfunction buildClientSchema(introspection, options) {\n  (0, _isObjectLike.default)(introspection) && (0, _isObjectLike.default)(introspection.__schema) || (0, _devAssert.default)(0, \"Invalid or incomplete introspection result. Ensure that you are passing \\\"data\\\" property of introspection response and no \\\"errors\\\" was returned alongside: \".concat((0, _inspect.default)(introspection), \".\")); // Get the schema from the introspection result.\n\n  var schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  var typeMap = (0, _keyValMap.default)(schemaIntrospection.types, function (typeIntrospection) {\n    return typeIntrospection.name;\n  }, function (typeIntrospection) {\n    return buildType(typeIntrospection);\n  }); // Include standard types only if they are used.\n\n  for (var _i2 = 0, _ref2 = [].concat(_scalars.specifiedScalarTypes, _introspection.introspectionTypes); _i2 < _ref2.length; _i2++) {\n    var stdType = _ref2[_i2];\n\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new _schema.GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: (0, _objectValues.default)(typeMap),\n    directives: directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === _introspection.TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return (0, _definition.GraphQLList)(getType(itemRef));\n    }\n\n    if (typeRef.kind === _introspection.TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return (0, _definition.GraphQLNonNull)((0, _definition.assertNullableType)(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    var typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(\"Unknown type reference: \".concat((0, _inspect.default)(typeRef), \".\"));\n    }\n\n    var type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure that a full introspection query is used in order to build a client schema.\"));\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return (0, _definition.assertObjectType)(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return (0, _definition.assertInterfaceType)(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type != null && type.name != null && type.kind != null) {\n      switch (type.kind) {\n        case _introspection.TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case _introspection.TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case _introspection.TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case _introspection.TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case _introspection.TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case _introspection.TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    var typeStr = (0, _inspect.default)(type);\n    throw new Error(\"Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: \".concat(typeStr, \".\"));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new _definition.GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByUrl: scalarIntrospection.specifiedByUrl\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      var implementingIntrospectionStr = (0, _inspect.default)(implementingIntrospection);\n      throw new Error(\"Introspection result missing interfaces: \".concat(implementingIntrospectionStr, \".\"));\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new _definition.GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(objectIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new _definition.GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(interfaceIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      var unionIntrospectionStr = (0, _inspect.default)(unionIntrospection);\n      throw new Error(\"Introspection result missing possibleTypes: \".concat(unionIntrospectionStr, \".\"));\n    }\n\n    return new _definition.GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      var enumIntrospectionStr = (0, _inspect.default)(enumIntrospection);\n      throw new Error(\"Introspection result missing enumValues: \".concat(enumIntrospectionStr, \".\"));\n    }\n\n    return new _definition.GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: (0, _keyValMap.default)(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      var inputObjectIntrospectionStr = (0, _inspect.default)(inputObjectIntrospection);\n      throw new Error(\"Introspection result missing inputFields: \".concat(inputObjectIntrospectionStr, \".\"));\n    }\n\n    return new _definition.GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\"Introspection result missing fields: \".concat((0, _inspect.default)(typeIntrospection), \".\"));\n    }\n\n    return (0, _keyValMap.default)(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, buildField);\n  }\n\n  function buildField(fieldIntrospection) {\n    var type = getType(fieldIntrospection.type);\n\n    if (!(0, _definition.isOutputType)(type)) {\n      var typeStr = (0, _inspect.default)(type);\n      throw new Error(\"Introspection must provide output type for fields, but received: \".concat(typeStr, \".\"));\n    }\n\n    if (!fieldIntrospection.args) {\n      var fieldIntrospectionStr = (0, _inspect.default)(fieldIntrospection);\n      throw new Error(\"Introspection result missing field args: \".concat(fieldIntrospectionStr, \".\"));\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type: type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return (0, _keyValMap.default)(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getType(inputValueIntrospection.type);\n\n    if (!(0, _definition.isInputType)(type)) {\n      var typeStr = (0, _inspect.default)(type);\n      throw new Error(\"Introspection must provide input type for arguments, but received: \".concat(typeStr, \".\"));\n    }\n\n    var defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      var directiveIntrospectionStr = (0, _inspect.default)(directiveIntrospection);\n      throw new Error(\"Introspection result missing directive args: \".concat(directiveIntrospectionStr, \".\"));\n    }\n\n    if (!directiveIntrospection.locations) {\n      var _directiveIntrospectionStr = (0, _inspect.default)(directiveIntrospection);\n\n      throw new Error(\"Introspection result missing directive locations: \".concat(_directiveIntrospectionStr, \".\"));\n    }\n\n    return new _directives.GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4203, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/TypeInfo.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visitWithTypeInfo = visitWithTypeInfo;\nexports.TypeInfo = void 0;\n\nvar _find = _interopRequireDefault(require(\"../polyfills/find\"));\n\nvar _kinds = require(\"../language/kinds\");\n\nvar _ast = require(\"../language/ast\");\n\nvar _visitor = require(\"../language/visitor\");\n\nvar _definition = require(\"../type/definition\");\n\nvar _introspection = require(\"../type/introspection\");\n\nvar _typeFromAST = require(\"./typeFromAST\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\nvar TypeInfo = /*#__PURE__*/function () {\n  function TypeInfo(schema, // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant code bases. You should never need to use it.\n  // It may disappear in the future.\n  getFieldDefFn, // Initial type may be provided in rare cases to facilitate traversals\n  // beginning somewhere other than documents.\n  initialType) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;\n\n    if (initialType) {\n      if ((0, _definition.isInputType)(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if ((0, _definition.isCompositeType)(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if ((0, _definition.isOutputType)(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  var _proto = TypeInfo.prototype;\n\n  _proto.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  _proto.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  _proto.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  _proto.getParentInputType = function getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  };\n\n  _proto.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  _proto.getDefaultValue = function getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  };\n\n  _proto.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  _proto.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  _proto.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  };\n\n  _proto.enter = function enter(node) {\n    var schema = this._schema; // Note: many of the types below are explicitly typed as \"mixed\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET:\n        {\n          var namedType = (0, _definition.getNamedType)(this.getType());\n\n          this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.FIELD:\n        {\n          var parentType = this.getParentType();\n          var fieldDef;\n          var fieldType;\n\n          if (parentType) {\n            fieldDef = this._getFieldDef(schema, parentType, node);\n\n            if (fieldDef) {\n              fieldType = fieldDef.type;\n            }\n          }\n\n          this._fieldDefStack.push(fieldDef);\n\n          this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case _kinds.Kind.OPERATION_DEFINITION:\n        {\n          var type;\n\n          switch (node.operation) {\n            case 'query':\n              type = schema.getQueryType();\n              break;\n\n            case 'mutation':\n              type = schema.getMutationType();\n              break;\n\n            case 'subscription':\n              type = schema.getSubscriptionType();\n              break;\n          }\n\n          this._typeStack.push((0, _definition.isObjectType)(type) ? type : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        {\n          var typeConditionAST = node.typeCondition;\n          var outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());\n\n          this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.VARIABLE_DEFINITION:\n        {\n          var inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);\n\n          this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.ARGUMENT:\n        {\n          var _this$getDirective;\n\n          var argDef;\n          var argType;\n          var fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();\n\n          if (fieldOrDirective) {\n            argDef = (0, _find.default)(fieldOrDirective.args, function (arg) {\n              return arg.name === node.name.value;\n            });\n\n            if (argDef) {\n              argType = argDef.type;\n            }\n          }\n\n          this._argument = argDef;\n\n          this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n          this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.LIST:\n        {\n          var listType = (0, _definition.getNullableType)(this.getInputType());\n          var itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n          this._defaultValueStack.push(undefined);\n\n          this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.OBJECT_FIELD:\n        {\n          var objectType = (0, _definition.getNamedType)(this.getInputType());\n          var inputFieldType;\n          var inputField;\n\n          if ((0, _definition.isInputObjectType)(objectType)) {\n            inputField = objectType.getFields()[node.name.value];\n\n            if (inputField) {\n              inputFieldType = inputField.type;\n            }\n          }\n\n          this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n\n          this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : undefined);\n\n          break;\n        }\n\n      case _kinds.Kind.ENUM:\n        {\n          var enumType = (0, _definition.getNamedType)(this.getInputType());\n          var enumValue;\n\n          if ((0, _definition.isEnumType)(enumType)) {\n            enumValue = enumType.getValue(node.value);\n          }\n\n          this._enumValue = enumValue;\n          break;\n        }\n    }\n  };\n\n  _proto.leave = function leave(node) {\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case _kinds.Kind.OPERATION_DEFINITION:\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case _kinds.Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.LIST:\n      case _kinds.Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\n\nexports.TypeInfo = TypeInfo;\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n\n  if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.SchemaMetaFieldDef;\n  }\n\n  if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.TypeMetaFieldDef;\n  }\n\n  if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n\n  if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\n\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = (0, _visitor.getVisitFn)(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if ((0, _ast.isNode)(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = (0, _visitor.getVisitFn)(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4499, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/extendSchema.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendSchema = extendSchema;\nexports.extendSchemaImpl = extendSchemaImpl;\nexports.getDescription = getDescription;\n\nvar _objectValues = _interopRequireDefault(require(\"../polyfills/objectValues\"));\n\nvar _keyMap = _interopRequireDefault(require(\"../jsutils/keyMap\"));\n\nvar _inspect = _interopRequireDefault(require(\"../jsutils/inspect\"));\n\nvar _mapValue = _interopRequireDefault(require(\"../jsutils/mapValue\"));\n\nvar _invariant = _interopRequireDefault(require(\"../jsutils/invariant\"));\n\nvar _devAssert = _interopRequireDefault(require(\"../jsutils/devAssert\"));\n\nvar _kinds = require(\"../language/kinds\");\n\nvar _tokenKind = require(\"../language/tokenKind\");\n\nvar _blockString = require(\"../language/blockString\");\n\nvar _predicates = require(\"../language/predicates\");\n\nvar _validate = require(\"../validation/validate\");\n\nvar _values = require(\"../execution/values\");\n\nvar _schema = require(\"../type/schema\");\n\nvar _scalars = require(\"../type/scalars\");\n\nvar _introspection = require(\"../type/introspection\");\n\nvar _directives = require(\"../type/directives\");\n\nvar _definition = require(\"../type/definition\");\n\nvar _valueFromAST = require(\"./valueFromAST\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nfunction extendSchema(schema, documentAST, options) {\n  (0, _schema.assertSchema)(schema);\n  documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.default)(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    (0, _validate.assertValidSDLExtension)(documentAST, schema);\n  }\n\n  var schemaConfig = schema.toConfig();\n  var extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\n\nfunction extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n\n  // Collect the type definitions and extensions found in the document.\n  var typeDefs = [];\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      typeDefs.push(def);\n    } else if ((0, _predicates.isTypeExtensionNode)(def)) {\n      var extendedTypeName = def.name.value;\n      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {\n    return schemaConfig;\n  }\n\n  var typeMap = Object.create(null);\n\n  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {\n    var existingType = _schemaConfig$types2[_i4];\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (var _i6 = 0; _i6 < typeDefs.length; _i6++) {\n    var _stdTypeMap$name;\n\n    var typeNode = typeDefs[_i6];\n    var name = typeNode.name.value;\n    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);\n  }\n\n  var operationTypes = _objectSpread(_objectSpread({\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)\n  }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions)); // Then produce and return a Schema config with these types.\n\n\n  return _objectSpread(_objectSpread({\n    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value\n  }, operationTypes), {}, {\n    types: (0, _objectValues.default)(typeMap),\n    directives: [].concat(schemaConfig.directives.map(replaceDirective), directiveDefs.map(buildDirective)),\n    extensions: undefined,\n    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if ((0, _definition.isListType)(type)) {\n      return new _definition.GraphQLList(replaceType(type.ofType));\n    } else if ((0, _definition.isNonNullType)(type)) {\n      return new _definition.GraphQLNonNull(replaceType(type.ofType));\n    }\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    var config = directive.toConfig();\n    return new _directives.GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {\n      args: (0, _mapValue.default)(config.args, extendArg)\n    }));\n  }\n\n  function extendNamedType(type) {\n    if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if ((0, _definition.isScalarType)(type)) {\n      return extendScalarType(type);\n    }\n\n    if ((0, _definition.isObjectType)(type)) {\n      return extendObjectType(type);\n    }\n\n    if ((0, _definition.isInterfaceType)(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if ((0, _definition.isUnionType)(type)) {\n      return extendUnionType(type);\n    }\n\n    if ((0, _definition.isEnumType)(type)) {\n      return extendEnumType(type);\n    } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n    if ((0, _definition.isInputObjectType)(type)) {\n      return extendInputObjectType(type);\n    } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n    false || (0, _invariant.default)(0, 'Unexpected type: ' + (0, _inspect.default)(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];\n    return new _definition.GraphQLInputObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, (0, _mapValue.default)(config.fields, function (field) {\n          return _objectSpread(_objectSpread({}, field), {}, {\n            type: replaceType(field.type)\n          });\n        })), buildInputFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];\n    return new _definition.GraphQLEnumType(_objectSpread(_objectSpread({}, config), {}, {\n      values: _objectSpread(_objectSpread({}, config.values), buildEnumValueMap(extensions)),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];\n    var specifiedByUrl = config.specifiedByUrl;\n\n    for (var _i8 = 0; _i8 < extensions.length; _i8++) {\n      var _getSpecifiedByUrl;\n\n      var extensionNode = extensions[_i8];\n      specifiedByUrl = (_getSpecifiedByUrl = getSpecifiedByUrl(extensionNode)) !== null && _getSpecifiedByUrl !== void 0 ? _getSpecifiedByUrl : specifiedByUrl;\n    }\n\n    return new _definition.GraphQLScalarType(_objectSpread(_objectSpread({}, config), {}, {\n      specifiedByUrl: specifiedByUrl,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];\n    return new _definition.GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, (0, _mapValue.default)(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];\n    return new _definition.GraphQLInterfaceType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, (0, _mapValue.default)(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];\n    return new _definition.GraphQLUnionType(_objectSpread(_objectSpread({}, config), {}, {\n      types: function types() {\n        return [].concat(type.getTypes().map(replaceNamedType), buildUnionTypes(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendField(field) {\n    return _objectSpread(_objectSpread({}, field), {}, {\n      type: replaceType(field.type),\n      args: (0, _mapValue.default)(field.args, extendArg)\n    });\n  }\n\n  function extendArg(arg) {\n    return _objectSpread(_objectSpread({}, arg), {}, {\n      type: replaceType(arg.type)\n    });\n  }\n\n  function getOperationTypes(nodes) {\n    var opTypes = {};\n\n    for (var _i10 = 0; _i10 < nodes.length; _i10++) {\n      var _node$operationTypes;\n\n      var node = nodes[_i10];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n\n      for (var _i12 = 0; _i12 < operationTypesNodes.length; _i12++) {\n        var operationType = operationTypesNodes[_i12];\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    } // Note: While this could make early assertions to get the correctly\n    // typed values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    var name = node.name.value;\n    var type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(name, \"\\\".\"));\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === _kinds.Kind.LIST_TYPE) {\n      return new _definition.GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === _kinds.Kind.NON_NULL_TYPE) {\n      return new _definition.GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var locations = node.locations.map(function (_ref) {\n      var value = _ref.value;\n      return value;\n    });\n    return new _directives.GraphQLDirective({\n      name: node.name.value,\n      description: getDescription(node, options),\n      locations: locations,\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    var fieldConfigMap = Object.create(null);\n\n    for (var _i14 = 0; _i14 < nodes.length; _i14++) {\n      var _node$fields;\n\n      var node = nodes[_i14];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n\n      for (var _i16 = 0; _i16 < nodeFields.length; _i16++) {\n        var field = nodeFields[_i16];\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description: getDescription(field, options),\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    var argsNodes = args !== null && args !== void 0 ? args : [];\n    var argConfigMap = Object.create(null);\n\n    for (var _i18 = 0; _i18 < argsNodes.length; _i18++) {\n      var arg = argsNodes[_i18];\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      var type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type: type,\n        description: getDescription(arg, options),\n        defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),\n        astNode: arg\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    var inputFieldMap = Object.create(null);\n\n    for (var _i20 = 0; _i20 < nodes.length; _i20++) {\n      var _node$fields2;\n\n      var node = nodes[_i20];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];\n\n      for (var _i22 = 0; _i22 < fieldsNodes.length; _i22++) {\n        var field = fieldsNodes[_i22];\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        var type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type: type,\n          description: getDescription(field, options),\n          defaultValue: (0, _valueFromAST.valueFromAST)(field.defaultValue, type),\n          astNode: field\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    var enumValueMap = Object.create(null);\n\n    for (var _i24 = 0; _i24 < nodes.length; _i24++) {\n      var _node$values;\n\n      var node = nodes[_i24];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n\n      for (var _i26 = 0; _i26 < valuesNodes.length; _i26++) {\n        var value = valuesNodes[_i26];\n        enumValueMap[value.name.value] = {\n          description: getDescription(value, options),\n          deprecationReason: getDeprecationReason(value),\n          astNode: value\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    var interfaces = [];\n\n    for (var _i28 = 0; _i28 < nodes.length; _i28++) {\n      var _node$interfaces;\n\n      var node = nodes[_i28];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var interfacesNodes = (_node$interfaces = node.interfaces) !== null && _node$interfaces !== void 0 ? _node$interfaces : [];\n\n      for (var _i30 = 0; _i30 < interfacesNodes.length; _i30++) {\n        var type = interfacesNodes[_i30];\n        // Note: While this could make assertions to get the correctly typed\n        // values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable\n        // results.\n        interfaces.push(getNamedType(type));\n      }\n    }\n\n    return interfaces;\n  }\n\n  function buildUnionTypes(nodes) {\n    var types = [];\n\n    for (var _i32 = 0; _i32 < nodes.length; _i32++) {\n      var _node$types;\n\n      var node = nodes[_i32];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var typeNodes = (_node$types = node.types) !== null && _node$types !== void 0 ? _node$types : [];\n\n      for (var _i34 = 0; _i34 < typeNodes.length; _i34++) {\n        var type = typeNodes[_i34];\n        // Note: While this could make assertions to get the correctly typed\n        // values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable\n        // results.\n        types.push(getNamedType(type));\n      }\n    }\n\n    return types;\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    var name = astNode.name.value;\n    var description = getDescription(astNode, options);\n    var extensionNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];\n\n    switch (astNode.kind) {\n      case _kinds.Kind.OBJECT_TYPE_DEFINITION:\n        {\n          var extensionASTNodes = extensionNodes;\n          var allNodes = [astNode].concat(extensionASTNodes);\n          return new _definition.GraphQLObjectType({\n            name: name,\n            description: description,\n            interfaces: function interfaces() {\n              return buildInterfaces(allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case _kinds.Kind.INTERFACE_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes = extensionNodes;\n\n          var _allNodes = [astNode].concat(_extensionASTNodes);\n\n          return new _definition.GraphQLInterfaceType({\n            name: name,\n            description: description,\n            interfaces: function interfaces() {\n              return buildInterfaces(_allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(_allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes\n          });\n        }\n\n      case _kinds.Kind.ENUM_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes2 = extensionNodes;\n\n          var _allNodes2 = [astNode].concat(_extensionASTNodes2);\n\n          return new _definition.GraphQLEnumType({\n            name: name,\n            description: description,\n            values: buildEnumValueMap(_allNodes2),\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes2\n          });\n        }\n\n      case _kinds.Kind.UNION_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes3 = extensionNodes;\n\n          var _allNodes3 = [astNode].concat(_extensionASTNodes3);\n\n          return new _definition.GraphQLUnionType({\n            name: name,\n            description: description,\n            types: function types() {\n              return buildUnionTypes(_allNodes3);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes3\n          });\n        }\n\n      case _kinds.Kind.SCALAR_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes4 = extensionNodes;\n          return new _definition.GraphQLScalarType({\n            name: name,\n            description: description,\n            specifiedByUrl: getSpecifiedByUrl(astNode),\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes4\n          });\n        }\n\n      case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes5 = extensionNodes;\n\n          var _allNodes4 = [astNode].concat(_extensionASTNodes5);\n\n          return new _definition.GraphQLInputObjectType({\n            name: name,\n            description: description,\n            fields: function fields() {\n              return buildInputFieldMap(_allNodes4);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes5\n          });\n        }\n    } // istanbul ignore next (Not reachable. All possible type definition nodes have been considered)\n\n\n    false || (0, _invariant.default)(0, 'Unexpected type definition node: ' + (0, _inspect.default)(astNode));\n  }\n}\n\nvar stdTypeMap = (0, _keyMap.default)(_scalars.specifiedScalarTypes.concat(_introspection.introspectionTypes), function (type) {\n  return type.name;\n});\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);\n  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByUrl.\n */\n\n\nfunction getSpecifiedByUrl(node) {\n  var specifiedBy = (0, _values.getDirectiveValues)(_directives.GraphQLSpecifiedByDirective, node);\n  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nfunction getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if ((options === null || options === void 0 ? void 0 : options.commentDescriptions) === true) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return (0, _blockString.dedentBlockStringValue)('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token != null && token.kind === _tokenKind.TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,YAAY,GAAG;AACvB,QAAQ,gBAAgB,GAAG;AAC3B,QAAQ,cAAc,GAAG;AAEzB,IAAI,gBAAgB;AAEpB,IAAI,UAAU;AAEd,IAAI,WAAW;AAEf,IAAI,YAAY;AAEhB,IAAI,aAAa;AAEjB,IAAI,aAAa;AAEjB,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F,SAAS,QAAQ,MAAM,EAAE,cAAc;IAAI,IAAI,OAAO,OAAO,IAAI,CAAC;IAAS,IAAI,OAAO,qBAAqB,EAAE;QAAE,IAAI,UAAU,OAAO,qBAAqB,CAAC;QAAS,IAAI,gBAAgB,UAAU,QAAQ,MAAM,CAAC,SAAU,GAAG;YAAI,OAAO,OAAO,wBAAwB,CAAC,QAAQ,KAAK,UAAU;QAAE;QAAI,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM;IAAU;IAAE,OAAO;AAAM;AAEpV,SAAS,cAAc,MAAM;IAAI,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;QAAE,IAAI,SAAS,SAAS,CAAC,EAAE,IAAI,OAAO,SAAS,CAAC,EAAE,GAAG,CAAC;QAAG,IAAI,IAAI,GAAG;YAAE,QAAQ,OAAO,SAAS,MAAM,OAAO,CAAC,SAAU,GAAG;gBAAI,gBAAgB,QAAQ,KAAK,MAAM,CAAC,IAAI;YAAG;QAAI,OAAO,IAAI,OAAO,yBAAyB,EAAE;YAAE,OAAO,gBAAgB,CAAC,QAAQ,OAAO,yBAAyB,CAAC;QAAU,OAAO;YAAE,QAAQ,OAAO,SAAS,OAAO,CAAC,SAAU,GAAG;gBAAI,OAAO,cAAc,CAAC,QAAQ,KAAK,OAAO,wBAAwB,CAAC,QAAQ;YAAO;QAAI;IAAE;IAAE,OAAO;AAAQ;AAErhB,SAAS,gBAAgB,GAAG,EAAE,GAAG,EAAE,KAAK;IAAI,IAAI,OAAO,KAAK;QAAE,OAAO,cAAc,CAAC,KAAK,KAAK;YAAE,OAAO;YAAO,YAAY;YAAM,cAAc;YAAM,UAAU;QAAK;IAAI,OAAO;QAAE,GAAG,CAAC,IAAI,GAAG;IAAO;IAAE,OAAO;AAAK;AAEhN;;;;;;;;;;;;;;;;;CAiBC,GACD,SAAS,aAAa,MAAM,EAAE,WAAW,EAAE,OAAO;IAChD,CAAC,GAAG,QAAQ,YAAY,EAAE;IAC1B,eAAe,QAAQ,YAAY,IAAI,KAAK,OAAO,IAAI,CAAC,QAAQ,IAAI,CAAC,GAAG,WAAW,OAAO,EAAE,GAAG;IAE/F,IAAI,CAAC,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,WAAW,MAAM,QAAQ,CAAC,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,cAAc,MAAM,MAAM;QAC3K,CAAC,GAAG,UAAU,uBAAuB,EAAE,aAAa;IACtD;IAEA,IAAI,eAAe,OAAO,QAAQ;IAClC,IAAI,iBAAiB,iBAAiB,cAAc,aAAa;IACjE,OAAO,iBAAiB,iBAAiB,SAAS,IAAI,QAAQ,aAAa,CAAC;AAC9E;AACA;;CAEC,GAGD,SAAS,iBAAiB,YAAY,EAAE,WAAW,EAAE,OAAO;IAC1D,IAAI,YAAY,uBAAuB,aAAa;IAEpD,qEAAqE;IACrE,IAAI,WAAW,EAAE;IACjB,IAAI,oBAAoB,OAAO,MAAM,CAAC,OAAO,2EAA2E;IACxH,wDAAwD;IAExD,IAAI,gBAAgB,EAAE;IACtB,IAAI,WAAW,4EAA4E;IAE3F,IAAI,mBAAmB,EAAE;IAEzB,IAAK,IAAI,MAAM,GAAG,yBAAyB,YAAY,WAAW,EAAE,MAAM,uBAAuB,MAAM,EAAE,MAAO;QAC9G,IAAI,MAAM,sBAAsB,CAAC,IAAI;QAErC,IAAI,IAAI,IAAI,KAAK,OAAO,IAAI,CAAC,iBAAiB,EAAE;YAC9C,YAAY;QACd,OAAO,IAAI,IAAI,IAAI,KAAK,OAAO,IAAI,CAAC,gBAAgB,EAAE;YACpD,iBAAiB,IAAI,CAAC;QACxB,OAAO,IAAI,CAAC,GAAG,YAAY,oBAAoB,EAAE,MAAM;YACrD,SAAS,IAAI,CAAC;QAChB,OAAO,IAAI,CAAC,GAAG,YAAY,mBAAmB,EAAE,MAAM;YACpD,IAAI,mBAAmB,IAAI,IAAI,CAAC,KAAK;YACrC,IAAI,yBAAyB,iBAAiB,CAAC,iBAAiB;YAChE,iBAAiB,CAAC,iBAAiB,GAAG,yBAAyB,uBAAuB,MAAM,CAAC;gBAAC;aAAI,IAAI;gBAAC;aAAI;QAC7G,OAAO,IAAI,IAAI,IAAI,KAAK,OAAO,IAAI,CAAC,oBAAoB,EAAE;YACxD,cAAc,IAAI,CAAC;QACrB;IACF,EAAE,yEAAyE;IAC3E,qDAAqD;IAGrD,IAAI,OAAO,IAAI,CAAC,mBAAmB,MAAM,KAAK,KAAK,SAAS,MAAM,KAAK,KAAK,cAAc,MAAM,KAAK,KAAK,iBAAiB,MAAM,KAAK,KAAK,aAAa,MAAM;QAC5J,OAAO;IACT;IAEA,IAAI,UAAU,OAAO,MAAM,CAAC;IAE5B,IAAK,IAAI,MAAM,GAAG,uBAAuB,aAAa,KAAK,EAAE,MAAM,qBAAqB,MAAM,EAAE,MAAO;QACrG,IAAI,eAAe,oBAAoB,CAAC,IAAI;QAC5C,OAAO,CAAC,aAAa,IAAI,CAAC,GAAG,gBAAgB;IAC/C;IAEA,IAAK,IAAI,MAAM,GAAG,MAAM,SAAS,MAAM,EAAE,MAAO;QAC9C,IAAI;QAEJ,IAAI,WAAW,QAAQ,CAAC,IAAI;QAC5B,IAAI,OAAO,SAAS,IAAI,CAAC,KAAK;QAC9B,OAAO,CAAC,KAAK,GAAG,CAAC,mBAAmB,UAAU,CAAC,KAAK,MAAM,QAAQ,qBAAqB,KAAK,IAAI,mBAAmB,UAAU;IAC/H;IAEA,IAAI,iBAAiB,cAAc,cAAc;QAC/C,yCAAyC;QACzC,OAAO,aAAa,KAAK,IAAI,iBAAiB,aAAa,KAAK;QAChE,UAAU,aAAa,QAAQ,IAAI,iBAAiB,aAAa,QAAQ;QACzE,cAAc,aAAa,YAAY,IAAI,iBAAiB,aAAa,YAAY;IACvF,GAAG,aAAa,kBAAkB;QAAC;KAAU,IAAI,kBAAkB,oBAAoB,4DAA4D;IAGnJ,OAAO,cAAc,cAAc;QACjC,aAAa,CAAC,aAAa,SAAS,MAAM,QAAQ,eAAe,KAAK,IAAI,KAAK,IAAI,CAAC,wBAAwB,WAAW,WAAW,MAAM,QAAQ,0BAA0B,KAAK,IAAI,KAAK,IAAI,sBAAsB,KAAK;IACzN,GAAG,iBAAiB,CAAC,GAAG;QACtB,OAAO,CAAC,GAAG,cAAc,OAAO,EAAE;QAClC,YAAY,EAAE,CAAC,MAAM,CAAC,aAAa,UAAU,CAAC,GAAG,CAAC,mBAAmB,cAAc,GAAG,CAAC;QACvF,YAAY;QACZ,SAAS,CAAC,cAAc,SAAS,MAAM,QAAQ,gBAAgB,KAAK,IAAI,cAAc,aAAa,OAAO;QAC1G,mBAAmB,aAAa,iBAAiB,CAAC,MAAM,CAAC;QACzD,aAAa,CAAC,uBAAuB,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,WAAW,MAAM,QAAQ,yBAAyB,KAAK,IAAI,uBAAuB;IACnL,IAAI,2EAA2E;;;IAC/E,4EAA4E;IAE5E,SAAS,YAAY,IAAI;QACvB,IAAI,CAAC,GAAG,YAAY,UAAU,EAAE,OAAO;YACrC,OAAO,IAAI,YAAY,WAAW,CAAC,YAAY,KAAK,MAAM;QAC5D,OAAO,IAAI,CAAC,GAAG,YAAY,aAAa,EAAE,OAAO;YAC/C,OAAO,IAAI,YAAY,cAAc,CAAC,YAAY,KAAK,MAAM;QAC/D;QAEA,OAAO,iBAAiB;IAC1B;IAEA,SAAS,iBAAiB,IAAI;QAC5B,oEAAoE;QACpE,+DAA+D;QAC/D,yEAAyE;QACzE,OAAO,OAAO,CAAC,KAAK,IAAI,CAAC;IAC3B;IAEA,SAAS,iBAAiB,SAAS;QACjC,IAAI,SAAS,UAAU,QAAQ;QAC/B,OAAO,IAAI,YAAY,gBAAgB,CAAC,cAAc,cAAc,CAAC,GAAG,SAAS,CAAC,GAAG;YACnF,MAAM,CAAC,GAAG,UAAU,OAAO,EAAE,OAAO,IAAI,EAAE;QAC5C;IACF;IAEA,SAAS,gBAAgB,IAAI;QAC3B,IAAI,CAAC,GAAG,eAAe,mBAAmB,EAAE,SAAS,CAAC,GAAG,SAAS,qBAAqB,EAAE,OAAO;YAC9F,kCAAkC;YAClC,OAAO;QACT;QAEA,IAAI,CAAC,GAAG,YAAY,YAAY,EAAE,OAAO;YACvC,OAAO,iBAAiB;QAC1B;QAEA,IAAI,CAAC,GAAG,YAAY,YAAY,EAAE,OAAO;YACvC,OAAO,iBAAiB;QAC1B;QAEA,IAAI,CAAC,GAAG,YAAY,eAAe,EAAE,OAAO;YAC1C,OAAO,oBAAoB;QAC7B;QAEA,IAAI,CAAC,GAAG,YAAY,WAAW,EAAE,OAAO;YACtC,OAAO,gBAAgB;QACzB;QAEA,IAAI,CAAC,GAAG,YAAY,UAAU,EAAE,OAAO;YACrC,OAAO,eAAe;QACxB,EAAE,kFAAkF;QAGpF,IAAI,CAAC,GAAG,YAAY,iBAAiB,EAAE,OAAO;YAC5C,OAAO,sBAAsB;QAC/B,EAAE,gFAAgF;QAGlF,SAAS,CAAC,GAAG,WAAW,OAAO,EAAE,GAAG,sBAAsB,CAAC,GAAG,SAAS,OAAO,EAAE;IAClF;IAEA,SAAS,sBAAsB,IAAI;QACjC,IAAI;QAEJ,IAAI,SAAS,KAAK,QAAQ;QAC1B,IAAI,aAAa,CAAC,wBAAwB,iBAAiB,CAAC,OAAO,IAAI,CAAC,MAAM,QAAQ,0BAA0B,KAAK,IAAI,wBAAwB,EAAE;QACnJ,OAAO,IAAI,YAAY,sBAAsB,CAAC,cAAc,cAAc,CAAC,GAAG,SAAS,CAAC,GAAG;YACzF,QAAQ,SAAS;gBACf,OAAO,cAAc,cAAc,CAAC,GAAG,CAAC,GAAG,UAAU,OAAO,EAAE,OAAO,MAAM,EAAE,SAAU,KAAK;oBAC1F,OAAO,cAAc,cAAc,CAAC,GAAG,QAAQ,CAAC,GAAG;wBACjD,MAAM,YAAY,MAAM,IAAI;oBAC9B;gBACF,KAAK,mBAAmB;YAC1B;YACA,mBAAmB,OAAO,iBAAiB,CAAC,MAAM,CAAC;QACrD;IACF;IAEA,SAAS,eAAe,IAAI;QAC1B,IAAI;QAEJ,IAAI,SAAS,KAAK,QAAQ;QAC1B,IAAI,aAAa,CAAC,wBAAwB,iBAAiB,CAAC,KAAK,IAAI,CAAC,MAAM,QAAQ,0BAA0B,KAAK,IAAI,wBAAwB,EAAE;QACjJ,OAAO,IAAI,YAAY,eAAe,CAAC,cAAc,cAAc,CAAC,GAAG,SAAS,CAAC,GAAG;YAClF,QAAQ,cAAc,cAAc,CAAC,GAAG,OAAO,MAAM,GAAG,kBAAkB;YAC1E,mBAAmB,OAAO,iBAAiB,CAAC,MAAM,CAAC;QACrD;IACF;IAEA,SAAS,iBAAiB,IAAI;QAC5B,IAAI;QAEJ,IAAI,SAAS,KAAK,QAAQ;QAC1B,IAAI,aAAa,CAAC,yBAAyB,iBAAiB,CAAC,OAAO,IAAI,CAAC,MAAM,QAAQ,2BAA2B,KAAK,IAAI,yBAAyB,EAAE;QACtJ,IAAI,iBAAiB,OAAO,cAAc;QAE1C,IAAK,IAAI,MAAM,GAAG,MAAM,WAAW,MAAM,EAAE,MAAO;YAChD,IAAI;YAEJ,IAAI,gBAAgB,UAAU,CAAC,IAAI;YACnC,iBAAiB,CAAC,qBAAqB,kBAAkB,cAAc,MAAM,QAAQ,uBAAuB,KAAK,IAAI,qBAAqB;QAC5I;QAEA,OAAO,IAAI,YAAY,iBAAiB,CAAC,cAAc,cAAc,CAAC,GAAG,SAAS,CAAC,GAAG;YACpF,gBAAgB;YAChB,mBAAmB,OAAO,iBAAiB,CAAC,MAAM,CAAC;QACrD;IACF;IAEA,SAAS,iBAAiB,IAAI;QAC5B,IAAI;QAEJ,IAAI,SAAS,KAAK,QAAQ;QAC1B,IAAI,aAAa,CAAC,yBAAyB,iBAAiB,CAAC,OAAO,IAAI,CAAC,MAAM,QAAQ,2BAA2B,KAAK,IAAI,yBAAyB,EAAE;QACtJ,OAAO,IAAI,YAAY,iBAAiB,CAAC,cAAc,cAAc,CAAC,GAAG,SAAS,CAAC,GAAG;YACpF,YAAY,SAAS;gBACnB,OAAO,EAAE,CAAC,MAAM,CAAC,KAAK,aAAa,GAAG,GAAG,CAAC,mBAAmB,gBAAgB;YAC/E;YACA,QAAQ,SAAS;gBACf,OAAO,cAAc,cAAc,CAAC,GAAG,CAAC,GAAG,UAAU,OAAO,EAAE,OAAO,MAAM,EAAE,eAAe,cAAc;YAC5G;YACA,mBAAmB,OAAO,iBAAiB,CAAC,MAAM,CAAC;QACrD;IACF;IAEA,SAAS,oBAAoB,IAAI;QAC/B,IAAI;QAEJ,IAAI,SAAS,KAAK,QAAQ;QAC1B,IAAI,aAAa,CAAC,yBAAyB,iBAAiB,CAAC,OAAO,IAAI,CAAC,MAAM,QAAQ,2BAA2B,KAAK,IAAI,yBAAyB,EAAE;QACtJ,OAAO,IAAI,YAAY,oBAAoB,CAAC,cAAc,cAAc,CAAC,GAAG,SAAS,CAAC,GAAG;YACvF,YAAY,SAAS;gBACnB,OAAO,EAAE,CAAC,MAAM,CAAC,KAAK,aAAa,GAAG,GAAG,CAAC,mBAAmB,gBAAgB;YAC/E;YACA,QAAQ,SAAS;gBACf,OAAO,cAAc,cAAc,CAAC,GAAG,CAAC,GAAG,UAAU,OAAO,EAAE,OAAO,MAAM,EAAE,eAAe,cAAc;YAC5G;YACA,mBAAmB,OAAO,iBAAiB,CAAC,MAAM,CAAC;QACrD;IACF;IAEA,SAAS,gBAAgB,IAAI;QAC3B,IAAI;QAEJ,IAAI,SAAS,KAAK,QAAQ;QAC1B,IAAI,aAAa,CAAC,yBAAyB,iBAAiB,CAAC,OAAO,IAAI,CAAC,MAAM,QAAQ,2BAA2B,KAAK,IAAI,yBAAyB,EAAE;QACtJ,OAAO,IAAI,YAAY,gBAAgB,CAAC,cAAc,cAAc,CAAC,GAAG,SAAS,CAAC,GAAG;YACnF,OAAO,SAAS;gBACd,OAAO,EAAE,CAAC,MAAM,CAAC,KAAK,QAAQ,GAAG,GAAG,CAAC,mBAAmB,gBAAgB;YAC1E;YACA,mBAAmB,OAAO,iBAAiB,CAAC,MAAM,CAAC;QACrD;IACF;IAEA,SAAS,YAAY,KAAK;QACxB,OAAO,cAAc,cAAc,CAAC,GAAG,QAAQ,CAAC,GAAG;YACjD,MAAM,YAAY,MAAM,IAAI;YAC5B,MAAM,CAAC,GAAG,UAAU,OAAO,EAAE,MAAM,IAAI,EAAE;QAC3C;IACF;IAEA,SAAS,UAAU,GAAG;QACpB,OAAO,cAAc,cAAc,CAAC,GAAG,MAAM,CAAC,GAAG;YAC/C,MAAM,YAAY,IAAI,IAAI;QAC5B;IACF;IAEA,SAAS,kBAAkB,KAAK;QAC9B,IAAI,UAAU,CAAC;QAEf,IAAK,IAAI,OAAO,GAAG,OAAO,MAAM,MAAM,EAAE,OAAQ;YAC9C,IAAI;YAEJ,IAAI,OAAO,KAAK,CAAC,KAAK;YACtB,kFAAkF;YAClF,IAAI,sBAAsB,CAAC,uBAAuB,KAAK,cAAc,MAAM,QAAQ,yBAAyB,KAAK,IAAI,uBAAuB,EAAE;YAE9I,IAAK,IAAI,OAAO,GAAG,OAAO,oBAAoB,MAAM,EAAE,OAAQ;gBAC5D,IAAI,gBAAgB,mBAAmB,CAAC,KAAK;gBAC7C,OAAO,CAAC,cAAc,SAAS,CAAC,GAAG,aAAa,cAAc,IAAI;YACpE;QACF,EAAE,oEAAoE;QACtE,qEAAqE;QACrE,yEAAyE;QAGzE,OAAO;IACT;IAEA,SAAS,aAAa,IAAI;QACxB,IAAI;QAEJ,IAAI,OAAO,KAAK,IAAI,CAAC,KAAK;QAC1B,IAAI,OAAO,CAAC,oBAAoB,UAAU,CAAC,KAAK,MAAM,QAAQ,sBAAsB,KAAK,IAAI,oBAAoB,OAAO,CAAC,KAAK;QAE9H,IAAI,SAAS,WAAW;YACtB,MAAM,IAAI,MAAM,mBAAmB,MAAM,CAAC,MAAM;QAClD;QAEA,OAAO;IACT;IAEA,SAAS,eAAe,IAAI;QAC1B,IAAI,KAAK,IAAI,KAAK,OAAO,IAAI,CAAC,SAAS,EAAE;YACvC,OAAO,IAAI,YAAY,WAAW,CAAC,eAAe,KAAK,IAAI;QAC7D;QAEA,IAAI,KAAK,IAAI,KAAK,OAAO,IAAI,CAAC,aAAa,EAAE;YAC3C,OAAO,IAAI,YAAY,cAAc,CAAC,eAAe,KAAK,IAAI;QAChE;QAEA,OAAO,aAAa;IACtB;IAEA,SAAS,eAAe,IAAI;QAC1B,IAAI,YAAY,KAAK,SAAS,CAAC,GAAG,CAAC,SAAU,IAAI;YAC/C,IAAI,QAAQ,KAAK,KAAK;YACtB,OAAO;QACT;QACA,OAAO,IAAI,YAAY,gBAAgB,CAAC;YACtC,MAAM,KAAK,IAAI,CAAC,KAAK;YACrB,aAAa,eAAe,MAAM;YAClC,WAAW;YACX,cAAc,KAAK,UAAU;YAC7B,MAAM,iBAAiB,KAAK,SAAS;YACrC,SAAS;QACX;IACF;IAEA,SAAS,cAAc,KAAK;QAC1B,IAAI,iBAAiB,OAAO,MAAM,CAAC;QAEnC,IAAK,IAAI,OAAO,GAAG,OAAO,MAAM,MAAM,EAAE,OAAQ;YAC9C,IAAI;YAEJ,IAAI,OAAO,KAAK,CAAC,KAAK;YACtB,kFAAkF;YAClF,IAAI,aAAa,CAAC,eAAe,KAAK,MAAM,MAAM,QAAQ,iBAAiB,KAAK,IAAI,eAAe,EAAE;YAErG,IAAK,IAAI,OAAO,GAAG,OAAO,WAAW,MAAM,EAAE,OAAQ;gBACnD,IAAI,QAAQ,UAAU,CAAC,KAAK;gBAC5B,cAAc,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG;oBACjC,oEAAoE;oBACpE,mEAAmE;oBACnE,8DAA8D;oBAC9D,MAAM,eAAe,MAAM,IAAI;oBAC/B,aAAa,eAAe,OAAO;oBACnC,MAAM,iBAAiB,MAAM,SAAS;oBACtC,mBAAmB,qBAAqB;oBACxC,SAAS;gBACX;YACF;QACF;QAEA,OAAO;IACT;IAEA,SAAS,iBAAiB,IAAI;QAC5B,kFAAkF;QAClF,IAAI,YAAY,SAAS,QAAQ,SAAS,KAAK,IAAI,OAAO,EAAE;QAC5D,IAAI,eAAe,OAAO,MAAM,CAAC;QAEjC,IAAK,IAAI,OAAO,GAAG,OAAO,UAAU,MAAM,EAAE,OAAQ;YAClD,IAAI,MAAM,SAAS,CAAC,KAAK;YACzB,oEAAoE;YACpE,mEAAmE;YACnE,8DAA8D;YAC9D,IAAI,OAAO,eAAe,IAAI,IAAI;YAClC,YAAY,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG;gBAC7B,MAAM;gBACN,aAAa,eAAe,KAAK;gBACjC,cAAc,CAAC,GAAG,cAAc,YAAY,EAAE,IAAI,YAAY,EAAE;gBAChE,SAAS;YACX;QACF;QAEA,OAAO;IACT;IAEA,SAAS,mBAAmB,KAAK;QAC/B,IAAI,gBAAgB,OAAO,MAAM,CAAC;QAElC,IAAK,IAAI,OAAO,GAAG,OAAO,MAAM,MAAM,EAAE,OAAQ;YAC9C,IAAI;YAEJ,IAAI,OAAO,KAAK,CAAC,KAAK;YACtB,kFAAkF;YAClF,IAAI,cAAc,CAAC,gBAAgB,KAAK,MAAM,MAAM,QAAQ,kBAAkB,KAAK,IAAI,gBAAgB,EAAE;YAEzG,IAAK,IAAI,OAAO,GAAG,OAAO,YAAY,MAAM,EAAE,OAAQ;gBACpD,IAAI,QAAQ,WAAW,CAAC,KAAK;gBAC7B,oEAAoE;gBACpE,mEAAmE;gBACnE,8DAA8D;gBAC9D,IAAI,OAAO,eAAe,MAAM,IAAI;gBACpC,aAAa,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG;oBAChC,MAAM;oBACN,aAAa,eAAe,OAAO;oBACnC,cAAc,CAAC,GAAG,cAAc,YAAY,EAAE,MAAM,YAAY,EAAE;oBAClE,SAAS;gBACX;YACF;QACF;QAEA,OAAO;IACT;IAEA,SAAS,kBAAkB,KAAK;QAC9B,IAAI,eAAe,OAAO,MAAM,CAAC;QAEjC,IAAK,IAAI,OAAO,GAAG,OAAO,MAAM,MAAM,EAAE,OAAQ;YAC9C,IAAI;YAEJ,IAAI,OAAO,KAAK,CAAC,KAAK;YACtB,kFAAkF;YAClF,IAAI,cAAc,CAAC,eAAe,KAAK,MAAM,MAAM,QAAQ,iBAAiB,KAAK,IAAI,eAAe,EAAE;YAEtG,IAAK,IAAI,OAAO,GAAG,OAAO,YAAY,MAAM,EAAE,OAAQ;gBACpD,IAAI,QAAQ,WAAW,CAAC,KAAK;gBAC7B,YAAY,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG;oBAC/B,aAAa,eAAe,OAAO;oBACnC,mBAAmB,qBAAqB;oBACxC,SAAS;gBACX;YACF;QACF;QAEA,OAAO;IACT;IAEA,SAAS,gBAAgB,KAAK;QAC5B,IAAI,aAAa,EAAE;QAEnB,IAAK,IAAI,OAAO,GAAG,OAAO,MAAM,MAAM,EAAE,OAAQ;YAC9C,IAAI;YAEJ,IAAI,OAAO,KAAK,CAAC,KAAK;YACtB,kFAAkF;YAClF,IAAI,kBAAkB,CAAC,mBAAmB,KAAK,UAAU,MAAM,QAAQ,qBAAqB,KAAK,IAAI,mBAAmB,EAAE;YAE1H,IAAK,IAAI,OAAO,GAAG,OAAO,gBAAgB,MAAM,EAAE,OAAQ;gBACxD,IAAI,OAAO,eAAe,CAAC,KAAK;gBAChC,oEAAoE;gBACpE,+DAA+D;gBAC/D,gEAAgE;gBAChE,WAAW;gBACX,WAAW,IAAI,CAAC,aAAa;YAC/B;QACF;QAEA,OAAO;IACT;IAEA,SAAS,gBAAgB,KAAK;QAC5B,IAAI,QAAQ,EAAE;QAEd,IAAK,IAAI,OAAO,GAAG,OAAO,MAAM,MAAM,EAAE,OAAQ;YAC9C,IAAI;YAEJ,IAAI,OAAO,KAAK,CAAC,KAAK;YACtB,kFAAkF;YAClF,IAAI,YAAY,CAAC,cAAc,KAAK,KAAK,MAAM,QAAQ,gBAAgB,KAAK,IAAI,cAAc,EAAE;YAEhG,IAAK,IAAI,OAAO,GAAG,OAAO,UAAU,MAAM,EAAE,OAAQ;gBAClD,IAAI,OAAO,SAAS,CAAC,KAAK;gBAC1B,oEAAoE;gBACpE,+DAA+D;gBAC/D,gEAAgE;gBAChE,WAAW;gBACX,MAAM,IAAI,CAAC,aAAa;YAC1B;QACF;QAEA,OAAO;IACT;IAEA,SAAS,UAAU,OAAO;QACxB,IAAI;QAEJ,IAAI,OAAO,QAAQ,IAAI,CAAC,KAAK;QAC7B,IAAI,cAAc,eAAe,SAAS;QAC1C,IAAI,iBAAiB,CAAC,wBAAwB,iBAAiB,CAAC,KAAK,MAAM,QAAQ,0BAA0B,KAAK,IAAI,wBAAwB,EAAE;QAEhJ,OAAQ,QAAQ,IAAI;YAClB,KAAK,OAAO,IAAI,CAAC,sBAAsB;gBACrC;oBACE,IAAI,oBAAoB;oBACxB,IAAI,WAAW;wBAAC;qBAAQ,CAAC,MAAM,CAAC;oBAChC,OAAO,IAAI,YAAY,iBAAiB,CAAC;wBACvC,MAAM;wBACN,aAAa;wBACb,YAAY,SAAS;4BACnB,OAAO,gBAAgB;wBACzB;wBACA,QAAQ,SAAS;4BACf,OAAO,cAAc;wBACvB;wBACA,SAAS;wBACT,mBAAmB;oBACrB;gBACF;YAEF,KAAK,OAAO,IAAI,CAAC,yBAAyB;gBACxC;oBACE,IAAI,qBAAqB;oBAEzB,IAAI,YAAY;wBAAC;qBAAQ,CAAC,MAAM,CAAC;oBAEjC,OAAO,IAAI,YAAY,oBAAoB,CAAC;wBAC1C,MAAM;wBACN,aAAa;wBACb,YAAY,SAAS;4BACnB,OAAO,gBAAgB;wBACzB;wBACA,QAAQ,SAAS;4BACf,OAAO,cAAc;wBACvB;wBACA,SAAS;wBACT,mBAAmB;oBACrB;gBACF;YAEF,KAAK,OAAO,IAAI,CAAC,oBAAoB;gBACnC;oBACE,IAAI,sBAAsB;oBAE1B,IAAI,aAAa;wBAAC;qBAAQ,CAAC,MAAM,CAAC;oBAElC,OAAO,IAAI,YAAY,eAAe,CAAC;wBACrC,MAAM;wBACN,aAAa;wBACb,QAAQ,kBAAkB;wBAC1B,SAAS;wBACT,mBAAmB;oBACrB;gBACF;YAEF,KAAK,OAAO,IAAI,CAAC,qBAAqB;gBACpC;oBACE,IAAI,sBAAsB;oBAE1B,IAAI,aAAa;wBAAC;qBAAQ,CAAC,MAAM,CAAC;oBAElC,OAAO,IAAI,YAAY,gBAAgB,CAAC;wBACtC,MAAM;wBACN,aAAa;wBACb,OAAO,SAAS;4BACd,OAAO,gBAAgB;wBACzB;wBACA,SAAS;wBACT,mBAAmB;oBACrB;gBACF;YAEF,KAAK,OAAO,IAAI,CAAC,sBAAsB;gBACrC;oBACE,IAAI,sBAAsB;oBAC1B,OAAO,IAAI,YAAY,iBAAiB,CAAC;wBACvC,MAAM;wBACN,aAAa;wBACb,gBAAgB,kBAAkB;wBAClC,SAAS;wBACT,mBAAmB;oBACrB;gBACF;YAEF,KAAK,OAAO,IAAI,CAAC,4BAA4B;gBAC3C;oBACE,IAAI,sBAAsB;oBAE1B,IAAI,aAAa;wBAAC;qBAAQ,CAAC,MAAM,CAAC;oBAElC,OAAO,IAAI,YAAY,sBAAsB,CAAC;wBAC5C,MAAM;wBACN,aAAa;wBACb,QAAQ,SAAS;4BACf,OAAO,mBAAmB;wBAC5B;wBACA,SAAS;wBACT,mBAAmB;oBACrB;gBACF;QACJ,EAAE,gGAAgG;QAGlG,SAAS,CAAC,GAAG,WAAW,OAAO,EAAE,GAAG,sCAAsC,CAAC,GAAG,SAAS,OAAO,EAAE;IAClG;AACF;AAEA,IAAI,aAAa,CAAC,GAAG,QAAQ,OAAO,EAAE,SAAS,oBAAoB,CAAC,MAAM,CAAC,eAAe,kBAAkB,GAAG,SAAU,IAAI;IAC3H,OAAO,KAAK,IAAI;AAClB;AACA;;;CAGC,GAED,SAAS,qBAAqB,IAAI;IAChC,IAAI,aAAa,CAAC,GAAG,QAAQ,kBAAkB,EAAE,YAAY,0BAA0B,EAAE;IACzF,OAAO,eAAe,QAAQ,eAAe,KAAK,IAAI,KAAK,IAAI,WAAW,MAAM;AAClF;AACA;;CAEC,GAGD,SAAS,kBAAkB,IAAI;IAC7B,IAAI,cAAc,CAAC,GAAG,QAAQ,kBAAkB,EAAE,YAAY,2BAA2B,EAAE;IAC3F,OAAO,gBAAgB,QAAQ,gBAAgB,KAAK,IAAI,KAAK,IAAI,YAAY,GAAG;AAClF;AACA;;;;;;;;;CASC,GAGD,SAAS,eAAe,IAAI,EAAE,OAAO;IACnC,IAAI,KAAK,WAAW,EAAE;QACpB,OAAO,KAAK,WAAW,CAAC,KAAK;IAC/B;IAEA,IAAI,CAAC,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,mBAAmB,MAAM,MAAM;QAC5F,IAAI,WAAW,uBAAuB;QAEtC,IAAI,aAAa,WAAW;YAC1B,OAAO,CAAC,GAAG,aAAa,sBAAsB,EAAE,OAAO;QACzD;IACF;AACF;AAEA,SAAS,uBAAuB,IAAI;IAClC,IAAI,MAAM,KAAK,GAAG;IAElB,IAAI,CAAC,KAAK;QACR;IACF;IAEA,IAAI,WAAW,EAAE;IACjB,IAAI,QAAQ,IAAI,UAAU,CAAC,IAAI;IAE/B,MAAO,SAAS,QAAQ,MAAM,IAAI,KAAK,WAAW,SAAS,CAAC,OAAO,IAAI,MAAM,IAAI,IAAI,MAAM,IAAI,IAAI,MAAM,IAAI,GAAG,MAAM,MAAM,IAAI,CAAC,IAAI,IAAI,MAAM,IAAI,KAAK,MAAM,IAAI,CAAC,IAAI,CAAE;QACvK,IAAI,QAAQ,OAAO,MAAM,KAAK;QAC9B,SAAS,IAAI,CAAC;QACd,QAAQ,MAAM,IAAI;IACpB;IAEA,OAAO,SAAS,MAAM,GAAG,IAAI,SAAS,OAAO,GAAG,IAAI,CAAC,QAAQ;AAC/D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5125, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/buildASTSchema.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildASTSchema = buildASTSchema;\nexports.buildSchema = buildSchema;\n\nvar _devAssert = _interopRequireDefault(require(\"../jsutils/devAssert\"));\n\nvar _kinds = require(\"../language/kinds\");\n\nvar _parser = require(\"../language/parser\");\n\nvar _validate = require(\"../validation/validate\");\n\nvar _schema = require(\"../type/schema\");\n\nvar _directives = require(\"../type/directives\");\n\nvar _extendSchema = require(\"./extendSchema\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nfunction buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.default)(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    (0, _validate.assertValidSDL)(documentAST);\n  }\n\n  var emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: undefined,\n    extensionASTNodes: [],\n    assumeValid: false\n  };\n  var config = (0, _extendSchema.extendSchemaImpl)(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n      var type = _config$types2[_i2];\n\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  var directives = config.directives; // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(_directives.GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(_directives.GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(_directives.GraphQLDeprecatedDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'specifiedBy';\n  })) {\n    directives.push(_directives.GraphQLSpecifiedByDirective);\n  }\n\n  return new _schema.GraphQLSchema(config);\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nfunction buildSchema(source, options) {\n  var document = (0, _parser.parse)(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,\n    allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,\n    experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables\n  });\n  return buildASTSchema(document, {\n    commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5235, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/lexicographicSortSchema.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lexicographicSortSchema = lexicographicSortSchema;\n\nvar _objectValues = _interopRequireDefault(require(\"../polyfills/objectValues\"));\n\nvar _inspect = _interopRequireDefault(require(\"../jsutils/inspect\"));\n\nvar _invariant = _interopRequireDefault(require(\"../jsutils/invariant\"));\n\nvar _keyValMap = _interopRequireDefault(require(\"../jsutils/keyValMap\"));\n\nvar _schema = require(\"../type/schema\");\n\nvar _directives = require(\"../type/directives\");\n\nvar _introspection = require(\"../type/introspection\");\n\nvar _definition = require(\"../type/definition\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Sort GraphQLSchema.\n *\n * This function returns a sorted copy of the given GraphQLSchema.\n */\nfunction lexicographicSortSchema(schema) {\n  var schemaConfig = schema.toConfig();\n  var typeMap = (0, _keyValMap.default)(sortByName(schemaConfig.types), function (type) {\n    return type.name;\n  }, sortNamedType);\n  return new _schema.GraphQLSchema(_objectSpread(_objectSpread({}, schemaConfig), {}, {\n    types: (0, _objectValues.default)(typeMap),\n    directives: sortByName(schemaConfig.directives).map(sortDirective),\n    query: replaceMaybeType(schemaConfig.query),\n    mutation: replaceMaybeType(schemaConfig.mutation),\n    subscription: replaceMaybeType(schemaConfig.subscription)\n  }));\n\n  function replaceType(type) {\n    if ((0, _definition.isListType)(type)) {\n      return new _definition.GraphQLList(replaceType(type.ofType));\n    } else if ((0, _definition.isNonNullType)(type)) {\n      return new _definition.GraphQLNonNull(replaceType(type.ofType));\n    }\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n\n  function replaceMaybeType(maybeType) {\n    return maybeType && replaceNamedType(maybeType);\n  }\n\n  function sortDirective(directive) {\n    var config = directive.toConfig();\n    return new _directives.GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {\n      locations: sortBy(config.locations, function (x) {\n        return x;\n      }),\n      args: sortArgs(config.args)\n    }));\n  }\n\n  function sortArgs(args) {\n    return sortObjMap(args, function (arg) {\n      return _objectSpread(_objectSpread({}, arg), {}, {\n        type: replaceType(arg.type)\n      });\n    });\n  }\n\n  function sortFields(fieldsMap) {\n    return sortObjMap(fieldsMap, function (field) {\n      return _objectSpread(_objectSpread({}, field), {}, {\n        type: replaceType(field.type),\n        args: sortArgs(field.args)\n      });\n    });\n  }\n\n  function sortInputFields(fieldsMap) {\n    return sortObjMap(fieldsMap, function (field) {\n      return _objectSpread(_objectSpread({}, field), {}, {\n        type: replaceType(field.type)\n      });\n    });\n  }\n\n  function sortTypes(arr) {\n    return sortByName(arr).map(replaceNamedType);\n  }\n\n  function sortNamedType(type) {\n    if ((0, _definition.isScalarType)(type) || (0, _introspection.isIntrospectionType)(type)) {\n      return type;\n    }\n\n    if ((0, _definition.isObjectType)(type)) {\n      var config = type.toConfig();\n      return new _definition.GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n        interfaces: function interfaces() {\n          return sortTypes(config.interfaces);\n        },\n        fields: function fields() {\n          return sortFields(config.fields);\n        }\n      }));\n    }\n\n    if ((0, _definition.isInterfaceType)(type)) {\n      var _config = type.toConfig();\n\n      return new _definition.GraphQLInterfaceType(_objectSpread(_objectSpread({}, _config), {}, {\n        interfaces: function interfaces() {\n          return sortTypes(_config.interfaces);\n        },\n        fields: function fields() {\n          return sortFields(_config.fields);\n        }\n      }));\n    }\n\n    if ((0, _definition.isUnionType)(type)) {\n      var _config2 = type.toConfig();\n\n      return new _definition.GraphQLUnionType(_objectSpread(_objectSpread({}, _config2), {}, {\n        types: function types() {\n          return sortTypes(_config2.types);\n        }\n      }));\n    }\n\n    if ((0, _definition.isEnumType)(type)) {\n      var _config3 = type.toConfig();\n\n      return new _definition.GraphQLEnumType(_objectSpread(_objectSpread({}, _config3), {}, {\n        values: sortObjMap(_config3.values)\n      }));\n    } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n    if ((0, _definition.isInputObjectType)(type)) {\n      var _config4 = type.toConfig();\n\n      return new _definition.GraphQLInputObjectType(_objectSpread(_objectSpread({}, _config4), {}, {\n        fields: function fields() {\n          return sortInputFields(_config4.fields);\n        }\n      }));\n    } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n    false || (0, _invariant.default)(0, 'Unexpected type: ' + (0, _inspect.default)(type));\n  }\n}\n\nfunction sortObjMap(map, sortValueFn) {\n  var sortedMap = Object.create(null);\n  var sortedKeys = sortBy(Object.keys(map), function (x) {\n    return x;\n  });\n\n  for (var _i2 = 0; _i2 < sortedKeys.length; _i2++) {\n    var key = sortedKeys[_i2];\n    var value = map[key];\n    sortedMap[key] = sortValueFn ? sortValueFn(value) : value;\n  }\n\n  return sortedMap;\n}\n\nfunction sortByName(array) {\n  return sortBy(array, function (obj) {\n    return obj.name;\n  });\n}\n\nfunction sortBy(array, mapToKey) {\n  return array.slice().sort(function (obj1, obj2) {\n    var key1 = mapToKey(obj1);\n    var key2 = mapToKey(obj2);\n    return key1.localeCompare(key2);\n  });\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5440, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/printSchema.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.printSchema = printSchema;\nexports.printIntrospectionSchema = printIntrospectionSchema;\nexports.printType = printType;\n\nvar _objectValues = _interopRequireDefault(require(\"../polyfills/objectValues\"));\n\nvar _inspect = _interopRequireDefault(require(\"../jsutils/inspect\"));\n\nvar _invariant = _interopRequireDefault(require(\"../jsutils/invariant\"));\n\nvar _printer = require(\"../language/printer\");\n\nvar _blockString = require(\"../language/blockString\");\n\nvar _introspection = require(\"../type/introspection\");\n\nvar _scalars = require(\"../type/scalars\");\n\nvar _directives = require(\"../type/directives\");\n\nvar _definition = require(\"../type/definition\");\n\nvar _astFromValue = require(\"./astFromValue\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nfunction printSchema(schema, options) {\n  return printFilteredSchema(schema, function (n) {\n    return !(0, _directives.isSpecifiedDirective)(n);\n  }, isDefinedType, options);\n}\n\nfunction printIntrospectionSchema(schema, options) {\n  return printFilteredSchema(schema, _directives.isSpecifiedDirective, _introspection.isIntrospectionType, options);\n}\n\nfunction isDefinedType(type) {\n  return !(0, _scalars.isSpecifiedScalarType)(type) && !(0, _introspection.isIntrospectionType)(type);\n}\n\nfunction printFilteredSchema(schema, directiveFilter, typeFilter, options) {\n  var directives = schema.getDirectives().filter(directiveFilter);\n  var types = (0, _objectValues.default)(schema.getTypeMap()).filter(typeFilter);\n  return [printSchemaDefinition(schema)].concat(directives.map(function (directive) {\n    return printDirective(directive, options);\n  }), types.map(function (type) {\n    return printType(type, options);\n  })).filter(Boolean).join('\\n\\n') + '\\n';\n}\n\nfunction printSchemaDefinition(schema) {\n  if (schema.description == null && isSchemaOfCommonNames(schema)) {\n    return;\n  }\n\n  var operationTypes = [];\n  var queryType = schema.getQueryType();\n\n  if (queryType) {\n    operationTypes.push(\"  query: \".concat(queryType.name));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType) {\n    operationTypes.push(\"  mutation: \".concat(mutationType.name));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    operationTypes.push(\"  subscription: \".concat(subscriptionType.name));\n  }\n\n  return printDescription({}, schema) + \"schema {\\n\".concat(operationTypes.join('\\n'), \"\\n}\");\n}\n/**\n * GraphQL schema define root types for each type of operation. These types are\n * the same as any other type and can be named in any manner, however there is\n * a common naming convention:\n *\n *   schema {\n *     query: Query\n *     mutation: Mutation\n *   }\n *\n * When using this naming convention, the schema description can be omitted.\n */\n\n\nfunction isSchemaOfCommonNames(schema) {\n  var queryType = schema.getQueryType();\n\n  if (queryType && queryType.name !== 'Query') {\n    return false;\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && mutationType.name !== 'Mutation') {\n    return false;\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && subscriptionType.name !== 'Subscription') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction printType(type, options) {\n  if ((0, _definition.isScalarType)(type)) {\n    return printScalar(type, options);\n  }\n\n  if ((0, _definition.isObjectType)(type)) {\n    return printObject(type, options);\n  }\n\n  if ((0, _definition.isInterfaceType)(type)) {\n    return printInterface(type, options);\n  }\n\n  if ((0, _definition.isUnionType)(type)) {\n    return printUnion(type, options);\n  }\n\n  if ((0, _definition.isEnumType)(type)) {\n    return printEnum(type, options);\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    return printInputObject(type, options);\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || (0, _invariant.default)(0, 'Unexpected type: ' + (0, _inspect.default)(type));\n}\n\nfunction printScalar(type, options) {\n  return printDescription(options, type) + \"scalar \".concat(type.name) + printSpecifiedByUrl(type);\n}\n\nfunction printImplementedInterfaces(type) {\n  var interfaces = type.getInterfaces();\n  return interfaces.length ? ' implements ' + interfaces.map(function (i) {\n    return i.name;\n  }).join(' & ') : '';\n}\n\nfunction printObject(type, options) {\n  return printDescription(options, type) + \"type \".concat(type.name) + printImplementedInterfaces(type) + printFields(options, type);\n}\n\nfunction printInterface(type, options) {\n  return printDescription(options, type) + \"interface \".concat(type.name) + printImplementedInterfaces(type) + printFields(options, type);\n}\n\nfunction printUnion(type, options) {\n  var types = type.getTypes();\n  var possibleTypes = types.length ? ' = ' + types.join(' | ') : '';\n  return printDescription(options, type) + 'union ' + type.name + possibleTypes;\n}\n\nfunction printEnum(type, options) {\n  var values = type.getValues().map(function (value, i) {\n    return printDescription(options, value, '  ', !i) + '  ' + value.name + printDeprecated(value);\n  });\n  return printDescription(options, type) + \"enum \".concat(type.name) + printBlock(values);\n}\n\nfunction printInputObject(type, options) {\n  var fields = (0, _objectValues.default)(type.getFields()).map(function (f, i) {\n    return printDescription(options, f, '  ', !i) + '  ' + printInputValue(f);\n  });\n  return printDescription(options, type) + \"input \".concat(type.name) + printBlock(fields);\n}\n\nfunction printFields(options, type) {\n  var fields = (0, _objectValues.default)(type.getFields()).map(function (f, i) {\n    return printDescription(options, f, '  ', !i) + '  ' + f.name + printArgs(options, f.args, '  ') + ': ' + String(f.type) + printDeprecated(f);\n  });\n  return printBlock(fields);\n}\n\nfunction printBlock(items) {\n  return items.length !== 0 ? ' {\\n' + items.join('\\n') + '\\n}' : '';\n}\n\nfunction printArgs(options, args) {\n  var indentation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n  if (args.length === 0) {\n    return '';\n  } // If every arg does not have a description, print them on one line.\n\n\n  if (args.every(function (arg) {\n    return !arg.description;\n  })) {\n    return '(' + args.map(printInputValue).join(', ') + ')';\n  }\n\n  return '(\\n' + args.map(function (arg, i) {\n    return printDescription(options, arg, '  ' + indentation, !i) + '  ' + indentation + printInputValue(arg);\n  }).join('\\n') + '\\n' + indentation + ')';\n}\n\nfunction printInputValue(arg) {\n  var defaultAST = (0, _astFromValue.astFromValue)(arg.defaultValue, arg.type);\n  var argDecl = arg.name + ': ' + String(arg.type);\n\n  if (defaultAST) {\n    argDecl += \" = \".concat((0, _printer.print)(defaultAST));\n  }\n\n  return argDecl;\n}\n\nfunction printDirective(directive, options) {\n  return printDescription(options, directive) + 'directive @' + directive.name + printArgs(options, directive.args) + (directive.isRepeatable ? ' repeatable' : '') + ' on ' + directive.locations.join(' | ');\n}\n\nfunction printDeprecated(fieldOrEnumVal) {\n  if (!fieldOrEnumVal.isDeprecated) {\n    return '';\n  }\n\n  var reason = fieldOrEnumVal.deprecationReason;\n  var reasonAST = (0, _astFromValue.astFromValue)(reason, _scalars.GraphQLString);\n\n  if (reasonAST && reason !== _directives.DEFAULT_DEPRECATION_REASON) {\n    return ' @deprecated(reason: ' + (0, _printer.print)(reasonAST) + ')';\n  }\n\n  return ' @deprecated';\n}\n\nfunction printSpecifiedByUrl(scalar) {\n  if (scalar.specifiedByUrl == null) {\n    return '';\n  }\n\n  var url = scalar.specifiedByUrl;\n  var urlAST = (0, _astFromValue.astFromValue)(url, _scalars.GraphQLString);\n  urlAST || (0, _invariant.default)(0, 'Unexpected null value returned from `astFromValue` for specifiedByUrl');\n  return ' @specifiedBy(url: ' + (0, _printer.print)(urlAST) + ')';\n}\n\nfunction printDescription(options, def) {\n  var indentation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var firstInBlock = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var description = def.description;\n\n  if (description == null) {\n    return '';\n  }\n\n  if ((options === null || options === void 0 ? void 0 : options.commentDescriptions) === true) {\n    return printDescriptionWithComments(description, indentation, firstInBlock);\n  }\n\n  var preferMultipleLines = description.length > 70;\n  var blockString = (0, _blockString.printBlockString)(description, '', preferMultipleLines);\n  var prefix = indentation && !firstInBlock ? '\\n' + indentation : indentation;\n  return prefix + blockString.replace(/\\n/g, '\\n' + indentation) + '\\n';\n}\n\nfunction printDescriptionWithComments(description, indentation, firstInBlock) {\n  var prefix = indentation && !firstInBlock ? '\\n' : '';\n  var comment = description.split('\\n').map(function (line) {\n    return indentation + (line !== '' ? '# ' + line : '#');\n  }).join('\\n');\n  return prefix + comment + '\\n';\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5669, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/concatAST.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.concatAST = concatAST;\n\nvar _flatMap = _interopRequireDefault(require(\"../polyfills/flatMap\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Provided a collection of ASTs, presumably each from different files,\n * concatenate the ASTs together into batched AST, useful for validating many\n * GraphQL source files which together represent one conceptual application.\n */\nfunction concatAST(asts) {\n  return {\n    kind: 'Document',\n    definitions: (0, _flatMap.default)(asts, function (ast) {\n      return ast.definitions;\n    })\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,SAAS,GAAG;AAEpB,IAAI,WAAW;AAEf,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F;;;;CAIC,GACD,SAAS,UAAU,IAAI;IACrB,OAAO;QACL,MAAM;QACN,aAAa,CAAC,GAAG,SAAS,OAAO,EAAE,MAAM,SAAU,GAAG;YACpD,OAAO,IAAI,WAAW;QACxB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5697, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/separateOperations.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.separateOperations = separateOperations;\n\nvar _kinds = require(\"../language/kinds\");\n\nvar _visitor = require(\"../language/visitor\");\n\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\nfunction separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null);\n  var fromName; // Populate metadata and build a dependency graph.\n\n  (0, _visitor.visit)(documentAST, {\n    OperationDefinition: function OperationDefinition(node) {\n      fromName = opName(node);\n      operations.push(node);\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fromName = node.name.value;\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var toName = node.name.value;\n      var dependents = depGraph[fromName];\n\n      if (dependents === undefined) {\n        dependents = depGraph[fromName] = Object.create(null);\n      }\n\n      dependents[toName] = true;\n    }\n  }); // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  var separatedDocumentASTs = Object.create(null);\n\n  var _loop = function _loop(_i2) {\n    var operation = operations[_i2];\n    var operationName = opName(operation);\n    var dependencies = Object.create(null);\n    collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: _kinds.Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies[node.name.value];\n      })\n    };\n  };\n\n  for (var _i2 = 0; _i2 < operations.length; _i2++) {\n    _loop(_i2);\n  }\n\n  return separatedDocumentASTs;\n}\n\n// Provides the empty string for anonymous operations.\nfunction opName(operation) {\n  return operation.name ? operation.name.value : '';\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  var immediateDeps = depGraph[fromName];\n\n  if (immediateDeps) {\n    for (var _i4 = 0, _Object$keys2 = Object.keys(immediateDeps); _i4 < _Object$keys2.length; _i4++) {\n      var toName = _Object$keys2[_i4];\n\n      if (!collected[toName]) {\n        collected[toName] = true;\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,kBAAkB,GAAG;AAE7B,IAAI;AAEJ,IAAI;AAEJ;;;;;CAKC,GACD,SAAS,mBAAmB,WAAW;IACrC,IAAI,aAAa,EAAE;IACnB,IAAI,WAAW,OAAO,MAAM,CAAC;IAC7B,IAAI,UAAU,kDAAkD;IAEhE,CAAC,GAAG,SAAS,KAAK,EAAE,aAAa;QAC/B,qBAAqB,SAAS,oBAAoB,IAAI;YACpD,WAAW,OAAO;YAClB,WAAW,IAAI,CAAC;QAClB;QACA,oBAAoB,SAAS,mBAAmB,IAAI;YAClD,WAAW,KAAK,IAAI,CAAC,KAAK;QAC5B;QACA,gBAAgB,SAAS,eAAe,IAAI;YAC1C,IAAI,SAAS,KAAK,IAAI,CAAC,KAAK;YAC5B,IAAI,aAAa,QAAQ,CAAC,SAAS;YAEnC,IAAI,eAAe,WAAW;gBAC5B,aAAa,QAAQ,CAAC,SAAS,GAAG,OAAO,MAAM,CAAC;YAClD;YAEA,UAAU,CAAC,OAAO,GAAG;QACvB;IACF,IAAI,6EAA6E;IACjF,8CAA8C;IAE9C,IAAI,wBAAwB,OAAO,MAAM,CAAC;IAE1C,IAAI,QAAQ,SAAS,MAAM,GAAG;QAC5B,IAAI,YAAY,UAAU,CAAC,IAAI;QAC/B,IAAI,gBAAgB,OAAO;QAC3B,IAAI,eAAe,OAAO,MAAM,CAAC;QACjC,8BAA8B,cAAc,UAAU,gBAAgB,yEAAyE;QAC/I,qDAAqD;QAErD,qBAAqB,CAAC,cAAc,GAAG;YACrC,MAAM,OAAO,IAAI,CAAC,QAAQ;YAC1B,aAAa,YAAY,WAAW,CAAC,MAAM,CAAC,SAAU,IAAI;gBACxD,OAAO,SAAS,aAAa,KAAK,IAAI,KAAK,OAAO,IAAI,CAAC,mBAAmB,IAAI,YAAY,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC;YAC7G;QACF;IACF;IAEA,IAAK,IAAI,MAAM,GAAG,MAAM,WAAW,MAAM,EAAE,MAAO;QAChD,MAAM;IACR;IAEA,OAAO;AACT;AAEA,sDAAsD;AACtD,SAAS,OAAO,SAAS;IACvB,OAAO,UAAU,IAAI,GAAG,UAAU,IAAI,CAAC,KAAK,GAAG;AACjD,EAAE,yEAAyE;AAC3E,wCAAwC;AAGxC,SAAS,8BAA8B,SAAS,EAAE,QAAQ,EAAE,QAAQ;IAClE,IAAI,gBAAgB,QAAQ,CAAC,SAAS;IAEtC,IAAI,eAAe;QACjB,IAAK,IAAI,MAAM,GAAG,gBAAgB,OAAO,IAAI,CAAC,gBAAgB,MAAM,cAAc,MAAM,EAAE,MAAO;YAC/F,IAAI,SAAS,aAAa,CAAC,IAAI;YAE/B,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE;gBACtB,SAAS,CAAC,OAAO,GAAG;gBACpB,8BAA8B,WAAW,UAAU;YACrD;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5772, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/stripIgnoredCharacters.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stripIgnoredCharacters = stripIgnoredCharacters;\n\nvar _inspect = _interopRequireDefault(require(\"../jsutils/inspect\"));\n\nvar _source = require(\"../language/source\");\n\nvar _tokenKind = require(\"../language/tokenKind\");\n\nvar _lexer = require(\"../language/lexer\");\n\nvar _blockString = require(\"../language/blockString\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Strips characters that are not significant to the validity or execution\n * of a GraphQL document:\n *   - UnicodeBOM\n *   - WhiteSpace\n *   - LineTerminator\n *   - Comment\n *   - Comma\n *   - BlockString indentation\n *\n * Note: It is required to have a delimiter character between neighboring\n * non-punctuator tokens and this function always uses single space as delimiter.\n *\n * It is guaranteed that both input and output documents if parsed would result\n * in the exact same AST except for nodes location.\n *\n * Warning: It is guaranteed that this function will always produce stable results.\n * However, it's not guaranteed that it will stay the same between different\n * releases due to bugfixes or changes in the GraphQL specification.\n *\n * Query example:\n *\n * query SomeQuery($foo: String!, $bar: String) {\n *   someField(foo: $foo, bar: $bar) {\n *     a\n *     b {\n *       c\n *       d\n *     }\n *   }\n * }\n *\n * Becomes:\n *\n * query SomeQuery($foo:String!$bar:String){someField(foo:$foo bar:$bar){a b{c d}}}\n *\n * SDL example:\n *\n * \"\"\"\n * Type description\n * \"\"\"\n * type Foo {\n *   \"\"\"\n *   Field description\n *   \"\"\"\n *   bar: String\n * }\n *\n * Becomes:\n *\n * \"\"\"Type description\"\"\" type Foo{\"\"\"Field description\"\"\" bar:String}\n */\nfunction stripIgnoredCharacters(source) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n\n  if (!(sourceObj instanceof _source.Source)) {\n    throw new TypeError(\"Must provide string or Source. Received: \".concat((0, _inspect.default)(sourceObj), \".\"));\n  }\n\n  var body = sourceObj.body;\n  var lexer = new _lexer.Lexer(sourceObj);\n  var strippedBody = '';\n  var wasLastAddedTokenNonPunctuator = false;\n\n  while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {\n    var currentToken = lexer.token;\n    var tokenKind = currentToken.kind;\n    /**\n     * Every two non-punctuator tokens should have space between them.\n     * Also prevent case of non-punctuator token following by spread resulting\n     * in invalid token (e.g. `1...` is invalid Float token).\n     */\n\n    var isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(currentToken.kind);\n\n    if (wasLastAddedTokenNonPunctuator) {\n      if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {\n        strippedBody += ' ';\n      }\n    }\n\n    var tokenBody = body.slice(currentToken.start, currentToken.end);\n\n    if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {\n      strippedBody += dedentBlockString(tokenBody);\n    } else {\n      strippedBody += tokenBody;\n    }\n\n    wasLastAddedTokenNonPunctuator = isNonPunctuator;\n  }\n\n  return strippedBody;\n}\n\nfunction dedentBlockString(blockStr) {\n  // skip leading and trailing triple quotations\n  var rawStr = blockStr.slice(3, -3);\n  var body = (0, _blockString.dedentBlockStringValue)(rawStr);\n  var lines = body.split(/\\r\\n|[\\n\\r]/g);\n\n  if ((0, _blockString.getBlockStringIndentation)(lines) > 0) {\n    body = '\\n' + body;\n  }\n\n  var lastChar = body[body.length - 1];\n  var hasTrailingQuote = lastChar === '\"' && body.slice(-4) !== '\\\\\"\"\"';\n\n  if (hasTrailingQuote || lastChar === '\\\\') {\n    body += '\\n';\n  }\n\n  return '\"\"\"' + body + '\"\"\"';\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,sBAAsB,GAAG;AAEjC,IAAI,WAAW;AAEf,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG;AAE9F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmDC,GACD,SAAS,uBAAuB,MAAM;IACpC,IAAI,YAAY,OAAO,WAAW,WAAW,IAAI,QAAQ,MAAM,CAAC,UAAU;IAE1E,IAAI,CAAC,CAAC,qBAAqB,QAAQ,MAAM,GAAG;QAC1C,MAAM,IAAI,UAAU,4CAA4C,MAAM,CAAC,CAAC,GAAG,SAAS,OAAO,EAAE,YAAY;IAC3G;IAEA,IAAI,OAAO,UAAU,IAAI;IACzB,IAAI,QAAQ,IAAI,OAAO,KAAK,CAAC;IAC7B,IAAI,eAAe;IACnB,IAAI,iCAAiC;IAErC,MAAO,MAAM,OAAO,GAAG,IAAI,KAAK,WAAW,SAAS,CAAC,GAAG,CAAE;QACxD,IAAI,eAAe,MAAM,KAAK;QAC9B,IAAI,YAAY,aAAa,IAAI;QACjC;;;;KAIC,GAED,IAAI,kBAAkB,CAAC,CAAC,GAAG,OAAO,qBAAqB,EAAE,aAAa,IAAI;QAE1E,IAAI,gCAAgC;YAClC,IAAI,mBAAmB,aAAa,IAAI,KAAK,WAAW,SAAS,CAAC,MAAM,EAAE;gBACxE,gBAAgB;YAClB;QACF;QAEA,IAAI,YAAY,KAAK,KAAK,CAAC,aAAa,KAAK,EAAE,aAAa,GAAG;QAE/D,IAAI,cAAc,WAAW,SAAS,CAAC,YAAY,EAAE;YACnD,gBAAgB,kBAAkB;QACpC,OAAO;YACL,gBAAgB;QAClB;QAEA,iCAAiC;IACnC;IAEA,OAAO;AACT;AAEA,SAAS,kBAAkB,QAAQ;IACjC,8CAA8C;IAC9C,IAAI,SAAS,SAAS,KAAK,CAAC,GAAG,CAAC;IAChC,IAAI,OAAO,CAAC,GAAG,aAAa,sBAAsB,EAAE;IACpD,IAAI,QAAQ,KAAK,KAAK,CAAC;IAEvB,IAAI,CAAC,GAAG,aAAa,yBAAyB,EAAE,SAAS,GAAG;QAC1D,OAAO,OAAO;IAChB;IAEA,IAAI,WAAW,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE;IACpC,IAAI,mBAAmB,aAAa,OAAO,KAAK,KAAK,CAAC,CAAC,OAAO;IAE9D,IAAI,oBAAoB,aAAa,MAAM;QACzC,QAAQ;IACV;IAEA,OAAO,QAAQ,OAAO;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5890, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/findBreakingChanges.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findBreakingChanges = findBreakingChanges;\nexports.findDangerousChanges = findDangerousChanges;\nexports.DangerousChangeType = exports.BreakingChangeType = void 0;\n\nvar _objectValues = _interopRequireDefault(require(\"../polyfills/objectValues\"));\n\nvar _keyMap = _interopRequireDefault(require(\"../jsutils/keyMap\"));\n\nvar _inspect = _interopRequireDefault(require(\"../jsutils/inspect\"));\n\nvar _invariant = _interopRequireDefault(require(\"../jsutils/invariant\"));\n\nvar _printer = require(\"../language/printer\");\n\nvar _visitor = require(\"../language/visitor\");\n\nvar _scalars = require(\"../type/scalars\");\n\nvar _definition = require(\"../type/definition\");\n\nvar _astFromValue = require(\"./astFromValue\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar BreakingChangeType = Object.freeze({\n  TYPE_REMOVED: 'TYPE_REMOVED',\n  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',\n  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',\n  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',\n  REQUIRED_INPUT_FIELD_ADDED: 'REQUIRED_INPUT_FIELD_ADDED',\n  IMPLEMENTED_INTERFACE_REMOVED: 'IMPLEMENTED_INTERFACE_REMOVED',\n  FIELD_REMOVED: 'FIELD_REMOVED',\n  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',\n  REQUIRED_ARG_ADDED: 'REQUIRED_ARG_ADDED',\n  ARG_REMOVED: 'ARG_REMOVED',\n  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',\n  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',\n  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',\n  REQUIRED_DIRECTIVE_ARG_ADDED: 'REQUIRED_DIRECTIVE_ARG_ADDED',\n  DIRECTIVE_REPEATABLE_REMOVED: 'DIRECTIVE_REPEATABLE_REMOVED',\n  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED'\n});\nexports.BreakingChangeType = BreakingChangeType;\nvar DangerousChangeType = Object.freeze({\n  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',\n  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',\n  OPTIONAL_INPUT_FIELD_ADDED: 'OPTIONAL_INPUT_FIELD_ADDED',\n  OPTIONAL_ARG_ADDED: 'OPTIONAL_ARG_ADDED',\n  IMPLEMENTED_INTERFACE_ADDED: 'IMPLEMENTED_INTERFACE_ADDED',\n  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE'\n});\nexports.DangerousChangeType = DangerousChangeType;\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nfunction findBreakingChanges(oldSchema, newSchema) {\n  var breakingChanges = findSchemaChanges(oldSchema, newSchema).filter(function (change) {\n    return change.type in BreakingChangeType;\n  });\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\n\nfunction findDangerousChanges(oldSchema, newSchema) {\n  var dangerousChanges = findSchemaChanges(oldSchema, newSchema).filter(function (change) {\n    return change.type in DangerousChangeType;\n  });\n  return dangerousChanges;\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [].concat(findTypeChanges(oldSchema, newSchema), findDirectiveChanges(oldSchema, newSchema));\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  var schemaChanges = [];\n  var directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());\n\n  for (var _i2 = 0, _directivesDiff$remov2 = directivesDiff.removed; _i2 < _directivesDiff$remov2.length; _i2++) {\n    var oldDirective = _directivesDiff$remov2[_i2];\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: \"\".concat(oldDirective.name, \" was removed.\")\n    });\n  }\n\n  for (var _i4 = 0, _directivesDiff$persi2 = directivesDiff.persisted; _i4 < _directivesDiff$persi2.length; _i4++) {\n    var _ref2 = _directivesDiff$persi2[_i4];\n    var _oldDirective = _ref2[0];\n    var newDirective = _ref2[1];\n    var argsDiff = diff(_oldDirective.args, newDirective.args);\n\n    for (var _i6 = 0, _argsDiff$added2 = argsDiff.added; _i6 < _argsDiff$added2.length; _i6++) {\n      var newArg = _argsDiff$added2[_i6];\n\n      if ((0, _definition.isRequiredArgument)(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: \"A required arg \".concat(newArg.name, \" on directive \").concat(_oldDirective.name, \" was added.\")\n        });\n      }\n    }\n\n    for (var _i8 = 0, _argsDiff$removed2 = argsDiff.removed; _i8 < _argsDiff$removed2.length; _i8++) {\n      var oldArg = _argsDiff$removed2[_i8];\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: \"\".concat(oldArg.name, \" was removed from \").concat(_oldDirective.name, \".\")\n      });\n    }\n\n    if (_oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: \"Repeatable flag was removed from \".concat(_oldDirective.name, \".\")\n      });\n    }\n\n    for (var _i10 = 0, _oldDirective$locatio2 = _oldDirective.locations; _i10 < _oldDirective$locatio2.length; _i10++) {\n      var location = _oldDirective$locatio2[_i10];\n\n      if (newDirective.locations.indexOf(location) === -1) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: \"\".concat(location, \" was removed from \").concat(_oldDirective.name, \".\")\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  var schemaChanges = [];\n  var typesDiff = diff((0, _objectValues.default)(oldSchema.getTypeMap()), (0, _objectValues.default)(newSchema.getTypeMap()));\n\n  for (var _i12 = 0, _typesDiff$removed2 = typesDiff.removed; _i12 < _typesDiff$removed2.length; _i12++) {\n    var oldType = _typesDiff$removed2[_i12];\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: (0, _scalars.isSpecifiedScalarType)(oldType) ? \"Standard scalar \".concat(oldType.name, \" was removed because it is not referenced anymore.\") : \"\".concat(oldType.name, \" was removed.\")\n    });\n  }\n\n  for (var _i14 = 0, _typesDiff$persisted2 = typesDiff.persisted; _i14 < _typesDiff$persisted2.length; _i14++) {\n    var _ref4 = _typesDiff$persisted2[_i14];\n    var _oldType = _ref4[0];\n    var newType = _ref4[1];\n\n    if ((0, _definition.isEnumType)(_oldType) && (0, _definition.isEnumType)(newType)) {\n      schemaChanges.push.apply(schemaChanges, findEnumTypeChanges(_oldType, newType));\n    } else if ((0, _definition.isUnionType)(_oldType) && (0, _definition.isUnionType)(newType)) {\n      schemaChanges.push.apply(schemaChanges, findUnionTypeChanges(_oldType, newType));\n    } else if ((0, _definition.isInputObjectType)(_oldType) && (0, _definition.isInputObjectType)(newType)) {\n      schemaChanges.push.apply(schemaChanges, findInputObjectTypeChanges(_oldType, newType));\n    } else if ((0, _definition.isObjectType)(_oldType) && (0, _definition.isObjectType)(newType)) {\n      schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType).concat(findImplementedInterfacesChanges(_oldType, newType)));\n    } else if ((0, _definition.isInterfaceType)(_oldType) && (0, _definition.isInterfaceType)(newType)) {\n      schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType).concat(findImplementedInterfacesChanges(_oldType, newType)));\n    } else if (_oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: \"\".concat(_oldType.name, \" changed from \") + \"\".concat(typeKindName(_oldType), \" to \").concat(typeKindName(newType), \".\")\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var fieldsDiff = diff((0, _objectValues.default)(oldType.getFields()), (0, _objectValues.default)(newType.getFields()));\n\n  for (var _i16 = 0, _fieldsDiff$added2 = fieldsDiff.added; _i16 < _fieldsDiff$added2.length; _i16++) {\n    var newField = _fieldsDiff$added2[_i16];\n\n    if ((0, _definition.isRequiredInputField)(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: \"A required field \".concat(newField.name, \" on input type \").concat(oldType.name, \" was added.\")\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: \"An optional field \".concat(newField.name, \" on input type \").concat(oldType.name, \" was added.\")\n      });\n    }\n  }\n\n  for (var _i18 = 0, _fieldsDiff$removed2 = fieldsDiff.removed; _i18 < _fieldsDiff$removed2.length; _i18++) {\n    var oldField = _fieldsDiff$removed2[_i18];\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" was removed.\")\n    });\n  }\n\n  for (var _i20 = 0, _fieldsDiff$persisted2 = fieldsDiff.persisted; _i20 < _fieldsDiff$persisted2.length; _i20++) {\n    var _ref6 = _fieldsDiff$persisted2[_i20];\n    var _oldField = _ref6[0];\n    var _newField = _ref6[1];\n    var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldField.type, _newField.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: \"\".concat(oldType.name, \".\").concat(_oldField.name, \" changed type from \") + \"\".concat(String(_oldField.type), \" to \").concat(String(_newField.type), \".\")\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (var _i22 = 0, _possibleTypesDiff$ad2 = possibleTypesDiff.added; _i22 < _possibleTypesDiff$ad2.length; _i22++) {\n    var newPossibleType = _possibleTypesDiff$ad2[_i22];\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: \"\".concat(newPossibleType.name, \" was added to union type \").concat(oldType.name, \".\")\n    });\n  }\n\n  for (var _i24 = 0, _possibleTypesDiff$re2 = possibleTypesDiff.removed; _i24 < _possibleTypesDiff$re2.length; _i24++) {\n    var oldPossibleType = _possibleTypesDiff$re2[_i24];\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: \"\".concat(oldPossibleType.name, \" was removed from union type \").concat(oldType.name, \".\")\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (var _i26 = 0, _valuesDiff$added2 = valuesDiff.added; _i26 < _valuesDiff$added2.length; _i26++) {\n    var newValue = _valuesDiff$added2[_i26];\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: \"\".concat(newValue.name, \" was added to enum type \").concat(oldType.name, \".\")\n    });\n  }\n\n  for (var _i28 = 0, _valuesDiff$removed2 = valuesDiff.removed; _i28 < _valuesDiff$removed2.length; _i28++) {\n    var oldValue = _valuesDiff$removed2[_i28];\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: \"\".concat(oldValue.name, \" was removed from enum type \").concat(oldType.name, \".\")\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  var schemaChanges = [];\n  var interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (var _i30 = 0, _interfacesDiff$added2 = interfacesDiff.added; _i30 < _interfacesDiff$added2.length; _i30++) {\n    var newInterface = _interfacesDiff$added2[_i30];\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: \"\".concat(newInterface.name, \" added to interfaces implemented by \").concat(oldType.name, \".\")\n    });\n  }\n\n  for (var _i32 = 0, _interfacesDiff$remov2 = interfacesDiff.removed; _i32 < _interfacesDiff$remov2.length; _i32++) {\n    var oldInterface = _interfacesDiff$remov2[_i32];\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: \"\".concat(oldType.name, \" no longer implements interface \").concat(oldInterface.name, \".\")\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  var schemaChanges = [];\n  var fieldsDiff = diff((0, _objectValues.default)(oldType.getFields()), (0, _objectValues.default)(newType.getFields()));\n\n  for (var _i34 = 0, _fieldsDiff$removed4 = fieldsDiff.removed; _i34 < _fieldsDiff$removed4.length; _i34++) {\n    var oldField = _fieldsDiff$removed4[_i34];\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" was removed.\")\n    });\n  }\n\n  for (var _i36 = 0, _fieldsDiff$persisted4 = fieldsDiff.persisted; _i36 < _fieldsDiff$persisted4.length; _i36++) {\n    var _ref8 = _fieldsDiff$persisted4[_i36];\n    var _oldField2 = _ref8[0];\n    var newField = _ref8[1];\n    schemaChanges.push.apply(schemaChanges, findArgChanges(oldType, _oldField2, newField));\n    var isSafe = isChangeSafeForObjectOrInterfaceField(_oldField2.type, newField.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: \"\".concat(oldType.name, \".\").concat(_oldField2.name, \" changed type from \") + \"\".concat(String(_oldField2.type), \" to \").concat(String(newField.type), \".\")\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  var schemaChanges = [];\n  var argsDiff = diff(oldField.args, newField.args);\n\n  for (var _i38 = 0, _argsDiff$removed4 = argsDiff.removed; _i38 < _argsDiff$removed4.length; _i38++) {\n    var oldArg = _argsDiff$removed4[_i38];\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(oldArg.name, \" was removed.\")\n    });\n  }\n\n  for (var _i40 = 0, _argsDiff$persisted2 = argsDiff.persisted; _i40 < _argsDiff$persisted2.length; _i40++) {\n    var _ref10 = _argsDiff$persisted2[_i40];\n    var _oldArg = _ref10[0];\n    var newArg = _ref10[1];\n    var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldArg.type, newArg.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" has changed type from \") + \"\".concat(String(_oldArg.type), \" to \").concat(String(newArg.type), \".\")\n      });\n    } else if (_oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" defaultValue was removed.\")\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        var oldValueStr = stringifyValue(_oldArg.defaultValue, _oldArg.type);\n        var newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" has changed defaultValue from \").concat(oldValueStr, \" to \").concat(newValueStr, \".\")\n          });\n        }\n      }\n    }\n  }\n\n  for (var _i42 = 0, _argsDiff$added4 = argsDiff.added; _i42 < _argsDiff$added4.length; _i42++) {\n    var _newArg = _argsDiff$added4[_i42];\n\n    if ((0, _definition.isRequiredArgument)(_newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: \"A required arg \".concat(_newArg.name, \" on \").concat(oldType.name, \".\").concat(oldField.name, \" was added.\")\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: \"An optional arg \".concat(_newArg.name, \" on \").concat(oldType.name, \".\").concat(oldField.name, \" was added.\")\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if ((0, _definition.isListType)(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  }\n\n  if ((0, _definition.isNonNullType)(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return (// if they're both named types, see if their names are equivalent\n    (0, _definition.isNamedType)(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n    (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if ((0, _definition.isListType)(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  }\n\n  if ((0, _definition.isNonNullType)(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  } // if they're both named types, see if their names are equivalent\n\n\n  return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if ((0, _definition.isScalarType)(type)) {\n    return 'a Scalar type';\n  }\n\n  if ((0, _definition.isObjectType)(type)) {\n    return 'an Object type';\n  }\n\n  if ((0, _definition.isInterfaceType)(type)) {\n    return 'an Interface type';\n  }\n\n  if ((0, _definition.isUnionType)(type)) {\n    return 'a Union type';\n  }\n\n  if ((0, _definition.isEnumType)(type)) {\n    return 'an Enum type';\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    return 'an Input type';\n  } // istanbul ignore next (Not reachable. All possible named types have been considered)\n\n\n  false || (0, _invariant.default)(0, 'Unexpected type: ' + (0, _inspect.default)(type));\n}\n\nfunction stringifyValue(value, type) {\n  var ast = (0, _astFromValue.astFromValue)(value, type);\n  ast != null || (0, _invariant.default)(0);\n  var sortedAST = (0, _visitor.visit)(ast, {\n    ObjectValue: function ObjectValue(objectNode) {\n      var fields = [].concat(objectNode.fields).sort(function (fieldA, fieldB) {\n        return fieldA.name.value.localeCompare(fieldB.name.value);\n      });\n      return _objectSpread(_objectSpread({}, objectNode), {}, {\n        fields: fields\n      });\n    }\n  });\n  return (0, _printer.print)(sortedAST);\n}\n\nfunction diff(oldArray, newArray) {\n  var added = [];\n  var removed = [];\n  var persisted = [];\n  var oldMap = (0, _keyMap.default)(oldArray, function (_ref11) {\n    var name = _ref11.name;\n    return name;\n  });\n  var newMap = (0, _keyMap.default)(newArray, function (_ref12) {\n    var name = _ref12.name;\n    return name;\n  });\n\n  for (var _i44 = 0; _i44 < oldArray.length; _i44++) {\n    var oldItem = oldArray[_i44];\n    var newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (var _i46 = 0; _i46 < newArray.length; _i46++) {\n    var _newItem = newArray[_i46];\n\n    if (oldMap[_newItem.name] === undefined) {\n      added.push(_newItem);\n    }\n  }\n\n  return {\n    added: added,\n    persisted: persisted,\n    removed: removed\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6361, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/findDeprecatedUsages.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findDeprecatedUsages = findDeprecatedUsages;\n\nvar _validate = require(\"../validation/validate\");\n\nvar _NoDeprecatedCustomRule = require(\"../validation/rules/custom/NoDeprecatedCustomRule\");\n\n/**\n * A validation rule which reports deprecated usages.\n *\n * Returns a list of GraphQLError instances describing each deprecated use.\n *\n * @deprecated Please use `validate` with `NoDeprecatedCustomRule` instead:\n *\n * ```\n * import { validate, NoDeprecatedCustomRule } from 'graphql'\n *\n * const errors = validate(schema, document, [NoDeprecatedCustomRule])\n * ```\n */\nfunction findDeprecatedUsages(schema, ast) {\n  return (0, _validate.validate)(schema, ast, [_NoDeprecatedCustomRule.NoDeprecatedCustomRule]);\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,oBAAoB,GAAG;AAE/B,IAAI;AAEJ,IAAI;AAEJ;;;;;;;;;;;;CAYC,GACD,SAAS,qBAAqB,MAAM,EAAE,GAAG;IACvC,OAAO,CAAC,GAAG,UAAU,QAAQ,EAAE,QAAQ,KAAK;QAAC,wBAAwB,sBAAsB;KAAC;AAC9F","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6390, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/utilities/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"getIntrospectionQuery\", {\n  enumerable: true,\n  get: function get() {\n    return _getIntrospectionQuery.getIntrospectionQuery;\n  }\n});\nObject.defineProperty(exports, \"getOperationAST\", {\n  enumerable: true,\n  get: function get() {\n    return _getOperationAST.getOperationAST;\n  }\n});\nObject.defineProperty(exports, \"getOperationRootType\", {\n  enumerable: true,\n  get: function get() {\n    return _getOperationRootType.getOperationRootType;\n  }\n});\nObject.defineProperty(exports, \"introspectionFromSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _introspectionFromSchema.introspectionFromSchema;\n  }\n});\nObject.defineProperty(exports, \"buildClientSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _buildClientSchema.buildClientSchema;\n  }\n});\nObject.defineProperty(exports, \"buildASTSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _buildASTSchema.buildASTSchema;\n  }\n});\nObject.defineProperty(exports, \"buildSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _buildASTSchema.buildSchema;\n  }\n});\nObject.defineProperty(exports, \"extendSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _extendSchema.extendSchema;\n  }\n});\nObject.defineProperty(exports, \"getDescription\", {\n  enumerable: true,\n  get: function get() {\n    return _extendSchema.getDescription;\n  }\n});\nObject.defineProperty(exports, \"lexicographicSortSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _lexicographicSortSchema.lexicographicSortSchema;\n  }\n});\nObject.defineProperty(exports, \"printSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _printSchema.printSchema;\n  }\n});\nObject.defineProperty(exports, \"printType\", {\n  enumerable: true,\n  get: function get() {\n    return _printSchema.printType;\n  }\n});\nObject.defineProperty(exports, \"printIntrospectionSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _printSchema.printIntrospectionSchema;\n  }\n});\nObject.defineProperty(exports, \"typeFromAST\", {\n  enumerable: true,\n  get: function get() {\n    return _typeFromAST.typeFromAST;\n  }\n});\nObject.defineProperty(exports, \"valueFromAST\", {\n  enumerable: true,\n  get: function get() {\n    return _valueFromAST.valueFromAST;\n  }\n});\nObject.defineProperty(exports, \"valueFromASTUntyped\", {\n  enumerable: true,\n  get: function get() {\n    return _valueFromASTUntyped.valueFromASTUntyped;\n  }\n});\nObject.defineProperty(exports, \"astFromValue\", {\n  enumerable: true,\n  get: function get() {\n    return _astFromValue.astFromValue;\n  }\n});\nObject.defineProperty(exports, \"TypeInfo\", {\n  enumerable: true,\n  get: function get() {\n    return _TypeInfo.TypeInfo;\n  }\n});\nObject.defineProperty(exports, \"visitWithTypeInfo\", {\n  enumerable: true,\n  get: function get() {\n    return _TypeInfo.visitWithTypeInfo;\n  }\n});\nObject.defineProperty(exports, \"coerceInputValue\", {\n  enumerable: true,\n  get: function get() {\n    return _coerceInputValue.coerceInputValue;\n  }\n});\nObject.defineProperty(exports, \"concatAST\", {\n  enumerable: true,\n  get: function get() {\n    return _concatAST.concatAST;\n  }\n});\nObject.defineProperty(exports, \"separateOperations\", {\n  enumerable: true,\n  get: function get() {\n    return _separateOperations.separateOperations;\n  }\n});\nObject.defineProperty(exports, \"stripIgnoredCharacters\", {\n  enumerable: true,\n  get: function get() {\n    return _stripIgnoredCharacters.stripIgnoredCharacters;\n  }\n});\nObject.defineProperty(exports, \"isEqualType\", {\n  enumerable: true,\n  get: function get() {\n    return _typeComparators.isEqualType;\n  }\n});\nObject.defineProperty(exports, \"isTypeSubTypeOf\", {\n  enumerable: true,\n  get: function get() {\n    return _typeComparators.isTypeSubTypeOf;\n  }\n});\nObject.defineProperty(exports, \"doTypesOverlap\", {\n  enumerable: true,\n  get: function get() {\n    return _typeComparators.doTypesOverlap;\n  }\n});\nObject.defineProperty(exports, \"assertValidName\", {\n  enumerable: true,\n  get: function get() {\n    return _assertValidName.assertValidName;\n  }\n});\nObject.defineProperty(exports, \"isValidNameError\", {\n  enumerable: true,\n  get: function get() {\n    return _assertValidName.isValidNameError;\n  }\n});\nObject.defineProperty(exports, \"BreakingChangeType\", {\n  enumerable: true,\n  get: function get() {\n    return _findBreakingChanges.BreakingChangeType;\n  }\n});\nObject.defineProperty(exports, \"DangerousChangeType\", {\n  enumerable: true,\n  get: function get() {\n    return _findBreakingChanges.DangerousChangeType;\n  }\n});\nObject.defineProperty(exports, \"findBreakingChanges\", {\n  enumerable: true,\n  get: function get() {\n    return _findBreakingChanges.findBreakingChanges;\n  }\n});\nObject.defineProperty(exports, \"findDangerousChanges\", {\n  enumerable: true,\n  get: function get() {\n    return _findBreakingChanges.findDangerousChanges;\n  }\n});\nObject.defineProperty(exports, \"findDeprecatedUsages\", {\n  enumerable: true,\n  get: function get() {\n    return _findDeprecatedUsages.findDeprecatedUsages;\n  }\n});\n\nvar _getIntrospectionQuery = require(\"./getIntrospectionQuery\");\n\nvar _getOperationAST = require(\"./getOperationAST\");\n\nvar _getOperationRootType = require(\"./getOperationRootType\");\n\nvar _introspectionFromSchema = require(\"./introspectionFromSchema\");\n\nvar _buildClientSchema = require(\"./buildClientSchema\");\n\nvar _buildASTSchema = require(\"./buildASTSchema\");\n\nvar _extendSchema = require(\"./extendSchema\");\n\nvar _lexicographicSortSchema = require(\"./lexicographicSortSchema\");\n\nvar _printSchema = require(\"./printSchema\");\n\nvar _typeFromAST = require(\"./typeFromAST\");\n\nvar _valueFromAST = require(\"./valueFromAST\");\n\nvar _valueFromASTUntyped = require(\"./valueFromASTUntyped\");\n\nvar _astFromValue = require(\"./astFromValue\");\n\nvar _TypeInfo = require(\"./TypeInfo\");\n\nvar _coerceInputValue = require(\"./coerceInputValue\");\n\nvar _concatAST = require(\"./concatAST\");\n\nvar _separateOperations = require(\"./separateOperations\");\n\nvar _stripIgnoredCharacters = require(\"./stripIgnoredCharacters\");\n\nvar _typeComparators = require(\"./typeComparators\");\n\nvar _assertValidName = require(\"./assertValidName\");\n\nvar _findBreakingChanges = require(\"./findBreakingChanges\");\n\nvar _findDeprecatedUsages = require(\"./findDeprecatedUsages\");\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}