module.exports = {

"[project]/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ExecutableDefinitionsRule": ()=>ExecutableDefinitionsRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/kinds.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$predicates$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/predicates.mjs [app-route] (ecmascript)");
;
;
;
function ExecutableDefinitionsRule(context) {
    return {
        Document: function Document(node) {
            for(var _i2 = 0, _node$definitions2 = node.definitions; _i2 < _node$definitions2.length; _i2++){
                var definition = _node$definitions2[_i2];
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$predicates$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isExecutableDefinitionNode"])(definition)) {
                    var defName = definition.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].SCHEMA_DEFINITION || definition.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].SCHEMA_EXTENSION ? 'schema' : '"' + definition.name.value + '"';
                    context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("The ".concat(defName, " definition is not executable."), definition));
                }
            }
            return false;
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "UniqueOperationNamesRule": ()=>UniqueOperationNamesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function UniqueOperationNamesRule(context) {
    var knownOperationNames = Object.create(null);
    return {
        OperationDefinition: function OperationDefinition(node) {
            var operationName = node.name;
            if (operationName) {
                if (knownOperationNames[operationName.value]) {
                    context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("There can be only one operation named \"".concat(operationName.value, "\"."), [
                        knownOperationNames[operationName.value],
                        operationName
                    ]));
                } else {
                    knownOperationNames[operationName.value] = operationName;
                }
            }
            return false;
        },
        FragmentDefinition: function FragmentDefinition() {
            return false;
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "LoneAnonymousOperationRule": ()=>LoneAnonymousOperationRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/kinds.mjs [app-route] (ecmascript)");
;
;
function LoneAnonymousOperationRule(context) {
    var operationCount = 0;
    return {
        Document: function Document(node) {
            operationCount = node.definitions.filter(function(definition) {
                return definition.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].OPERATION_DEFINITION;
            }).length;
        },
        OperationDefinition: function OperationDefinition(node) {
            if (!node.name && operationCount > 1) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]('This anonymous operation must be the only defined operation.', node));
            }
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "SingleFieldSubscriptionsRule": ()=>SingleFieldSubscriptionsRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function SingleFieldSubscriptionsRule(context) {
    return {
        OperationDefinition: function OperationDefinition(node) {
            if (node.operation === 'subscription') {
                if (node.selectionSet.selections.length !== 1) {
                    context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"](node.name ? "Subscription \"".concat(node.name.value, "\" must select only one top level field.") : 'Anonymous Subscription must select only one top level field.', node.selectionSet.selections.slice(1)));
                }
            }
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "KnownTypeNamesRule": ()=>KnownTypeNamesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$didYouMean$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/didYouMean.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$suggestionList$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/suggestionList.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$predicates$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/predicates.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$scalars$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/scalars.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$introspection$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/introspection.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
function KnownTypeNamesRule(context) {
    var schema = context.getSchema();
    var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);
    var definedTypes = Object.create(null);
    for(var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++){
        var def = _context$getDocument$2[_i2];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$predicates$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTypeDefinitionNode"])(def)) {
            definedTypes[def.name.value] = true;
        }
    }
    var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));
    return {
        NamedType: function NamedType(node, _1, parent, _2, ancestors) {
            var typeName = node.name.value;
            if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
                var _ancestors$;
                var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
                var isSDL = definitionNode != null && isSDLNode(definitionNode);
                if (isSDL && isStandardTypeName(typeName)) {
                    return;
                }
                var suggestedTypes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$suggestionList$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Unknown type \"".concat(typeName, "\".") + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$didYouMean$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(suggestedTypes), node));
            }
        }
    };
}
var standardTypeNames = [].concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$scalars$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["specifiedScalarTypes"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$introspection$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["introspectionTypes"]).map(function(type) {
    return type.name;
});
function isStandardTypeName(typeName) {
    return standardTypeNames.indexOf(typeName) !== -1;
}
function isSDLNode(value) {
    return !Array.isArray(value) && ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$predicates$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTypeSystemDefinitionNode"])(value) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$predicates$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTypeSystemExtensionNode"])(value));
}
}),
"[project]/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "FragmentsOnCompositeTypesRule": ()=>FragmentsOnCompositeTypesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/printer.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/definition.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/utilities/typeFromAST.mjs [app-route] (ecmascript)");
;
;
;
;
function FragmentsOnCompositeTypesRule(context) {
    return {
        InlineFragment: function InlineFragment(node) {
            var typeCondition = node.typeCondition;
            if (typeCondition) {
                var type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["typeFromAST"])(context.getSchema(), typeCondition);
                if (type && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isCompositeType"])(type)) {
                    var typeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["print"])(typeCondition);
                    context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Fragment cannot condition on non composite type \"".concat(typeStr, "\"."), typeCondition));
                }
            }
        },
        FragmentDefinition: function FragmentDefinition(node) {
            var type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["typeFromAST"])(context.getSchema(), node.typeCondition);
            if (type && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isCompositeType"])(type)) {
                var typeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["print"])(node.typeCondition);
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Fragment \"".concat(node.name.value, "\" cannot condition on non composite type \"").concat(typeStr, "\"."), node.typeCondition));
            }
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "VariablesAreInputTypesRule": ()=>VariablesAreInputTypesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/printer.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/definition.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/utilities/typeFromAST.mjs [app-route] (ecmascript)");
;
;
;
;
function VariablesAreInputTypesRule(context) {
    return {
        VariableDefinition: function VariableDefinition(node) {
            var type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["typeFromAST"])(context.getSchema(), node.type);
            if (type && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isInputType"])(type)) {
                var variableName = node.variable.name.value;
                var typeName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["print"])(node.type);
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Variable \"$".concat(variableName, "\" cannot be non-input type \"").concat(typeName, "\"."), node.type));
            }
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/ScalarLeafsRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ScalarLeafsRule": ()=>ScalarLeafsRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/inspect.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/definition.mjs [app-route] (ecmascript)");
;
;
;
function ScalarLeafsRule(context) {
    return {
        Field: function Field(node) {
            var type = context.getType();
            var selectionSet = node.selectionSet;
            if (type) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isLeafType"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getNamedType"])(type))) {
                    if (selectionSet) {
                        var fieldName = node.name.value;
                        var typeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(type);
                        context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Field \"".concat(fieldName, "\" must not have a selection since type \"").concat(typeStr, "\" has no subfields."), selectionSet));
                    }
                } else if (!selectionSet) {
                    var _fieldName = node.name.value;
                    var _typeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(type);
                    context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Field \"".concat(_fieldName, "\" of type \"").concat(_typeStr, "\" must have a selection of subfields. Did you mean \"").concat(_fieldName, " { ... }\"?"), node));
                }
            }
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "FieldsOnCorrectTypeRule": ()=>FieldsOnCorrectTypeRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$polyfills$2f$arrayFrom$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/polyfills/arrayFrom.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$didYouMean$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/didYouMean.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$suggestionList$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/suggestionList.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/definition.mjs [app-route] (ecmascript)");
;
;
;
;
;
function FieldsOnCorrectTypeRule(context) {
    return {
        Field: function Field(node) {
            var type = context.getParentType();
            if (type) {
                var fieldDef = context.getFieldDef();
                if (!fieldDef) {
                    // This field doesn't exist, lets look for suggestions.
                    var schema = context.getSchema();
                    var fieldName = node.name.value; // First determine if there are any suggested types to condition on.
                    var suggestion = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$didYouMean$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])('to use an inline fragment on', getSuggestedTypeNames(schema, type, fieldName)); // If there are no suggested types, then perhaps this was a typo?
                    if (suggestion === '') {
                        suggestion = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$didYouMean$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(getSuggestedFieldNames(type, fieldName));
                    } // Report an error, including helpful suggestions.
                    context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Cannot query field \"".concat(fieldName, "\" on type \"").concat(type.name, "\".") + suggestion, node));
                }
            }
        }
    };
}
/**
 * Go through all of the implementations of type, as well as the interfaces that
 * they implement. If any of those types include the provided field, suggest them,
 * sorted by how often the type is referenced.
 */ function getSuggestedTypeNames(schema, type, fieldName) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isAbstractType"])(type)) {
        // Must be an Object type, which does not have possible fields.
        return [];
    }
    var suggestedTypes = new Set();
    var usageCount = Object.create(null);
    for(var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++){
        var possibleType = _schema$getPossibleTy2[_i2];
        if (!possibleType.getFields()[fieldName]) {
            continue;
        } // This object type defines this field.
        suggestedTypes.add(possibleType);
        usageCount[possibleType.name] = 1;
        for(var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++){
            var _usageCount$possibleI;
            var possibleInterface = _possibleType$getInte2[_i4];
            if (!possibleInterface.getFields()[fieldName]) {
                continue;
            } // This interface type defines this field.
            suggestedTypes.add(possibleInterface);
            usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$polyfills$2f$arrayFrom$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(suggestedTypes).sort(function(typeA, typeB) {
        // Suggest both interface and object types based on how common they are.
        var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
        if (usageCountDiff !== 0) {
            return usageCountDiff;
        } // Suggest super types first followed by subtypes
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isInterfaceType"])(typeA) && schema.isSubType(typeA, typeB)) {
            return -1;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isInterfaceType"])(typeB) && schema.isSubType(typeB, typeA)) {
            return 1;
        }
        return typeA.name.localeCompare(typeB.name);
    }).map(function(x) {
        return x.name;
    });
}
/**
 * For the field name provided, determine if there are any similar field names
 * that may be the result of a typo.
 */ function getSuggestedFieldNames(type, fieldName) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isObjectType"])(type) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isInterfaceType"])(type)) {
        var possibleFieldNames = Object.keys(type.getFields());
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$suggestionList$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(fieldName, possibleFieldNames);
    } // Otherwise, must be a Union type, which does not define fields.
    return [];
}
}),
"[project]/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "UniqueFragmentNamesRule": ()=>UniqueFragmentNamesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function UniqueFragmentNamesRule(context) {
    var knownFragmentNames = Object.create(null);
    return {
        OperationDefinition: function OperationDefinition() {
            return false;
        },
        FragmentDefinition: function FragmentDefinition(node) {
            var fragmentName = node.name.value;
            if (knownFragmentNames[fragmentName]) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("There can be only one fragment named \"".concat(fragmentName, "\"."), [
                    knownFragmentNames[fragmentName],
                    node.name
                ]));
            } else {
                knownFragmentNames[fragmentName] = node.name;
            }
            return false;
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "KnownFragmentNamesRule": ()=>KnownFragmentNamesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function KnownFragmentNamesRule(context) {
    return {
        FragmentSpread: function FragmentSpread(node) {
            var fragmentName = node.name.value;
            var fragment = context.getFragment(fragmentName);
            if (!fragment) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Unknown fragment \"".concat(fragmentName, "\"."), node.name));
            }
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "NoUnusedFragmentsRule": ()=>NoUnusedFragmentsRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function NoUnusedFragmentsRule(context) {
    var operationDefs = [];
    var fragmentDefs = [];
    return {
        OperationDefinition: function OperationDefinition(node) {
            operationDefs.push(node);
            return false;
        },
        FragmentDefinition: function FragmentDefinition(node) {
            fragmentDefs.push(node);
            return false;
        },
        Document: {
            leave: function leave() {
                var fragmentNameUsed = Object.create(null);
                for(var _i2 = 0; _i2 < operationDefs.length; _i2++){
                    var operation = operationDefs[_i2];
                    for(var _i4 = 0, _context$getRecursive2 = context.getRecursivelyReferencedFragments(operation); _i4 < _context$getRecursive2.length; _i4++){
                        var fragment = _context$getRecursive2[_i4];
                        fragmentNameUsed[fragment.name.value] = true;
                    }
                }
                for(var _i6 = 0; _i6 < fragmentDefs.length; _i6++){
                    var fragmentDef = fragmentDefs[_i6];
                    var fragName = fragmentDef.name.value;
                    if (fragmentNameUsed[fragName] !== true) {
                        context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Fragment \"".concat(fragName, "\" is never used."), fragmentDef));
                    }
                }
            }
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "PossibleFragmentSpreadsRule": ()=>PossibleFragmentSpreadsRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/inspect.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/definition.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/utilities/typeFromAST.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeComparators$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/utilities/typeComparators.mjs [app-route] (ecmascript)");
;
;
;
;
;
function PossibleFragmentSpreadsRule(context) {
    return {
        InlineFragment: function InlineFragment(node) {
            var fragType = context.getType();
            var parentType = context.getParentType();
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isCompositeType"])(fragType) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isCompositeType"])(parentType) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeComparators$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["doTypesOverlap"])(context.getSchema(), fragType, parentType)) {
                var parentTypeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(parentType);
                var fragTypeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(fragType);
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Fragment cannot be spread here as objects of type \"".concat(parentTypeStr, "\" can never be of type \"").concat(fragTypeStr, "\"."), node));
            }
        },
        FragmentSpread: function FragmentSpread(node) {
            var fragName = node.name.value;
            var fragType = getFragmentType(context, fragName);
            var parentType = context.getParentType();
            if (fragType && parentType && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeComparators$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["doTypesOverlap"])(context.getSchema(), fragType, parentType)) {
                var parentTypeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(parentType);
                var fragTypeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(fragType);
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Fragment \"".concat(fragName, "\" cannot be spread here as objects of type \"").concat(parentTypeStr, "\" can never be of type \"").concat(fragTypeStr, "\"."), node));
            }
        }
    };
}
function getFragmentType(context, name) {
    var frag = context.getFragment(name);
    if (frag) {
        var type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["typeFromAST"])(context.getSchema(), frag.typeCondition);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isCompositeType"])(type)) {
            return type;
        }
    }
}
}),
"[project]/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "NoFragmentCyclesRule": ()=>NoFragmentCyclesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function NoFragmentCyclesRule(context) {
    // Tracks already visited fragments to maintain O(N) and to ensure that cycles
    // are not redundantly reported.
    var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors
    var spreadPath = []; // Position in the spread path
    var spreadPathIndexByName = Object.create(null);
    return {
        OperationDefinition: function OperationDefinition() {
            return false;
        },
        FragmentDefinition: function FragmentDefinition(node) {
            detectCycleRecursive(node);
            return false;
        }
    }; // This does a straight-forward DFS to find cycles.
    //TURBOPACK unreachable
    ;
    // It does not terminate when a cycle was found but continues to explore
    // the graph to find all possible cycles.
    function detectCycleRecursive(fragment) {
        if (visitedFrags[fragment.name.value]) {
            return;
        }
        var fragmentName = fragment.name.value;
        visitedFrags[fragmentName] = true;
        var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
        if (spreadNodes.length === 0) {
            return;
        }
        spreadPathIndexByName[fragmentName] = spreadPath.length;
        for(var _i2 = 0; _i2 < spreadNodes.length; _i2++){
            var spreadNode = spreadNodes[_i2];
            var spreadName = spreadNode.name.value;
            var cycleIndex = spreadPathIndexByName[spreadName];
            spreadPath.push(spreadNode);
            if (cycleIndex === undefined) {
                var spreadFragment = context.getFragment(spreadName);
                if (spreadFragment) {
                    detectCycleRecursive(spreadFragment);
                }
            } else {
                var cyclePath = spreadPath.slice(cycleIndex);
                var viaPath = cyclePath.slice(0, -1).map(function(s) {
                    return '"' + s.name.value + '"';
                }).join(', ');
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Cannot spread fragment \"".concat(spreadName, "\" within itself") + (viaPath !== '' ? " via ".concat(viaPath, ".") : '.'), cyclePath));
            }
            spreadPath.pop();
        }
        spreadPathIndexByName[fragmentName] = undefined;
    }
}
}),
"[project]/node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "UniqueVariableNamesRule": ()=>UniqueVariableNamesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function UniqueVariableNamesRule(context) {
    var knownVariableNames = Object.create(null);
    return {
        OperationDefinition: function OperationDefinition() {
            knownVariableNames = Object.create(null);
        },
        VariableDefinition: function VariableDefinition(node) {
            var variableName = node.variable.name.value;
            if (knownVariableNames[variableName]) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("There can be only one variable named \"$".concat(variableName, "\"."), [
                    knownVariableNames[variableName],
                    node.variable.name
                ]));
            } else {
                knownVariableNames[variableName] = node.variable.name;
            }
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "NoUndefinedVariablesRule": ()=>NoUndefinedVariablesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function NoUndefinedVariablesRule(context) {
    var variableNameDefined = Object.create(null);
    return {
        OperationDefinition: {
            enter: function enter() {
                variableNameDefined = Object.create(null);
            },
            leave: function leave(operation) {
                var usages = context.getRecursiveVariableUsages(operation);
                for(var _i2 = 0; _i2 < usages.length; _i2++){
                    var _ref2 = usages[_i2];
                    var node = _ref2.node;
                    var varName = node.name.value;
                    if (variableNameDefined[varName] !== true) {
                        context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"](operation.name ? "Variable \"$".concat(varName, "\" is not defined by operation \"").concat(operation.name.value, "\".") : "Variable \"$".concat(varName, "\" is not defined."), [
                            node,
                            operation
                        ]));
                    }
                }
            }
        },
        VariableDefinition: function VariableDefinition(node) {
            variableNameDefined[node.variable.name.value] = true;
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "NoUnusedVariablesRule": ()=>NoUnusedVariablesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function NoUnusedVariablesRule(context) {
    var variableDefs = [];
    return {
        OperationDefinition: {
            enter: function enter() {
                variableDefs = [];
            },
            leave: function leave(operation) {
                var variableNameUsed = Object.create(null);
                var usages = context.getRecursiveVariableUsages(operation);
                for(var _i2 = 0; _i2 < usages.length; _i2++){
                    var _ref2 = usages[_i2];
                    var node = _ref2.node;
                    variableNameUsed[node.name.value] = true;
                }
                for(var _i4 = 0, _variableDefs2 = variableDefs; _i4 < _variableDefs2.length; _i4++){
                    var variableDef = _variableDefs2[_i4];
                    var variableName = variableDef.variable.name.value;
                    if (variableNameUsed[variableName] !== true) {
                        context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"](operation.name ? "Variable \"$".concat(variableName, "\" is never used in operation \"").concat(operation.name.value, "\".") : "Variable \"$".concat(variableName, "\" is never used."), variableDef));
                    }
                }
            }
        },
        VariableDefinition: function VariableDefinition(def) {
            variableDefs.push(def);
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/KnownDirectivesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "KnownDirectivesRule": ()=>KnownDirectivesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/inspect.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$invariant$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/invariant.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/kinds.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/directiveLocation.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$directives$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/directives.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
function KnownDirectivesRule(context) {
    var locationsMap = Object.create(null);
    var schema = context.getSchema();
    var definedDirectives = schema ? schema.getDirectives() : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$directives$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["specifiedDirectives"];
    for(var _i2 = 0; _i2 < definedDirectives.length; _i2++){
        var directive = definedDirectives[_i2];
        locationsMap[directive.name] = directive.locations;
    }
    var astDefinitions = context.getDocument().definitions;
    for(var _i4 = 0; _i4 < astDefinitions.length; _i4++){
        var def = astDefinitions[_i4];
        if (def.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].DIRECTIVE_DEFINITION) {
            locationsMap[def.name.value] = def.locations.map(function(name) {
                return name.value;
            });
        }
    }
    return {
        Directive: function Directive(node, _key, _parent, _path, ancestors) {
            var name = node.name.value;
            var locations = locationsMap[name];
            if (!locations) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Unknown directive \"@".concat(name, "\"."), node));
                return;
            }
            var candidateLocation = getDirectiveLocationForASTPath(ancestors);
            if (candidateLocation && locations.indexOf(candidateLocation) === -1) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Directive \"@".concat(name, "\" may not be used on ").concat(candidateLocation, "."), node));
            }
        }
    };
}
function getDirectiveLocationForASTPath(ancestors) {
    var appliedTo = ancestors[ancestors.length - 1];
    !Array.isArray(appliedTo) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$invariant$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(0);
    switch(appliedTo.kind){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].OPERATION_DEFINITION:
            return getDirectiveLocationForOperation(appliedTo.operation);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].FIELD:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].FIELD;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].FRAGMENT_SPREAD:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].FRAGMENT_SPREAD;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INLINE_FRAGMENT:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].INLINE_FRAGMENT;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].FRAGMENT_DEFINITION:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].FRAGMENT_DEFINITION;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].VARIABLE_DEFINITION:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].VARIABLE_DEFINITION;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].SCHEMA_DEFINITION:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].SCHEMA_EXTENSION:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].SCHEMA;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].SCALAR_TYPE_DEFINITION:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].SCALAR_TYPE_EXTENSION:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].SCALAR;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].OBJECT_TYPE_DEFINITION:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].OBJECT_TYPE_EXTENSION:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].OBJECT;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].FIELD_DEFINITION:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].FIELD_DEFINITION;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INTERFACE_TYPE_DEFINITION:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INTERFACE_TYPE_EXTENSION:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].INTERFACE;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].UNION_TYPE_DEFINITION:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].UNION_TYPE_EXTENSION:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].UNION;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].ENUM_TYPE_DEFINITION:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].ENUM_TYPE_EXTENSION:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].ENUM;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].ENUM_VALUE_DEFINITION:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].ENUM_VALUE;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INPUT_OBJECT_TYPE_DEFINITION:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INPUT_OBJECT_TYPE_EXTENSION:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].INPUT_OBJECT;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INPUT_VALUE_DEFINITION:
            {
                var parentNode = ancestors[ancestors.length - 3];
                return parentNode.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INPUT_OBJECT_TYPE_DEFINITION ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].INPUT_FIELD_DEFINITION : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].ARGUMENT_DEFINITION;
            }
    }
}
function getDirectiveLocationForOperation(operation) {
    switch(operation){
        case 'query':
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].QUERY;
        case 'mutation':
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].MUTATION;
        case 'subscription':
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$directiveLocation$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DirectiveLocation"].SUBSCRIPTION;
    } // istanbul ignore next (Not reachable. All possible types have been considered)
    false || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$invariant$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(0, 'Unexpected operation: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(operation));
}
}),
"[project]/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "UniqueDirectivesPerLocationRule": ()=>UniqueDirectivesPerLocationRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/kinds.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$predicates$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/predicates.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$directives$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/directives.mjs [app-route] (ecmascript)");
;
;
;
;
function UniqueDirectivesPerLocationRule(context) {
    var uniqueDirectiveMap = Object.create(null);
    var schema = context.getSchema();
    var definedDirectives = schema ? schema.getDirectives() : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$directives$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["specifiedDirectives"];
    for(var _i2 = 0; _i2 < definedDirectives.length; _i2++){
        var directive = definedDirectives[_i2];
        uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
    }
    var astDefinitions = context.getDocument().definitions;
    for(var _i4 = 0; _i4 < astDefinitions.length; _i4++){
        var def = astDefinitions[_i4];
        if (def.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].DIRECTIVE_DEFINITION) {
            uniqueDirectiveMap[def.name.value] = !def.repeatable;
        }
    }
    var schemaDirectives = Object.create(null);
    var typeDirectivesMap = Object.create(null);
    return {
        // Many different AST nodes may contain directives. Rather than listing
        // them all, just listen for entering any node, and check to see if it
        // defines any directives.
        enter: function enter(node) {
            if (node.directives == null) {
                return;
            }
            var seenDirectives;
            if (node.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].SCHEMA_DEFINITION || node.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].SCHEMA_EXTENSION) {
                seenDirectives = schemaDirectives;
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$predicates$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTypeDefinitionNode"])(node) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$predicates$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTypeExtensionNode"])(node)) {
                var typeName = node.name.value;
                seenDirectives = typeDirectivesMap[typeName];
                if (seenDirectives === undefined) {
                    typeDirectivesMap[typeName] = seenDirectives = Object.create(null);
                }
            } else {
                seenDirectives = Object.create(null);
            }
            for(var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++){
                var _directive = _node$directives2[_i6];
                var directiveName = _directive.name.value;
                if (uniqueDirectiveMap[directiveName]) {
                    if (seenDirectives[directiveName]) {
                        context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("The directive \"@".concat(directiveName, "\" can only be used once at this location."), [
                            seenDirectives[directiveName],
                            _directive
                        ]));
                    } else {
                        seenDirectives[directiveName] = _directive;
                    }
                }
            }
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "KnownArgumentNamesOnDirectivesRule": ()=>KnownArgumentNamesOnDirectivesRule,
    "KnownArgumentNamesRule": ()=>KnownArgumentNamesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$didYouMean$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/didYouMean.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$suggestionList$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/suggestionList.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/kinds.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$directives$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/directives.mjs [app-route] (ecmascript)");
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
;
;
;
;
;
function KnownArgumentNamesRule(context) {
    return _objectSpread(_objectSpread({}, KnownArgumentNamesOnDirectivesRule(context)), {}, {
        Argument: function Argument(argNode) {
            var argDef = context.getArgument();
            var fieldDef = context.getFieldDef();
            var parentType = context.getParentType();
            if (!argDef && fieldDef && parentType) {
                var argName = argNode.name.value;
                var knownArgsNames = fieldDef.args.map(function(arg) {
                    return arg.name;
                });
                var suggestions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$suggestionList$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(argName, knownArgsNames);
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Unknown argument \"".concat(argName, "\" on field \"").concat(parentType.name, ".").concat(fieldDef.name, "\".") + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$didYouMean$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(suggestions), argNode));
            }
        }
    });
}
function KnownArgumentNamesOnDirectivesRule(context) {
    var directiveArgs = Object.create(null);
    var schema = context.getSchema();
    var definedDirectives = schema ? schema.getDirectives() : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$directives$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["specifiedDirectives"];
    for(var _i2 = 0; _i2 < definedDirectives.length; _i2++){
        var directive = definedDirectives[_i2];
        directiveArgs[directive.name] = directive.args.map(function(arg) {
            return arg.name;
        });
    }
    var astDefinitions = context.getDocument().definitions;
    for(var _i4 = 0; _i4 < astDefinitions.length; _i4++){
        var def = astDefinitions[_i4];
        if (def.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].DIRECTIVE_DEFINITION) {
            var _def$arguments;
            // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
            var argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            directiveArgs[def.name.value] = argsNodes.map(function(arg) {
                return arg.name.value;
            });
        }
    }
    return {
        Directive: function Directive(directiveNode) {
            var directiveName = directiveNode.name.value;
            var knownArgs = directiveArgs[directiveName];
            if (directiveNode.arguments && knownArgs) {
                for(var _i6 = 0, _directiveNode$argume2 = directiveNode.arguments; _i6 < _directiveNode$argume2.length; _i6++){
                    var argNode = _directiveNode$argume2[_i6];
                    var argName = argNode.name.value;
                    if (knownArgs.indexOf(argName) === -1) {
                        var suggestions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$suggestionList$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(argName, knownArgs);
                        context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Unknown argument \"".concat(argName, "\" on directive \"@").concat(directiveName, "\".") + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$didYouMean$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(suggestions), argNode));
                    }
                }
            }
            return false;
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "UniqueArgumentNamesRule": ()=>UniqueArgumentNamesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function UniqueArgumentNamesRule(context) {
    var knownArgNames = Object.create(null);
    return {
        Field: function Field() {
            knownArgNames = Object.create(null);
        },
        Directive: function Directive() {
            knownArgNames = Object.create(null);
        },
        Argument: function Argument(node) {
            var argName = node.name.value;
            if (knownArgNames[argName]) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("There can be only one argument named \"".concat(argName, "\"."), [
                    knownArgNames[argName],
                    node.name
                ]));
            } else {
                knownArgNames[argName] = node.name;
            }
            return false;
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ValuesOfCorrectTypeRule": ()=>ValuesOfCorrectTypeRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$polyfills$2f$objectValues$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/polyfills/objectValues.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$keyMap$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/keyMap.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/inspect.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$didYouMean$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/didYouMean.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$suggestionList$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/suggestionList.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/printer.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/definition.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
function ValuesOfCorrectTypeRule(context) {
    return {
        ListValue: function ListValue(node) {
            // Note: TypeInfo will traverse into a list's item type, so look to the
            // parent input type to check if it is a list.
            var type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getNullableType"])(context.getParentInputType());
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isListType"])(type)) {
                isValidValueNode(context, node);
                return false; // Don't traverse further.
            }
        },
        ObjectValue: function ObjectValue(node) {
            var type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getNamedType"])(context.getInputType());
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isInputObjectType"])(type)) {
                isValidValueNode(context, node);
                return false; // Don't traverse further.
            } // Ensure every required field exists.
            var fieldNodeMap = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$keyMap$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(node.fields, function(field) {
                return field.name.value;
            });
            for(var _i2 = 0, _objectValues2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$polyfills$2f$objectValues$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(type.getFields()); _i2 < _objectValues2.length; _i2++){
                var fieldDef = _objectValues2[_i2];
                var fieldNode = fieldNodeMap[fieldDef.name];
                if (!fieldNode && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRequiredInputField"])(fieldDef)) {
                    var typeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(fieldDef.type);
                    context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Field \"".concat(type.name, ".").concat(fieldDef.name, "\" of required type \"").concat(typeStr, "\" was not provided."), node));
                }
            }
        },
        ObjectField: function ObjectField(node) {
            var parentType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getNamedType"])(context.getParentInputType());
            var fieldType = context.getInputType();
            if (!fieldType && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isInputObjectType"])(parentType)) {
                var suggestions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$suggestionList$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(node.name.value, Object.keys(parentType.getFields()));
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Field \"".concat(node.name.value, "\" is not defined by type \"").concat(parentType.name, "\".") + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$didYouMean$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(suggestions), node));
            }
        },
        NullValue: function NullValue(node) {
            var type = context.getInputType();
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isNonNullType"])(type)) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Expected value of type \"".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(type), "\", found ").concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["print"])(node), "."), node));
            }
        },
        EnumValue: function EnumValue(node) {
            return isValidValueNode(context, node);
        },
        IntValue: function IntValue(node) {
            return isValidValueNode(context, node);
        },
        FloatValue: function FloatValue(node) {
            return isValidValueNode(context, node);
        },
        StringValue: function StringValue(node) {
            return isValidValueNode(context, node);
        },
        BooleanValue: function BooleanValue(node) {
            return isValidValueNode(context, node);
        }
    };
}
/**
 * Any value literal may be a valid representation of a Scalar, depending on
 * that scalar type.
 */ function isValidValueNode(context, node) {
    // Report any error at the full type expected by the location.
    var locationType = context.getInputType();
    if (!locationType) {
        return;
    }
    var type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getNamedType"])(locationType);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isLeafType"])(type)) {
        var typeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(locationType);
        context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Expected value of type \"".concat(typeStr, "\", found ").concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["print"])(node), "."), node));
        return;
    } // Scalars and Enums determine if a literal value is valid via parseLiteral(),
    // which may throw or return an invalid value to indicate failure.
    try {
        var parseResult = type.parseLiteral(node, undefined);
        if (parseResult === undefined) {
            var _typeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(locationType);
            context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Expected value of type \"".concat(_typeStr, "\", found ").concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["print"])(node), "."), node));
        }
    } catch (error) {
        var _typeStr2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(locationType);
        if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]) {
            context.reportError(error);
        } else {
            context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Expected value of type \"".concat(_typeStr2, "\", found ").concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["print"])(node), "; ") + error.message, node, undefined, undefined, undefined, error));
        }
    }
}
}),
"[project]/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ProvidedRequiredArgumentsOnDirectivesRule": ()=>ProvidedRequiredArgumentsOnDirectivesRule,
    "ProvidedRequiredArgumentsRule": ()=>ProvidedRequiredArgumentsRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/inspect.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$keyMap$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/keyMap.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/kinds.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/printer.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$directives$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/directives.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/definition.mjs [app-route] (ecmascript)");
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
;
;
;
;
;
;
;
function ProvidedRequiredArgumentsRule(context) {
    return _objectSpread(_objectSpread({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {}, {
        Field: {
            // Validate on leave to allow for deeper errors to appear first.
            leave: function leave(fieldNode) {
                var _fieldNode$arguments;
                var fieldDef = context.getFieldDef();
                if (!fieldDef) {
                    return false;
                } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
                var argNodes = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];
                var argNodeMap = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$keyMap$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(argNodes, function(arg) {
                    return arg.name.value;
                });
                for(var _i2 = 0, _fieldDef$args2 = fieldDef.args; _i2 < _fieldDef$args2.length; _i2++){
                    var argDef = _fieldDef$args2[_i2];
                    var argNode = argNodeMap[argDef.name];
                    if (!argNode && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRequiredArgument"])(argDef)) {
                        var argTypeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(argDef.type);
                        context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Field \"".concat(fieldDef.name, "\" argument \"").concat(argDef.name, "\" of type \"").concat(argTypeStr, "\" is required, but it was not provided."), fieldNode));
                    }
                }
            }
        }
    });
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
    var requiredArgsMap = Object.create(null);
    var schema = context.getSchema();
    var definedDirectives = schema ? schema.getDirectives() : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$directives$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["specifiedDirectives"];
    for(var _i4 = 0; _i4 < definedDirectives.length; _i4++){
        var directive = definedDirectives[_i4];
        requiredArgsMap[directive.name] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$keyMap$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(directive.args.filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isRequiredArgument"]), function(arg) {
            return arg.name;
        });
    }
    var astDefinitions = context.getDocument().definitions;
    for(var _i6 = 0; _i6 < astDefinitions.length; _i6++){
        var def = astDefinitions[_i6];
        if (def.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].DIRECTIVE_DEFINITION) {
            var _def$arguments;
            // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
            var argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            requiredArgsMap[def.name.value] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$keyMap$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(argNodes.filter(isRequiredArgumentNode), function(arg) {
                return arg.name.value;
            });
        }
    }
    return {
        Directive: {
            // Validate on leave to allow for deeper errors to appear first.
            leave: function leave(directiveNode) {
                var directiveName = directiveNode.name.value;
                var requiredArgs = requiredArgsMap[directiveName];
                if (requiredArgs) {
                    var _directiveNode$argume;
                    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
                    var _argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
                    var argNodeMap = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$keyMap$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(_argNodes, function(arg) {
                        return arg.name.value;
                    });
                    for(var _i8 = 0, _Object$keys2 = Object.keys(requiredArgs); _i8 < _Object$keys2.length; _i8++){
                        var argName = _Object$keys2[_i8];
                        if (!argNodeMap[argName]) {
                            var argType = requiredArgs[argName].type;
                            var argTypeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isType"])(argType) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(argType) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["print"])(argType);
                            context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Directive \"@".concat(directiveName, "\" argument \"").concat(argName, "\" of type \"").concat(argTypeStr, "\" is required, but it was not provided."), directiveNode));
                        }
                    }
                }
            }
        }
    };
}
function isRequiredArgumentNode(arg) {
    return arg.type.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].NON_NULL_TYPE && arg.defaultValue == null;
}
}),
"[project]/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "VariablesInAllowedPositionRule": ()=>VariablesInAllowedPositionRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/inspect.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/kinds.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/definition.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/utilities/typeFromAST.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeComparators$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/utilities/typeComparators.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
function VariablesInAllowedPositionRule(context) {
    var varDefMap = Object.create(null);
    return {
        OperationDefinition: {
            enter: function enter() {
                varDefMap = Object.create(null);
            },
            leave: function leave(operation) {
                var usages = context.getRecursiveVariableUsages(operation);
                for(var _i2 = 0; _i2 < usages.length; _i2++){
                    var _ref2 = usages[_i2];
                    var node = _ref2.node;
                    var type = _ref2.type;
                    var defaultValue = _ref2.defaultValue;
                    var varName = node.name.value;
                    var varDef = varDefMap[varName];
                    if (varDef && type) {
                        // A var type is allowed if it is the same or more strict (e.g. is
                        // a subtype of) than the expected type. It can be more strict if
                        // the variable type is non-null when the expected type is nullable.
                        // If both are list types, the variable item type can be more strict
                        // than the expected item type (contravariant).
                        var schema = context.getSchema();
                        var varType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["typeFromAST"])(schema, varDef.type);
                        if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
                            var varTypeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(varType);
                            var typeStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(type);
                            context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Variable \"$".concat(varName, "\" of type \"").concat(varTypeStr, "\" used in position expecting type \"").concat(typeStr, "\"."), [
                                varDef,
                                node
                            ]));
                        }
                    }
                }
            }
        },
        VariableDefinition: function VariableDefinition(node) {
            varDefMap[node.variable.name.value] = node;
        }
    };
}
/**
 * Returns true if the variable is allowed in the location it was found,
 * which includes considering if default values exist for either the variable
 * or the location at which it is located.
 */ function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isNonNullType"])(locationType) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isNonNullType"])(varType)) {
        var hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].NULL;
        var hasLocationDefaultValue = locationDefaultValue !== undefined;
        if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
            return false;
        }
        var nullableLocationType = locationType.ofType;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeComparators$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTypeSubTypeOf"])(schema, varType, nullableLocationType);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeComparators$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTypeSubTypeOf"])(schema, varType, locationType);
}
}),
"[project]/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "OverlappingFieldsCanBeMergedRule": ()=>OverlappingFieldsCanBeMergedRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$polyfills$2f$find$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/polyfills/find.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$polyfills$2f$objectEntries$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/polyfills/objectEntries.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/inspect.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/kinds.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/printer.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/definition.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/utilities/typeFromAST.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
function reasonMessage(reason) {
    if (Array.isArray(reason)) {
        return reason.map(function(_ref) {
            var responseName = _ref[0], subReason = _ref[1];
            return "subfields \"".concat(responseName, "\" conflict because ") + reasonMessage(subReason);
        }).join(' and ');
    }
    return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
    // A memoization for when two fragments are compared "between" each other for
    // conflicts. Two fragments may be compared many times, so memoizing this can
    // dramatically improve the performance of this validator.
    var comparedFragmentPairs = new PairSet(); // A cache for the "field map" and list of fragment names found in any given
    // selection set. Selection sets may be asked for this information multiple
    // times, so this improves the performance of this validator.
    var cachedFieldsAndFragmentNames = new Map();
    return {
        SelectionSet: function SelectionSet(selectionSet) {
            var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
            for(var _i2 = 0; _i2 < conflicts.length; _i2++){
                var _ref3 = conflicts[_i2];
                var _ref2$ = _ref3[0];
                var responseName = _ref2$[0];
                var reason = _ref2$[1];
                var fields1 = _ref3[1];
                var fields2 = _ref3[2];
                var reasonMsg = reasonMessage(reason);
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Fields \"".concat(responseName, "\" conflict because ").concat(reasonMsg, ". Use different aliases on the fields to fetch both if this was intentional."), fields1.concat(fields2)));
            }
        }
    };
}
/**
 * Algorithm:
 *
 * Conflicts occur when two fields exist in a query which will produce the same
 * response name, but represent differing values, thus creating a conflict.
 * The algorithm below finds all conflicts via making a series of comparisons
 * between fields. In order to compare as few fields as possible, this makes
 * a series of comparisons "within" sets of fields and "between" sets of fields.
 *
 * Given any selection set, a collection produces both a set of fields by
 * also including all inline fragments, as well as a list of fragments
 * referenced by fragment spreads.
 *
 * A) Each selection set represented in the document first compares "within" its
 * collected set of fields, finding any conflicts between every pair of
 * overlapping fields.
 * Note: This is the *only time* that a the fields "within" a set are compared
 * to each other. After this only fields "between" sets are compared.
 *
 * B) Also, if any fragment is referenced in a selection set, then a
 * comparison is made "between" the original set of fields and the
 * referenced fragment.
 *
 * C) Also, if multiple fragments are referenced, then comparisons
 * are made "between" each referenced fragment.
 *
 * D) When comparing "between" a set of fields and a referenced fragment, first
 * a comparison is made between each field in the original set of fields and
 * each field in the the referenced set of fields.
 *
 * E) Also, if any fragment is referenced in the referenced selection set,
 * then a comparison is made "between" the original set of fields and the
 * referenced fragment (recursively referring to step D).
 *
 * F) When comparing "between" two fragments, first a comparison is made between
 * each field in the first referenced set of fields and each field in the the
 * second referenced set of fields.
 *
 * G) Also, any fragments referenced by the first must be compared to the
 * second, and any fragments referenced by the second must be compared to the
 * first (recursively referring to step F).
 *
 * H) When comparing two fields, if both have selection sets, then a comparison
 * is made "between" both selection sets, first comparing the set of fields in
 * the first selection set with the set of fields in the second.
 *
 * I) Also, if any fragment is referenced in either selection set, then a
 * comparison is made "between" the other set of fields and the
 * referenced fragment.
 *
 * J) Also, if two fragments are referenced in both selection sets, then a
 * comparison is made "between" the two fragments.
 *
 */ // Find all conflicts found "within" a selection set, including those found
// via spreading in fragments. Called when visiting each SelectionSet in the
// GraphQL Document.
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
    var conflicts = [];
    var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet), fieldMap = _getFieldsAndFragment[0], fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts "within" the fields of this selection set.
    // Note: this is the *only place* `collectConflictsWithin` is called.
    collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
    if (fragmentNames.length !== 0) {
        // (B) Then collect conflicts between these fields and those represented by
        // each spread fragment name found.
        for(var i = 0; i < fragmentNames.length; i++){
            collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this
            // selection set to collect conflicts between fragments spread together.
            // This compares each item in the list of fragment names to every other
            // item in that same list (except for itself).
            for(var j = i + 1; j < fragmentNames.length; j++){
                collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
            }
        }
    }
    return conflicts;
} // Collect all conflicts found between a set of fields and a fragment reference
// including via spreading in any nested fragments.
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
    var fragment = context.getFragment(fragmentName);
    if (!fragment) {
        return;
    }
    var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment), fieldMap2 = _getReferencedFieldsA[0], fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.
    if (fieldMap === fieldMap2) {
        return;
    } // (D) First collect any conflicts between the provided collection of fields
    // and the collection of fields represented by the given fragment.
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields
    // and any fragment names found in the given fragment.
    for(var i = 0; i < fragmentNames2.length; i++){
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);
    }
} // Collect all conflicts found between two fragments, including via spreading in
// any nested fragments.
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
    // No need to compare a fragment to itself.
    if (fragmentName1 === fragmentName2) {
        return;
    } // Memoize so two fragments are not compared for conflicts more than once.
    if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
        return;
    }
    comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
    var fragment1 = context.getFragment(fragmentName1);
    var fragment2 = context.getFragment(fragmentName2);
    if (!fragment1 || !fragment2) {
        return;
    }
    var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1), fieldMap1 = _getReferencedFieldsA2[0], fragmentNames1 = _getReferencedFieldsA2[1];
    var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2), fieldMap2 = _getReferencedFieldsA3[0], fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields
    // (not including any nested fragments).
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested
    // fragments spread in the second fragment.
    for(var j = 0; j < fragmentNames2.length; j++){
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);
    } // (G) Then collect conflicts between the second fragment and any nested
    // fragments spread in the first fragment.
    for(var i = 0; i < fragmentNames1.length; i++){
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);
    }
} // Find all conflicts found between two selection sets, including those found
// via spreading in fragments. Called when determining if conflicts exist
// between the sub-fields of two overlapping fields.
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
    var conflicts = [];
    var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1), fieldMap1 = _getFieldsAndFragment2[0], fragmentNames1 = _getFieldsAndFragment2[1];
    var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2), fieldMap2 = _getFieldsAndFragment3[0], fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and
    // those referenced by each fragment name associated with the second.
    if (fragmentNames2.length !== 0) {
        for(var j = 0; j < fragmentNames2.length; j++){
            collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);
        }
    } // (I) Then collect conflicts between the second collection of fields and
    // those referenced by each fragment name associated with the first.
    if (fragmentNames1.length !== 0) {
        for(var i = 0; i < fragmentNames1.length; i++){
            collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);
        }
    } // (J) Also collect conflicts between any fragment names by the first and
    // fragment names by the second. This compares each item in the first set of
    // names to each item in the second set of names.
    for(var _i3 = 0; _i3 < fragmentNames1.length; _i3++){
        for(var _j = 0; _j < fragmentNames2.length; _j++){
            collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i3], fragmentNames2[_j]);
        }
    }
    return conflicts;
} // Collect all Conflicts "within" one collection of fields.
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
    // A field map is a keyed collection, where each key represents a response
    // name and the value at that key is a list of all fields which provide that
    // response name. For every response name, if there are multiple fields, they
    // must be compared to find a potential conflict.
    for(var _i5 = 0, _objectEntries2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$polyfills$2f$objectEntries$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(fieldMap); _i5 < _objectEntries2.length; _i5++){
        var _ref5 = _objectEntries2[_i5];
        var responseName = _ref5[0];
        var fields = _ref5[1];
        // This compares every field in the list to every other field in this list
        // (except to itself). If the list only has one item, nothing needs to
        // be compared.
        if (fields.length > 1) {
            for(var i = 0; i < fields.length; i++){
                for(var j = i + 1; j < fields.length; j++){
                    var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
                    if (conflict) {
                        conflicts.push(conflict);
                    }
                }
            }
        }
    }
} // Collect all Conflicts between two collections of fields. This is similar to,
// but different from the `collectConflictsWithin` function above. This check
// assumes that `collectConflictsWithin` has already been called on each
// provided collection of fields. This is true because this validator traverses
// each individual selection set.
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
    // A field map is a keyed collection, where each key represents a response
    // name and the value at that key is a list of all fields which provide that
    // response name. For any response name which appears in both provided field
    // maps, each field from the first field map must be compared to every field
    // in the second field map to find potential conflicts.
    for(var _i7 = 0, _Object$keys2 = Object.keys(fieldMap1); _i7 < _Object$keys2.length; _i7++){
        var responseName = _Object$keys2[_i7];
        var fields2 = fieldMap2[responseName];
        if (fields2) {
            var fields1 = fieldMap1[responseName];
            for(var i = 0; i < fields1.length; i++){
                for(var j = 0; j < fields2.length; j++){
                    var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);
                    if (conflict) {
                        conflicts.push(conflict);
                    }
                }
            }
        }
    }
} // Determines if there is a conflict between two particular fields, including
// comparing their sub-fields.
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
    var parentType1 = field1[0], node1 = field1[1], def1 = field1[2];
    var parentType2 = field2[0], node2 = field2[1], def2 = field2[2]; // If it is known that two fields could not possibly apply at the same
    // time, due to the parent types, then it is safe to permit them to diverge
    // in aliased field or arguments used as they will not present any ambiguity
    // by differing.
    // It is known that two parent types could never overlap if they are
    // different Object types. Interface or Union types might overlap - if not
    // in the current state of the schema, then perhaps in some future version,
    // thus may not safely diverge.
    var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isObjectType"])(parentType1) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isObjectType"])(parentType2);
    if (!areMutuallyExclusive) {
        var _node1$arguments, _node2$arguments;
        // Two aliases must refer to the same field.
        var name1 = node1.name.value;
        var name2 = node2.name.value;
        if (name1 !== name2) {
            return [
                [
                    responseName,
                    "\"".concat(name1, "\" and \"").concat(name2, "\" are different fields")
                ],
                [
                    node1
                ],
                [
                    node2
                ]
            ];
        } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
        var args1 = (_node1$arguments = node1.arguments) !== null && _node1$arguments !== void 0 ? _node1$arguments : []; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
        var args2 = (_node2$arguments = node2.arguments) !== null && _node2$arguments !== void 0 ? _node2$arguments : []; // Two field calls must have the same arguments.
        if (!sameArguments(args1, args2)) {
            return [
                [
                    responseName,
                    'they have differing arguments'
                ],
                [
                    node1
                ],
                [
                    node2
                ]
            ];
        }
    } // The return type for each field.
    var type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
    var type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
    if (type1 && type2 && doTypesConflict(type1, type2)) {
        return [
            [
                responseName,
                "they return conflicting types \"".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(type1), "\" and \"").concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(type2), "\"")
            ],
            [
                node1
            ],
            [
                node2
            ]
        ];
    } // Collect and compare sub-fields. Use the same "visited fragment names" list
    // for both collections so fields in a fragment reference are never
    // compared to themselves.
    var selectionSet1 = node1.selectionSet;
    var selectionSet2 = node2.selectionSet;
    if (selectionSet1 && selectionSet2) {
        var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getNamedType"])(type1), selectionSet1, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getNamedType"])(type2), selectionSet2);
        return subfieldConflicts(conflicts, responseName, node1, node2);
    }
}
function sameArguments(arguments1, arguments2) {
    if (arguments1.length !== arguments2.length) {
        return false;
    }
    return arguments1.every(function(argument1) {
        var argument2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$polyfills$2f$find$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(arguments2, function(argument) {
            return argument.name.value === argument1.name.value;
        });
        if (!argument2) {
            return false;
        }
        return sameValue(argument1.value, argument2.value);
    });
}
function sameValue(value1, value2) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["print"])(value1) === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["print"])(value2);
} // Two types conflict if both types could not apply to a value simultaneously.
// Composite types are ignored as their individual field types will be compared
// later recursively. However List and Non-Null types must match.
function doTypesConflict(type1, type2) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isListType"])(type1)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isListType"])(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isListType"])(type2)) {
        return true;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isNonNullType"])(type1)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isNonNullType"])(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isNonNullType"])(type2)) {
        return true;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isLeafType"])(type1) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isLeafType"])(type2)) {
        return type1 !== type2;
    }
    return false;
} // Given a selection set, return the collection of fields (a mapping of response
// name to field nodes and definitions) as well as a list of fragment names
// referenced via fragment spreads.
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
    var cached = cachedFieldsAndFragmentNames.get(selectionSet);
    if (!cached) {
        var nodeAndDefs = Object.create(null);
        var fragmentNames = Object.create(null);
        _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
        cached = [
            nodeAndDefs,
            Object.keys(fragmentNames)
        ];
        cachedFieldsAndFragmentNames.set(selectionSet, cached);
    }
    return cached;
} // Given a reference to a fragment, return the represented collection of fields
// as well as a list of nested fragment names referenced via fragment spreads.
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
    // Short-circuit building a type from the node if possible.
    var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
    if (cached) {
        return cached;
    }
    var fragmentType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["typeFromAST"])(context.getSchema(), fragment.typeCondition);
    return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
    for(var _i9 = 0, _selectionSet$selecti2 = selectionSet.selections; _i9 < _selectionSet$selecti2.length; _i9++){
        var selection = _selectionSet$selecti2[_i9];
        switch(selection.kind){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].FIELD:
                {
                    var fieldName = selection.name.value;
                    var fieldDef = void 0;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isObjectType"])(parentType) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isInterfaceType"])(parentType)) {
                        fieldDef = parentType.getFields()[fieldName];
                    }
                    var responseName = selection.alias ? selection.alias.value : fieldName;
                    if (!nodeAndDefs[responseName]) {
                        nodeAndDefs[responseName] = [];
                    }
                    nodeAndDefs[responseName].push([
                        parentType,
                        selection,
                        fieldDef
                    ]);
                    break;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].FRAGMENT_SPREAD:
                fragmentNames[selection.name.value] = true;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INLINE_FRAGMENT:
                {
                    var typeCondition = selection.typeCondition;
                    var inlineFragmentType = typeCondition ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["typeFromAST"])(context.getSchema(), typeCondition) : parentType;
                    _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
                    break;
                }
        }
    }
} // Given a series of Conflicts which occurred between two sub-fields, generate
// a single Conflict.
function subfieldConflicts(conflicts, responseName, node1, node2) {
    if (conflicts.length > 0) {
        return [
            [
                responseName,
                conflicts.map(function(_ref6) {
                    var reason = _ref6[0];
                    return reason;
                })
            ],
            conflicts.reduce(function(allFields, _ref7) {
                var fields1 = _ref7[1];
                return allFields.concat(fields1);
            }, [
                node1
            ]),
            conflicts.reduce(function(allFields, _ref8) {
                var fields2 = _ref8[2];
                return allFields.concat(fields2);
            }, [
                node2
            ])
        ];
    }
}
/**
 * A way to keep track of pairs of things when the ordering of the pair does
 * not matter. We do this by maintaining a sort of double adjacency sets.
 */ var PairSet = /*#__PURE__*/ function() {
    function PairSet() {
        this._data = Object.create(null);
    }
    var _proto = PairSet.prototype;
    _proto.has = function has(a, b, areMutuallyExclusive) {
        var first = this._data[a];
        var result = first && first[b];
        if (result === undefined) {
            return false;
        } // areMutuallyExclusive being false is a superset of being true,
        // hence if we want to know if this PairSet "has" these two with no
        // exclusivity, we have to ensure it was added as such.
        if (areMutuallyExclusive === false) {
            return result === false;
        }
        return true;
    };
    _proto.add = function add(a, b, areMutuallyExclusive) {
        _pairSetAdd(this._data, a, b, areMutuallyExclusive);
        _pairSetAdd(this._data, b, a, areMutuallyExclusive);
    };
    return PairSet;
}();
function _pairSetAdd(data, a, b, areMutuallyExclusive) {
    var map = data[a];
    if (!map) {
        map = Object.create(null);
        data[a] = map;
    }
    map[b] = areMutuallyExclusive;
}
}),
"[project]/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "UniqueInputFieldNamesRule": ()=>UniqueInputFieldNamesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function UniqueInputFieldNamesRule(context) {
    var knownNameStack = [];
    var knownNames = Object.create(null);
    return {
        ObjectValue: {
            enter: function enter() {
                knownNameStack.push(knownNames);
                knownNames = Object.create(null);
            },
            leave: function leave() {
                knownNames = knownNameStack.pop();
            }
        },
        ObjectField: function ObjectField(node) {
            var fieldName = node.name.value;
            if (knownNames[fieldName]) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("There can be only one input field named \"".concat(fieldName, "\"."), [
                    knownNames[fieldName],
                    node.name
                ]));
            } else {
                knownNames[fieldName] = node.name;
            }
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "LoneSchemaDefinitionRule": ()=>LoneSchemaDefinitionRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function LoneSchemaDefinitionRule(context) {
    var _ref, _ref2, _oldSchema$astNode;
    var oldSchema = context.getSchema();
    var alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
    var schemaDefinitionsCount = 0;
    return {
        SchemaDefinition: function SchemaDefinition(node) {
            if (alreadyDefined) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]('Cannot define a new schema within a schema extension.', node));
                return;
            }
            if (schemaDefinitionsCount > 0) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]('Must provide only one schema definition.', node));
            }
            ++schemaDefinitionsCount;
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "UniqueOperationTypesRule": ()=>UniqueOperationTypesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function UniqueOperationTypesRule(context) {
    var schema = context.getSchema();
    var definedOperationTypes = Object.create(null);
    var existingOperationTypes = schema ? {
        query: schema.getQueryType(),
        mutation: schema.getMutationType(),
        subscription: schema.getSubscriptionType()
    } : {};
    return {
        SchemaDefinition: checkOperationTypes,
        SchemaExtension: checkOperationTypes
    };
    //TURBOPACK unreachable
    ;
    function checkOperationTypes(node) {
        var _node$operationTypes;
        // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
        var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
        for(var _i2 = 0; _i2 < operationTypesNodes.length; _i2++){
            var operationType = operationTypesNodes[_i2];
            var operation = operationType.operation;
            var alreadyDefinedOperationType = definedOperationTypes[operation];
            if (existingOperationTypes[operation]) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Type for ".concat(operation, " already defined in the schema. It cannot be redefined."), operationType));
            } else if (alreadyDefinedOperationType) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("There can be only one ".concat(operation, " type in schema."), [
                    alreadyDefinedOperationType,
                    operationType
                ]));
            } else {
                definedOperationTypes[operation] = operationType;
            }
        }
        return false;
    }
}
}),
"[project]/node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "UniqueTypeNamesRule": ()=>UniqueTypeNamesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function UniqueTypeNamesRule(context) {
    var knownTypeNames = Object.create(null);
    var schema = context.getSchema();
    return {
        ScalarTypeDefinition: checkTypeName,
        ObjectTypeDefinition: checkTypeName,
        InterfaceTypeDefinition: checkTypeName,
        UnionTypeDefinition: checkTypeName,
        EnumTypeDefinition: checkTypeName,
        InputObjectTypeDefinition: checkTypeName
    };
    //TURBOPACK unreachable
    ;
    function checkTypeName(node) {
        var typeName = node.name.value;
        if (schema === null || schema === void 0 ? void 0 : schema.getType(typeName)) {
            context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Type \"".concat(typeName, "\" already exists in the schema. It cannot also be defined in this type definition."), node.name));
            return;
        }
        if (knownTypeNames[typeName]) {
            context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("There can be only one type named \"".concat(typeName, "\"."), [
                knownTypeNames[typeName],
                node.name
            ]));
        } else {
            knownTypeNames[typeName] = node.name;
        }
        return false;
    }
}
}),
"[project]/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "UniqueEnumValueNamesRule": ()=>UniqueEnumValueNamesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/definition.mjs [app-route] (ecmascript)");
;
;
function UniqueEnumValueNamesRule(context) {
    var schema = context.getSchema();
    var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
    var knownValueNames = Object.create(null);
    return {
        EnumTypeDefinition: checkValueUniqueness,
        EnumTypeExtension: checkValueUniqueness
    };
    //TURBOPACK unreachable
    ;
    function checkValueUniqueness(node) {
        var _node$values;
        var typeName = node.name.value;
        if (!knownValueNames[typeName]) {
            knownValueNames[typeName] = Object.create(null);
        } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
        var valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
        var valueNames = knownValueNames[typeName];
        for(var _i2 = 0; _i2 < valueNodes.length; _i2++){
            var valueDef = valueNodes[_i2];
            var valueName = valueDef.name.value;
            var existingType = existingTypeMap[typeName];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isEnumType"])(existingType) && existingType.getValue(valueName)) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Enum value \"".concat(typeName, ".").concat(valueName, "\" already exists in the schema. It cannot also be defined in this type extension."), valueDef.name));
            } else if (valueNames[valueName]) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Enum value \"".concat(typeName, ".").concat(valueName, "\" can only be defined once."), [
                    valueNames[valueName],
                    valueDef.name
                ]));
            } else {
                valueNames[valueName] = valueDef.name;
            }
        }
        return false;
    }
}
}),
"[project]/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "UniqueFieldDefinitionNamesRule": ()=>UniqueFieldDefinitionNamesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/definition.mjs [app-route] (ecmascript)");
;
;
function UniqueFieldDefinitionNamesRule(context) {
    var schema = context.getSchema();
    var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
    var knownFieldNames = Object.create(null);
    return {
        InputObjectTypeDefinition: checkFieldUniqueness,
        InputObjectTypeExtension: checkFieldUniqueness,
        InterfaceTypeDefinition: checkFieldUniqueness,
        InterfaceTypeExtension: checkFieldUniqueness,
        ObjectTypeDefinition: checkFieldUniqueness,
        ObjectTypeExtension: checkFieldUniqueness
    };
    //TURBOPACK unreachable
    ;
    function checkFieldUniqueness(node) {
        var _node$fields;
        var typeName = node.name.value;
        if (!knownFieldNames[typeName]) {
            knownFieldNames[typeName] = Object.create(null);
        } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
        var fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
        var fieldNames = knownFieldNames[typeName];
        for(var _i2 = 0; _i2 < fieldNodes.length; _i2++){
            var fieldDef = fieldNodes[_i2];
            var fieldName = fieldDef.name.value;
            if (hasField(existingTypeMap[typeName], fieldName)) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Field \"".concat(typeName, ".").concat(fieldName, "\" already exists in the schema. It cannot also be defined in this type extension."), fieldDef.name));
            } else if (fieldNames[fieldName]) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Field \"".concat(typeName, ".").concat(fieldName, "\" can only be defined once."), [
                    fieldNames[fieldName],
                    fieldDef.name
                ]));
            } else {
                fieldNames[fieldName] = fieldDef.name;
            }
        }
        return false;
    }
}
function hasField(type, fieldName) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isObjectType"])(type) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isInterfaceType"])(type) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isInputObjectType"])(type)) {
        return type.getFields()[fieldName];
    }
    return false;
}
}),
"[project]/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "UniqueDirectiveNamesRule": ()=>UniqueDirectiveNamesRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
;
function UniqueDirectiveNamesRule(context) {
    var knownDirectiveNames = Object.create(null);
    var schema = context.getSchema();
    return {
        DirectiveDefinition: function DirectiveDefinition(node) {
            var directiveName = node.name.value;
            if (schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName)) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Directive \"@".concat(directiveName, "\" already exists in the schema. It cannot be redefined."), node.name));
                return;
            }
            if (knownDirectiveNames[directiveName]) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("There can be only one directive named \"@".concat(directiveName, "\"."), [
                    knownDirectiveNames[directiveName],
                    node.name
                ]));
            } else {
                knownDirectiveNames[directiveName] = node.name;
            }
            return false;
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "PossibleTypeExtensionsRule": ()=>PossibleTypeExtensionsRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/inspect.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$invariant$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/invariant.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$didYouMean$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/didYouMean.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$suggestionList$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/suggestionList.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/kinds.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$predicates$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/predicates.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/definition.mjs [app-route] (ecmascript)");
var _defKindToExtKind;
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
;
;
;
;
;
;
;
;
function PossibleTypeExtensionsRule(context) {
    var schema = context.getSchema();
    var definedTypes = Object.create(null);
    for(var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++){
        var def = _context$getDocument$2[_i2];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$predicates$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTypeDefinitionNode"])(def)) {
            definedTypes[def.name.value] = def;
        }
    }
    return {
        ScalarTypeExtension: checkExtension,
        ObjectTypeExtension: checkExtension,
        InterfaceTypeExtension: checkExtension,
        UnionTypeExtension: checkExtension,
        EnumTypeExtension: checkExtension,
        InputObjectTypeExtension: checkExtension
    };
    //TURBOPACK unreachable
    ;
    function checkExtension(node) {
        var typeName = node.name.value;
        var defNode = definedTypes[typeName];
        var existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
        var expectedKind;
        if (defNode) {
            expectedKind = defKindToExtKind[defNode.kind];
        } else if (existingType) {
            expectedKind = typeToExtKind(existingType);
        }
        if (expectedKind) {
            if (expectedKind !== node.kind) {
                var kindStr = extensionKindToTypeName(node.kind);
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Cannot extend non-".concat(kindStr, " type \"").concat(typeName, "\"."), defNode ? [
                    defNode,
                    node
                ] : node));
            }
        } else {
            var allTypeNames = Object.keys(definedTypes);
            if (schema) {
                allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));
            }
            var suggestedTypes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$suggestionList$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(typeName, allTypeNames);
            context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("Cannot extend type \"".concat(typeName, "\" because it is not defined.") + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$didYouMean$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(suggestedTypes), node.name));
        }
    }
}
var defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].SCALAR_TYPE_DEFINITION, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].OBJECT_TYPE_DEFINITION, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INTERFACE_TYPE_DEFINITION, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].UNION_TYPE_DEFINITION, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].ENUM_TYPE_DEFINITION, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INPUT_OBJECT_TYPE_DEFINITION, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);
function typeToExtKind(type) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isScalarType"])(type)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].SCALAR_TYPE_EXTENSION;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isObjectType"])(type)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].OBJECT_TYPE_EXTENSION;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isInterfaceType"])(type)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INTERFACE_TYPE_EXTENSION;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isUnionType"])(type)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].UNION_TYPE_EXTENSION;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isEnumType"])(type)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].ENUM_TYPE_EXTENSION;
    } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isInputObjectType"])(type)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INPUT_OBJECT_TYPE_EXTENSION;
    } // istanbul ignore next (Not reachable. All possible types have been considered)
    false || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$invariant$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(0, 'Unexpected type: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(type));
}
function extensionKindToTypeName(kind) {
    switch(kind){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].SCALAR_TYPE_EXTENSION:
            return 'scalar';
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].OBJECT_TYPE_EXTENSION:
            return 'object';
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INTERFACE_TYPE_EXTENSION:
            return 'interface';
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].UNION_TYPE_EXTENSION:
            return 'union';
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].ENUM_TYPE_EXTENSION:
            return 'enum';
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].INPUT_OBJECT_TYPE_EXTENSION:
            return 'input object';
    } // istanbul ignore next (Not reachable. All possible types have been considered)
    false || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$invariant$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(0, 'Unexpected kind: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(kind));
}
}),
"[project]/node_modules/graphql/validation/specifiedRules.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// Spec Section: "Executable Definitions"
__turbopack_context__.s({
    "specifiedRules": ()=>specifiedRules,
    "specifiedSDLRules": ()=>specifiedSDLRules
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$ExecutableDefinitionsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs [app-route] (ecmascript)"); // Spec Section: "Operation Name Uniqueness"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueOperationNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs [app-route] (ecmascript)"); // Spec Section: "Lone Anonymous Operation"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$LoneAnonymousOperationRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs [app-route] (ecmascript)"); // Spec Section: "Subscriptions with Single Root Field"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$SingleFieldSubscriptionsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs [app-route] (ecmascript)"); // Spec Section: "Fragment Spread Type Existence"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$KnownTypeNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs [app-route] (ecmascript)"); // Spec Section: "Fragments on Composite Types"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$FragmentsOnCompositeTypesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs [app-route] (ecmascript)"); // Spec Section: "Variables are Input Types"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$VariablesAreInputTypesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs [app-route] (ecmascript)"); // Spec Section: "Leaf Field Selections"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$ScalarLeafsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/ScalarLeafsRule.mjs [app-route] (ecmascript)"); // Spec Section: "Field Selections on Objects, Interfaces, and Unions Types"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$FieldsOnCorrectTypeRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs [app-route] (ecmascript)"); // Spec Section: "Fragment Name Uniqueness"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueFragmentNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs [app-route] (ecmascript)"); // Spec Section: "Fragment spread target defined"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$KnownFragmentNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs [app-route] (ecmascript)"); // Spec Section: "Fragments must be used"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$NoUnusedFragmentsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs [app-route] (ecmascript)"); // Spec Section: "Fragment spread is possible"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$PossibleFragmentSpreadsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs [app-route] (ecmascript)"); // Spec Section: "Fragments must not form cycles"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$NoFragmentCyclesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs [app-route] (ecmascript)"); // Spec Section: "Variable Uniqueness"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueVariableNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs [app-route] (ecmascript)"); // Spec Section: "All Variable Used Defined"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$NoUndefinedVariablesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs [app-route] (ecmascript)"); // Spec Section: "All Variables Used"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$NoUnusedVariablesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs [app-route] (ecmascript)"); // Spec Section: "Directives Are Defined"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$KnownDirectivesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/KnownDirectivesRule.mjs [app-route] (ecmascript)"); // Spec Section: "Directives Are Unique Per Location"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueDirectivesPerLocationRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs [app-route] (ecmascript)"); // Spec Section: "Argument Names"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$KnownArgumentNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs [app-route] (ecmascript)"); // Spec Section: "Argument Uniqueness"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueArgumentNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs [app-route] (ecmascript)"); // Spec Section: "Value Type Correctness"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$ValuesOfCorrectTypeRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs [app-route] (ecmascript)"); // Spec Section: "Argument Optionality"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$ProvidedRequiredArgumentsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs [app-route] (ecmascript)"); // Spec Section: "All Variable Usages Are Allowed"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$VariablesInAllowedPositionRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs [app-route] (ecmascript)"); // Spec Section: "Field Selection Merging"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$OverlappingFieldsCanBeMergedRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs [app-route] (ecmascript)"); // Spec Section: "Input Object Field Uniqueness"
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueInputFieldNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs [app-route] (ecmascript)"); // SDL-specific validation rules
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$LoneSchemaDefinitionRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueOperationTypesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueTypeNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueEnumValueNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueFieldDefinitionNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueDirectiveNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$PossibleTypeExtensionsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
var specifiedRules = Object.freeze([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$ExecutableDefinitionsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecutableDefinitionsRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueOperationNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UniqueOperationNamesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$LoneAnonymousOperationRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LoneAnonymousOperationRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$SingleFieldSubscriptionsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SingleFieldSubscriptionsRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$KnownTypeNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["KnownTypeNamesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$FragmentsOnCompositeTypesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FragmentsOnCompositeTypesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$VariablesAreInputTypesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["VariablesAreInputTypesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$ScalarLeafsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ScalarLeafsRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$FieldsOnCorrectTypeRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FieldsOnCorrectTypeRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueFragmentNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UniqueFragmentNamesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$KnownFragmentNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["KnownFragmentNamesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$NoUnusedFragmentsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NoUnusedFragmentsRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$PossibleFragmentSpreadsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PossibleFragmentSpreadsRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$NoFragmentCyclesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NoFragmentCyclesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueVariableNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UniqueVariableNamesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$NoUndefinedVariablesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NoUndefinedVariablesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$NoUnusedVariablesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NoUnusedVariablesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$KnownDirectivesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["KnownDirectivesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueDirectivesPerLocationRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UniqueDirectivesPerLocationRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$KnownArgumentNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["KnownArgumentNamesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueArgumentNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UniqueArgumentNamesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$ValuesOfCorrectTypeRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ValuesOfCorrectTypeRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$ProvidedRequiredArgumentsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ProvidedRequiredArgumentsRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$VariablesInAllowedPositionRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["VariablesInAllowedPositionRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$OverlappingFieldsCanBeMergedRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OverlappingFieldsCanBeMergedRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueInputFieldNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UniqueInputFieldNamesRule"]
]);
var specifiedSDLRules = Object.freeze([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$LoneSchemaDefinitionRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LoneSchemaDefinitionRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueOperationTypesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UniqueOperationTypesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueTypeNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UniqueTypeNamesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueEnumValueNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UniqueEnumValueNamesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueFieldDefinitionNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UniqueFieldDefinitionNamesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueDirectiveNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UniqueDirectiveNamesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$KnownTypeNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["KnownTypeNamesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$KnownDirectivesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["KnownDirectivesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueDirectivesPerLocationRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UniqueDirectivesPerLocationRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$PossibleTypeExtensionsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PossibleTypeExtensionsRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$KnownArgumentNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["KnownArgumentNamesOnDirectivesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueArgumentNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UniqueArgumentNamesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$UniqueInputFieldNamesRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UniqueInputFieldNamesRule"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$rules$2f$ProvidedRequiredArgumentsRule$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ProvidedRequiredArgumentsOnDirectivesRule"]
]);
}),
"[project]/node_modules/graphql/validation/ValidationContext.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ASTValidationContext": ()=>ASTValidationContext,
    "SDLValidationContext": ()=>SDLValidationContext,
    "ValidationContext": ()=>ValidationContext
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/kinds.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$visitor$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/visitor.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$TypeInfo$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/utilities/TypeInfo.mjs [app-route] (ecmascript)");
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
}
;
;
;
var ASTValidationContext = /*#__PURE__*/ function() {
    function ASTValidationContext(ast, onError) {
        this._ast = ast;
        this._fragments = undefined;
        this._fragmentSpreads = new Map();
        this._recursivelyReferencedFragments = new Map();
        this._onError = onError;
    }
    var _proto = ASTValidationContext.prototype;
    _proto.reportError = function reportError(error) {
        this._onError(error);
    };
    _proto.getDocument = function getDocument() {
        return this._ast;
    };
    _proto.getFragment = function getFragment(name) {
        var fragments = this._fragments;
        if (!fragments) {
            this._fragments = fragments = this.getDocument().definitions.reduce(function(frags, statement) {
                if (statement.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].FRAGMENT_DEFINITION) {
                    frags[statement.name.value] = statement;
                }
                return frags;
            }, Object.create(null));
        }
        return fragments[name];
    };
    _proto.getFragmentSpreads = function getFragmentSpreads(node) {
        var spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
            spreads = [];
            var setsToVisit = [
                node
            ];
            while(setsToVisit.length !== 0){
                var set = setsToVisit.pop();
                for(var _i2 = 0, _set$selections2 = set.selections; _i2 < _set$selections2.length; _i2++){
                    var selection = _set$selections2[_i2];
                    if (selection.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Kind"].FRAGMENT_SPREAD) {
                        spreads.push(selection);
                    } else if (selection.selectionSet) {
                        setsToVisit.push(selection.selectionSet);
                    }
                }
            }
            this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
    };
    _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {
        var fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
            fragments = [];
            var collectedNames = Object.create(null);
            var nodesToVisit = [
                operation.selectionSet
            ];
            while(nodesToVisit.length !== 0){
                var node = nodesToVisit.pop();
                for(var _i4 = 0, _this$getFragmentSpre2 = this.getFragmentSpreads(node); _i4 < _this$getFragmentSpre2.length; _i4++){
                    var spread = _this$getFragmentSpre2[_i4];
                    var fragName = spread.name.value;
                    if (collectedNames[fragName] !== true) {
                        collectedNames[fragName] = true;
                        var fragment = this.getFragment(fragName);
                        if (fragment) {
                            fragments.push(fragment);
                            nodesToVisit.push(fragment.selectionSet);
                        }
                    }
                }
            }
            this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
    };
    return ASTValidationContext;
}();
var SDLValidationContext = /*#__PURE__*/ function(_ASTValidationContext) {
    _inheritsLoose(SDLValidationContext, _ASTValidationContext);
    function SDLValidationContext(ast, schema, onError) {
        var _this;
        _this = _ASTValidationContext.call(this, ast, onError) || this;
        _this._schema = schema;
        return _this;
    }
    var _proto2 = SDLValidationContext.prototype;
    _proto2.getSchema = function getSchema() {
        return this._schema;
    };
    return SDLValidationContext;
}(ASTValidationContext);
var ValidationContext = /*#__PURE__*/ function(_ASTValidationContext2) {
    _inheritsLoose(ValidationContext, _ASTValidationContext2);
    function ValidationContext(schema, ast, typeInfo, onError) {
        var _this2;
        _this2 = _ASTValidationContext2.call(this, ast, onError) || this;
        _this2._schema = schema;
        _this2._typeInfo = typeInfo;
        _this2._variableUsages = new Map();
        _this2._recursiveVariableUsages = new Map();
        return _this2;
    }
    var _proto3 = ValidationContext.prototype;
    _proto3.getSchema = function getSchema() {
        return this._schema;
    };
    _proto3.getVariableUsages = function getVariableUsages(node) {
        var usages = this._variableUsages.get(node);
        if (!usages) {
            var newUsages = [];
            var typeInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$TypeInfo$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TypeInfo"](this._schema);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$visitor$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["visit"])(node, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$TypeInfo$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["visitWithTypeInfo"])(typeInfo, {
                VariableDefinition: function VariableDefinition() {
                    return false;
                },
                Variable: function Variable(variable) {
                    newUsages.push({
                        node: variable,
                        type: typeInfo.getInputType(),
                        defaultValue: typeInfo.getDefaultValue()
                    });
                }
            }));
            usages = newUsages;
            this._variableUsages.set(node, usages);
        }
        return usages;
    };
    _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {
        var usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
            usages = this.getVariableUsages(operation);
            for(var _i6 = 0, _this$getRecursivelyR2 = this.getRecursivelyReferencedFragments(operation); _i6 < _this$getRecursivelyR2.length; _i6++){
                var frag = _this$getRecursivelyR2[_i6];
                usages = usages.concat(this.getVariableUsages(frag));
            }
            this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
    };
    _proto3.getType = function getType() {
        return this._typeInfo.getType();
    };
    _proto3.getParentType = function getParentType() {
        return this._typeInfo.getParentType();
    };
    _proto3.getInputType = function getInputType() {
        return this._typeInfo.getInputType();
    };
    _proto3.getParentInputType = function getParentInputType() {
        return this._typeInfo.getParentInputType();
    };
    _proto3.getFieldDef = function getFieldDef() {
        return this._typeInfo.getFieldDef();
    };
    _proto3.getDirective = function getDirective() {
        return this._typeInfo.getDirective();
    };
    _proto3.getArgument = function getArgument() {
        return this._typeInfo.getArgument();
    };
    _proto3.getEnumValue = function getEnumValue() {
        return this._typeInfo.getEnumValue();
    };
    return ValidationContext;
}(ASTValidationContext);
}),
"[project]/node_modules/graphql/validation/validate.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "assertValidSDL": ()=>assertValidSDL,
    "assertValidSDLExtension": ()=>assertValidSDLExtension,
    "validate": ()=>validate,
    "validateSDL": ()=>validateSDL
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$devAssert$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/jsutils/devAssert.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$visitor$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/language/visitor.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$validate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/validate.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$TypeInfo$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/utilities/TypeInfo.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$specifiedRules$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/specifiedRules.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$ValidationContext$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/validation/ValidationContext.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
;
function validate(schema, documentAST) {
    var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$specifiedRules$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["specifiedRules"];
    var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$TypeInfo$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TypeInfo"](schema);
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
        maxErrors: undefined
    };
    documentAST || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$devAssert$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(0, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$validate$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["assertValidSchema"])(schema);
    var abortObj = Object.freeze({});
    var errors = [];
    var context = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$ValidationContext$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ValidationContext"](schema, documentAST, typeInfo, function(error) {
        if (options.maxErrors != null && errors.length >= options.maxErrors) {
            errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]('Too many validation errors, error limit reached. Validation aborted.'));
            throw abortObj;
        }
        errors.push(error);
    }); // This uses a specialized visitor which runs multiple visitors in parallel,
    // while maintaining the visitor skip and break API.
    var visitor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$visitor$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["visitInParallel"])(rules.map(function(rule) {
        return rule(context);
    })); // Visit the whole document with each instance of all provided rules.
    try {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$visitor$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["visit"])(documentAST, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$TypeInfo$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["visitWithTypeInfo"])(typeInfo, visitor));
    } catch (e) {
        if (e !== abortObj) {
            throw e;
        }
    }
    return errors;
}
function validateSDL(documentAST, schemaToExtend) {
    var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$specifiedRules$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["specifiedSDLRules"];
    var errors = [];
    var context = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$validation$2f$ValidationContext$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SDLValidationContext"](documentAST, schemaToExtend, function(error) {
        errors.push(error);
    });
    var visitors = rules.map(function(rule) {
        return rule(context);
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$visitor$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["visit"])(documentAST, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$visitor$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["visitInParallel"])(visitors));
    return errors;
}
function assertValidSDL(documentAST) {
    var errors = validateSDL(documentAST);
    if (errors.length !== 0) {
        throw new Error(errors.map(function(error) {
            return error.message;
        }).join('\n\n'));
    }
}
function assertValidSDLExtension(documentAST, schema) {
    var errors = validateSDL(documentAST, schema);
    if (errors.length !== 0) {
        throw new Error(errors.map(function(error) {
            return error.message;
        }).join('\n\n'));
    }
}
}),
"[project]/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "NoDeprecatedCustomRule": ()=>NoDeprecatedCustomRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/definition.mjs [app-route] (ecmascript)");
;
;
function NoDeprecatedCustomRule(context) {
    return {
        Field: function Field(node) {
            var fieldDef = context.getFieldDef();
            var parentType = context.getParentType();
            if (parentType && (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason) != null) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("The field ".concat(parentType.name, ".").concat(fieldDef.name, " is deprecated. ") + fieldDef.deprecationReason, node));
            }
        },
        EnumValue: function EnumValue(node) {
            var type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getNamedType"])(context.getInputType());
            var enumValue = context.getEnumValue();
            if (type && (enumValue === null || enumValue === void 0 ? void 0 : enumValue.deprecationReason) != null) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("The enum value \"".concat(type.name, ".").concat(enumValue.name, "\" is deprecated. ") + enumValue.deprecationReason, node));
            }
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "NoSchemaIntrospectionCustomRule": ()=>NoSchemaIntrospectionCustomRule
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/error/GraphQLError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/definition.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$introspection$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/graphql/type/introspection.mjs [app-route] (ecmascript)");
;
;
;
function NoSchemaIntrospectionCustomRule(context) {
    return {
        Field: function Field(node) {
            var type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getNamedType"])(context.getType());
            if (type && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$introspection$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isIntrospectionType"])(type)) {
                context.reportError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLError"]("GraphQL introspection has been disabled, but the requested query contained the field \"".concat(node.name.value, "\"."), node));
            }
        }
    };
}
}),
"[project]/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _kinds = __turbopack_context__.r("[project]/node_modules/graphql/language/kinds.js [app-route] (ecmascript)");
var _predicates = __turbopack_context__.r("[project]/node_modules/graphql/language/predicates.js [app-route] (ecmascript)");
/**
 * Executable definitions
 *
 * A GraphQL document is only valid for execution if all definitions are either
 * operation or fragment definitions.
 */ function ExecutableDefinitionsRule(context) {
    return {
        Document: function Document(node) {
            for(var _i2 = 0, _node$definitions2 = node.definitions; _i2 < _node$definitions2.length; _i2++){
                var definition = _node$definitions2[_i2];
                if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
                    var defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? 'schema' : '"' + definition.name.value + '"';
                    context.reportError(new _GraphQLError.GraphQLError("The ".concat(defName, " definition is not executable."), definition));
                }
            }
            return false;
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/UniqueOperationNamesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UniqueOperationNamesRule = UniqueOperationNamesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
/**
 * Unique operation names
 *
 * A GraphQL document is only valid if all defined operations have unique names.
 */ function UniqueOperationNamesRule(context) {
    var knownOperationNames = Object.create(null);
    return {
        OperationDefinition: function OperationDefinition(node) {
            var operationName = node.name;
            if (operationName) {
                if (knownOperationNames[operationName.value]) {
                    context.reportError(new _GraphQLError.GraphQLError("There can be only one operation named \"".concat(operationName.value, "\"."), [
                        knownOperationNames[operationName.value],
                        operationName
                    ]));
                } else {
                    knownOperationNames[operationName.value] = operationName;
                }
            }
            return false;
        },
        FragmentDefinition: function FragmentDefinition() {
            return false;
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _kinds = __turbopack_context__.r("[project]/node_modules/graphql/language/kinds.js [app-route] (ecmascript)");
/**
 * Lone anonymous operation
 *
 * A GraphQL document is only valid if when it contains an anonymous operation
 * (the query short-hand) that it contains only that one operation definition.
 */ function LoneAnonymousOperationRule(context) {
    var operationCount = 0;
    return {
        Document: function Document(node) {
            operationCount = node.definitions.filter(function(definition) {
                return definition.kind === _kinds.Kind.OPERATION_DEFINITION;
            }).length;
        },
        OperationDefinition: function OperationDefinition(node) {
            if (!node.name && operationCount > 1) {
                context.reportError(new _GraphQLError.GraphQLError('This anonymous operation must be the only defined operation.', node));
            }
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
/**
 * Subscriptions must only include one field.
 *
 * A GraphQL subscription is valid only if it contains a single root field.
 */ function SingleFieldSubscriptionsRule(context) {
    return {
        OperationDefinition: function OperationDefinition(node) {
            if (node.operation === 'subscription') {
                if (node.selectionSet.selections.length !== 1) {
                    context.reportError(new _GraphQLError.GraphQLError(node.name ? "Subscription \"".concat(node.name.value, "\" must select only one top level field.") : 'Anonymous Subscription must select only one top level field.', node.selectionSet.selections.slice(1)));
                }
            }
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/KnownTypeNamesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KnownTypeNamesRule = KnownTypeNamesRule;
var _didYouMean = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/didYouMean.js [app-route] (ecmascript)"));
var _suggestionList = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/suggestionList.js [app-route] (ecmascript)"));
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _predicates = __turbopack_context__.r("[project]/node_modules/graphql/language/predicates.js [app-route] (ecmascript)");
var _scalars = __turbopack_context__.r("[project]/node_modules/graphql/type/scalars.js [app-route] (ecmascript)");
var _introspection = __turbopack_context__.r("[project]/node_modules/graphql/type/introspection.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Known type names
 *
 * A GraphQL document is only valid if referenced types (specifically
 * variable definitions and fragment conditions) are defined by the type schema.
 */ function KnownTypeNamesRule(context) {
    var schema = context.getSchema();
    var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);
    var definedTypes = Object.create(null);
    for(var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++){
        var def = _context$getDocument$2[_i2];
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
            definedTypes[def.name.value] = true;
        }
    }
    var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));
    return {
        NamedType: function NamedType(node, _1, parent, _2, ancestors) {
            var typeName = node.name.value;
            if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
                var _ancestors$;
                var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
                var isSDL = definitionNode != null && isSDLNode(definitionNode);
                if (isSDL && isStandardTypeName(typeName)) {
                    return;
                }
                var suggestedTypes = (0, _suggestionList.default)(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
                context.reportError(new _GraphQLError.GraphQLError("Unknown type \"".concat(typeName, "\".") + (0, _didYouMean.default)(suggestedTypes), node));
            }
        }
    };
}
var standardTypeNames = [].concat(_scalars.specifiedScalarTypes, _introspection.introspectionTypes).map(function(type) {
    return type.name;
});
function isStandardTypeName(typeName) {
    return standardTypeNames.indexOf(typeName) !== -1;
}
function isSDLNode(value) {
    return !Array.isArray(value) && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
}
}}),
"[project]/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _printer = __turbopack_context__.r("[project]/node_modules/graphql/language/printer.js [app-route] (ecmascript)");
var _definition = __turbopack_context__.r("[project]/node_modules/graphql/type/definition.js [app-route] (ecmascript)");
var _typeFromAST = __turbopack_context__.r("[project]/node_modules/graphql/utilities/typeFromAST.js [app-route] (ecmascript)");
/**
 * Fragments on composite type
 *
 * Fragments use a type condition to determine if they apply, since fragments
 * can only be spread into a composite type (object, interface, or union), the
 * type condition must also be a composite type.
 */ function FragmentsOnCompositeTypesRule(context) {
    return {
        InlineFragment: function InlineFragment(node) {
            var typeCondition = node.typeCondition;
            if (typeCondition) {
                var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition);
                if (type && !(0, _definition.isCompositeType)(type)) {
                    var typeStr = (0, _printer.print)(typeCondition);
                    context.reportError(new _GraphQLError.GraphQLError("Fragment cannot condition on non composite type \"".concat(typeStr, "\"."), typeCondition));
                }
            }
        },
        FragmentDefinition: function FragmentDefinition(node) {
            var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.typeCondition);
            if (type && !(0, _definition.isCompositeType)(type)) {
                var typeStr = (0, _printer.print)(node.typeCondition);
                context.reportError(new _GraphQLError.GraphQLError("Fragment \"".concat(node.name.value, "\" cannot condition on non composite type \"").concat(typeStr, "\"."), node.typeCondition));
            }
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _printer = __turbopack_context__.r("[project]/node_modules/graphql/language/printer.js [app-route] (ecmascript)");
var _definition = __turbopack_context__.r("[project]/node_modules/graphql/type/definition.js [app-route] (ecmascript)");
var _typeFromAST = __turbopack_context__.r("[project]/node_modules/graphql/utilities/typeFromAST.js [app-route] (ecmascript)");
/**
 * Variables are input types
 *
 * A GraphQL operation is only valid if all the variables it defines are of
 * input types (scalar, enum, or input object).
 */ function VariablesAreInputTypesRule(context) {
    return {
        VariableDefinition: function VariableDefinition(node) {
            var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.type);
            if (type && !(0, _definition.isInputType)(type)) {
                var variableName = node.variable.name.value;
                var typeName = (0, _printer.print)(node.type);
                context.reportError(new _GraphQLError.GraphQLError("Variable \"$".concat(variableName, "\" cannot be non-input type \"").concat(typeName, "\"."), node.type));
            }
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/ScalarLeafsRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ScalarLeafsRule = ScalarLeafsRule;
var _inspect = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/inspect.js [app-route] (ecmascript)"));
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _definition = __turbopack_context__.r("[project]/node_modules/graphql/type/definition.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Scalar leafs
 *
 * A GraphQL document is valid only if all leaf fields (fields without
 * sub selections) are of scalar or enum types.
 */ function ScalarLeafsRule(context) {
    return {
        Field: function Field(node) {
            var type = context.getType();
            var selectionSet = node.selectionSet;
            if (type) {
                if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
                    if (selectionSet) {
                        var fieldName = node.name.value;
                        var typeStr = (0, _inspect.default)(type);
                        context.reportError(new _GraphQLError.GraphQLError("Field \"".concat(fieldName, "\" must not have a selection since type \"").concat(typeStr, "\" has no subfields."), selectionSet));
                    }
                } else if (!selectionSet) {
                    var _fieldName = node.name.value;
                    var _typeStr = (0, _inspect.default)(type);
                    context.reportError(new _GraphQLError.GraphQLError("Field \"".concat(_fieldName, "\" of type \"").concat(_typeStr, "\" must have a selection of subfields. Did you mean \"").concat(_fieldName, " { ... }\"?"), node));
                }
            }
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
var _arrayFrom = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/polyfills/arrayFrom.js [app-route] (ecmascript)"));
var _didYouMean = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/didYouMean.js [app-route] (ecmascript)"));
var _suggestionList = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/suggestionList.js [app-route] (ecmascript)"));
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _definition = __turbopack_context__.r("[project]/node_modules/graphql/type/definition.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Fields on correct type
 *
 * A GraphQL document is only valid if all fields selected are defined by the
 * parent type, or are an allowed meta field such as __typename.
 */ function FieldsOnCorrectTypeRule(context) {
    return {
        Field: function Field(node) {
            var type = context.getParentType();
            if (type) {
                var fieldDef = context.getFieldDef();
                if (!fieldDef) {
                    // This field doesn't exist, lets look for suggestions.
                    var schema = context.getSchema();
                    var fieldName = node.name.value; // First determine if there are any suggested types to condition on.
                    var suggestion = (0, _didYouMean.default)('to use an inline fragment on', getSuggestedTypeNames(schema, type, fieldName)); // If there are no suggested types, then perhaps this was a typo?
                    if (suggestion === '') {
                        suggestion = (0, _didYouMean.default)(getSuggestedFieldNames(type, fieldName));
                    } // Report an error, including helpful suggestions.
                    context.reportError(new _GraphQLError.GraphQLError("Cannot query field \"".concat(fieldName, "\" on type \"").concat(type.name, "\".") + suggestion, node));
                }
            }
        }
    };
}
/**
 * Go through all of the implementations of type, as well as the interfaces that
 * they implement. If any of those types include the provided field, suggest them,
 * sorted by how often the type is referenced.
 */ function getSuggestedTypeNames(schema, type, fieldName) {
    if (!(0, _definition.isAbstractType)(type)) {
        // Must be an Object type, which does not have possible fields.
        return [];
    }
    var suggestedTypes = new Set();
    var usageCount = Object.create(null);
    for(var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++){
        var possibleType = _schema$getPossibleTy2[_i2];
        if (!possibleType.getFields()[fieldName]) {
            continue;
        } // This object type defines this field.
        suggestedTypes.add(possibleType);
        usageCount[possibleType.name] = 1;
        for(var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++){
            var _usageCount$possibleI;
            var possibleInterface = _possibleType$getInte2[_i4];
            if (!possibleInterface.getFields()[fieldName]) {
                continue;
            } // This interface type defines this field.
            suggestedTypes.add(possibleInterface);
            usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
        }
    }
    return (0, _arrayFrom.default)(suggestedTypes).sort(function(typeA, typeB) {
        // Suggest both interface and object types based on how common they are.
        var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
        if (usageCountDiff !== 0) {
            return usageCountDiff;
        } // Suggest super types first followed by subtypes
        if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
            return -1;
        }
        if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
            return 1;
        }
        return typeA.name.localeCompare(typeB.name);
    }).map(function(x) {
        return x.name;
    });
}
/**
 * For the field name provided, determine if there are any similar field names
 * that may be the result of a typo.
 */ function getSuggestedFieldNames(type, fieldName) {
    if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
        var possibleFieldNames = Object.keys(type.getFields());
        return (0, _suggestionList.default)(fieldName, possibleFieldNames);
    } // Otherwise, must be a Union type, which does not define fields.
    return [];
}
}}),
"[project]/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
/**
 * Unique fragment names
 *
 * A GraphQL document is only valid if all defined fragments have unique names.
 */ function UniqueFragmentNamesRule(context) {
    var knownFragmentNames = Object.create(null);
    return {
        OperationDefinition: function OperationDefinition() {
            return false;
        },
        FragmentDefinition: function FragmentDefinition(node) {
            var fragmentName = node.name.value;
            if (knownFragmentNames[fragmentName]) {
                context.reportError(new _GraphQLError.GraphQLError("There can be only one fragment named \"".concat(fragmentName, "\"."), [
                    knownFragmentNames[fragmentName],
                    node.name
                ]));
            } else {
                knownFragmentNames[fragmentName] = node.name;
            }
            return false;
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/KnownFragmentNamesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KnownFragmentNamesRule = KnownFragmentNamesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
/**
 * Known fragment names
 *
 * A GraphQL document is only valid if all `...Fragment` fragment spreads refer
 * to fragments defined in the same document.
 */ function KnownFragmentNamesRule(context) {
    return {
        FragmentSpread: function FragmentSpread(node) {
            var fragmentName = node.name.value;
            var fragment = context.getFragment(fragmentName);
            if (!fragment) {
                context.reportError(new _GraphQLError.GraphQLError("Unknown fragment \"".concat(fragmentName, "\"."), node.name));
            }
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
/**
 * No unused fragments
 *
 * A GraphQL document is only valid if all fragment definitions are spread
 * within operations, or spread within other fragments spread within operations.
 */ function NoUnusedFragmentsRule(context) {
    var operationDefs = [];
    var fragmentDefs = [];
    return {
        OperationDefinition: function OperationDefinition(node) {
            operationDefs.push(node);
            return false;
        },
        FragmentDefinition: function FragmentDefinition(node) {
            fragmentDefs.push(node);
            return false;
        },
        Document: {
            leave: function leave() {
                var fragmentNameUsed = Object.create(null);
                for(var _i2 = 0; _i2 < operationDefs.length; _i2++){
                    var operation = operationDefs[_i2];
                    for(var _i4 = 0, _context$getRecursive2 = context.getRecursivelyReferencedFragments(operation); _i4 < _context$getRecursive2.length; _i4++){
                        var fragment = _context$getRecursive2[_i4];
                        fragmentNameUsed[fragment.name.value] = true;
                    }
                }
                for(var _i6 = 0; _i6 < fragmentDefs.length; _i6++){
                    var fragmentDef = fragmentDefs[_i6];
                    var fragName = fragmentDef.name.value;
                    if (fragmentNameUsed[fragName] !== true) {
                        context.reportError(new _GraphQLError.GraphQLError("Fragment \"".concat(fragName, "\" is never used."), fragmentDef));
                    }
                }
            }
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
var _inspect = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/inspect.js [app-route] (ecmascript)"));
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _definition = __turbopack_context__.r("[project]/node_modules/graphql/type/definition.js [app-route] (ecmascript)");
var _typeFromAST = __turbopack_context__.r("[project]/node_modules/graphql/utilities/typeFromAST.js [app-route] (ecmascript)");
var _typeComparators = __turbopack_context__.r("[project]/node_modules/graphql/utilities/typeComparators.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Possible fragment spread
 *
 * A fragment spread is only valid if the type condition could ever possibly
 * be true: if there is a non-empty intersection of the possible parent types,
 * and possible types which pass the type condition.
 */ function PossibleFragmentSpreadsRule(context) {
    return {
        InlineFragment: function InlineFragment(node) {
            var fragType = context.getType();
            var parentType = context.getParentType();
            if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
                var parentTypeStr = (0, _inspect.default)(parentType);
                var fragTypeStr = (0, _inspect.default)(fragType);
                context.reportError(new _GraphQLError.GraphQLError("Fragment cannot be spread here as objects of type \"".concat(parentTypeStr, "\" can never be of type \"").concat(fragTypeStr, "\"."), node));
            }
        },
        FragmentSpread: function FragmentSpread(node) {
            var fragName = node.name.value;
            var fragType = getFragmentType(context, fragName);
            var parentType = context.getParentType();
            if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
                var parentTypeStr = (0, _inspect.default)(parentType);
                var fragTypeStr = (0, _inspect.default)(fragType);
                context.reportError(new _GraphQLError.GraphQLError("Fragment \"".concat(fragName, "\" cannot be spread here as objects of type \"").concat(parentTypeStr, "\" can never be of type \"").concat(fragTypeStr, "\"."), node));
            }
        }
    };
}
function getFragmentType(context, name) {
    var frag = context.getFragment(name);
    if (frag) {
        var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);
        if ((0, _definition.isCompositeType)(type)) {
            return type;
        }
    }
}
}}),
"[project]/node_modules/graphql/validation/rules/NoFragmentCyclesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoFragmentCyclesRule = NoFragmentCyclesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
function NoFragmentCyclesRule(context) {
    // Tracks already visited fragments to maintain O(N) and to ensure that cycles
    // are not redundantly reported.
    var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors
    var spreadPath = []; // Position in the spread path
    var spreadPathIndexByName = Object.create(null);
    return {
        OperationDefinition: function OperationDefinition() {
            return false;
        },
        FragmentDefinition: function FragmentDefinition(node) {
            detectCycleRecursive(node);
            return false;
        }
    }; // This does a straight-forward DFS to find cycles.
    //TURBOPACK unreachable
    ;
    // It does not terminate when a cycle was found but continues to explore
    // the graph to find all possible cycles.
    function detectCycleRecursive(fragment) {
        if (visitedFrags[fragment.name.value]) {
            return;
        }
        var fragmentName = fragment.name.value;
        visitedFrags[fragmentName] = true;
        var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
        if (spreadNodes.length === 0) {
            return;
        }
        spreadPathIndexByName[fragmentName] = spreadPath.length;
        for(var _i2 = 0; _i2 < spreadNodes.length; _i2++){
            var spreadNode = spreadNodes[_i2];
            var spreadName = spreadNode.name.value;
            var cycleIndex = spreadPathIndexByName[spreadName];
            spreadPath.push(spreadNode);
            if (cycleIndex === undefined) {
                var spreadFragment = context.getFragment(spreadName);
                if (spreadFragment) {
                    detectCycleRecursive(spreadFragment);
                }
            } else {
                var cyclePath = spreadPath.slice(cycleIndex);
                var viaPath = cyclePath.slice(0, -1).map(function(s) {
                    return '"' + s.name.value + '"';
                }).join(', ');
                context.reportError(new _GraphQLError.GraphQLError("Cannot spread fragment \"".concat(spreadName, "\" within itself") + (viaPath !== '' ? " via ".concat(viaPath, ".") : '.'), cyclePath));
            }
            spreadPath.pop();
        }
        spreadPathIndexByName[fragmentName] = undefined;
    }
}
}}),
"[project]/node_modules/graphql/validation/rules/UniqueVariableNamesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UniqueVariableNamesRule = UniqueVariableNamesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
/**
 * Unique variable names
 *
 * A GraphQL operation is only valid if all its variables are uniquely named.
 */ function UniqueVariableNamesRule(context) {
    var knownVariableNames = Object.create(null);
    return {
        OperationDefinition: function OperationDefinition() {
            knownVariableNames = Object.create(null);
        },
        VariableDefinition: function VariableDefinition(node) {
            var variableName = node.variable.name.value;
            if (knownVariableNames[variableName]) {
                context.reportError(new _GraphQLError.GraphQLError("There can be only one variable named \"$".concat(variableName, "\"."), [
                    knownVariableNames[variableName],
                    node.variable.name
                ]));
            } else {
                knownVariableNames[variableName] = node.variable.name;
            }
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
/**
 * No undefined variables
 *
 * A GraphQL operation is only valid if all variables encountered, both directly
 * and via fragment spreads, are defined by that operation.
 */ function NoUndefinedVariablesRule(context) {
    var variableNameDefined = Object.create(null);
    return {
        OperationDefinition: {
            enter: function enter() {
                variableNameDefined = Object.create(null);
            },
            leave: function leave(operation) {
                var usages = context.getRecursiveVariableUsages(operation);
                for(var _i2 = 0; _i2 < usages.length; _i2++){
                    var _ref2 = usages[_i2];
                    var node = _ref2.node;
                    var varName = node.name.value;
                    if (variableNameDefined[varName] !== true) {
                        context.reportError(new _GraphQLError.GraphQLError(operation.name ? "Variable \"$".concat(varName, "\" is not defined by operation \"").concat(operation.name.value, "\".") : "Variable \"$".concat(varName, "\" is not defined."), [
                            node,
                            operation
                        ]));
                    }
                }
            }
        },
        VariableDefinition: function VariableDefinition(node) {
            variableNameDefined[node.variable.name.value] = true;
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/NoUnusedVariablesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoUnusedVariablesRule = NoUnusedVariablesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
/**
 * No unused variables
 *
 * A GraphQL operation is only valid if all variables defined by an operation
 * are used, either directly or within a spread fragment.
 */ function NoUnusedVariablesRule(context) {
    var variableDefs = [];
    return {
        OperationDefinition: {
            enter: function enter() {
                variableDefs = [];
            },
            leave: function leave(operation) {
                var variableNameUsed = Object.create(null);
                var usages = context.getRecursiveVariableUsages(operation);
                for(var _i2 = 0; _i2 < usages.length; _i2++){
                    var _ref2 = usages[_i2];
                    var node = _ref2.node;
                    variableNameUsed[node.name.value] = true;
                }
                for(var _i4 = 0, _variableDefs2 = variableDefs; _i4 < _variableDefs2.length; _i4++){
                    var variableDef = _variableDefs2[_i4];
                    var variableName = variableDef.variable.name.value;
                    if (variableNameUsed[variableName] !== true) {
                        context.reportError(new _GraphQLError.GraphQLError(operation.name ? "Variable \"$".concat(variableName, "\" is never used in operation \"").concat(operation.name.value, "\".") : "Variable \"$".concat(variableName, "\" is never used."), variableDef));
                    }
                }
            }
        },
        VariableDefinition: function VariableDefinition(def) {
            variableDefs.push(def);
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/KnownDirectivesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KnownDirectivesRule = KnownDirectivesRule;
var _inspect = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/inspect.js [app-route] (ecmascript)"));
var _invariant = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/invariant.js [app-route] (ecmascript)"));
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _kinds = __turbopack_context__.r("[project]/node_modules/graphql/language/kinds.js [app-route] (ecmascript)");
var _directiveLocation = __turbopack_context__.r("[project]/node_modules/graphql/language/directiveLocation.js [app-route] (ecmascript)");
var _directives = __turbopack_context__.r("[project]/node_modules/graphql/type/directives.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Known directives
 *
 * A GraphQL document is only valid if all `@directives` are known by the
 * schema and legally positioned.
 */ function KnownDirectivesRule(context) {
    var locationsMap = Object.create(null);
    var schema = context.getSchema();
    var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for(var _i2 = 0; _i2 < definedDirectives.length; _i2++){
        var directive = definedDirectives[_i2];
        locationsMap[directive.name] = directive.locations;
    }
    var astDefinitions = context.getDocument().definitions;
    for(var _i4 = 0; _i4 < astDefinitions.length; _i4++){
        var def = astDefinitions[_i4];
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            locationsMap[def.name.value] = def.locations.map(function(name) {
                return name.value;
            });
        }
    }
    return {
        Directive: function Directive(node, _key, _parent, _path, ancestors) {
            var name = node.name.value;
            var locations = locationsMap[name];
            if (!locations) {
                context.reportError(new _GraphQLError.GraphQLError("Unknown directive \"@".concat(name, "\"."), node));
                return;
            }
            var candidateLocation = getDirectiveLocationForASTPath(ancestors);
            if (candidateLocation && locations.indexOf(candidateLocation) === -1) {
                context.reportError(new _GraphQLError.GraphQLError("Directive \"@".concat(name, "\" may not be used on ").concat(candidateLocation, "."), node));
            }
        }
    };
}
function getDirectiveLocationForASTPath(ancestors) {
    var appliedTo = ancestors[ancestors.length - 1];
    !Array.isArray(appliedTo) || (0, _invariant.default)(0);
    switch(appliedTo.kind){
        case _kinds.Kind.OPERATION_DEFINITION:
            return getDirectiveLocationForOperation(appliedTo.operation);
        case _kinds.Kind.FIELD:
            return _directiveLocation.DirectiveLocation.FIELD;
        case _kinds.Kind.FRAGMENT_SPREAD:
            return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
        case _kinds.Kind.INLINE_FRAGMENT:
            return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
        case _kinds.Kind.FRAGMENT_DEFINITION:
            return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
        case _kinds.Kind.VARIABLE_DEFINITION:
            return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
        case _kinds.Kind.SCHEMA_DEFINITION:
        case _kinds.Kind.SCHEMA_EXTENSION:
            return _directiveLocation.DirectiveLocation.SCHEMA;
        case _kinds.Kind.SCALAR_TYPE_DEFINITION:
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.SCALAR;
        case _kinds.Kind.OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.OBJECT;
        case _kinds.Kind.FIELD_DEFINITION:
            return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
        case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.INTERFACE;
        case _kinds.Kind.UNION_TYPE_DEFINITION:
        case _kinds.Kind.UNION_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.UNION;
        case _kinds.Kind.ENUM_TYPE_DEFINITION:
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.ENUM;
        case _kinds.Kind.ENUM_VALUE_DEFINITION:
            return _directiveLocation.DirectiveLocation.ENUM_VALUE;
        case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
        case _kinds.Kind.INPUT_VALUE_DEFINITION:
            {
                var parentNode = ancestors[ancestors.length - 3];
                return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
            }
    }
}
function getDirectiveLocationForOperation(operation) {
    switch(operation){
        case 'query':
            return _directiveLocation.DirectiveLocation.QUERY;
        case 'mutation':
            return _directiveLocation.DirectiveLocation.MUTATION;
        case 'subscription':
            return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
    } // istanbul ignore next (Not reachable. All possible types have been considered)
    false || (0, _invariant.default)(0, 'Unexpected operation: ' + (0, _inspect.default)(operation));
}
}}),
"[project]/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _kinds = __turbopack_context__.r("[project]/node_modules/graphql/language/kinds.js [app-route] (ecmascript)");
var _predicates = __turbopack_context__.r("[project]/node_modules/graphql/language/predicates.js [app-route] (ecmascript)");
var _directives = __turbopack_context__.r("[project]/node_modules/graphql/type/directives.js [app-route] (ecmascript)");
/**
 * Unique directive names per location
 *
 * A GraphQL document is only valid if all non-repeatable directives at
 * a given location are uniquely named.
 */ function UniqueDirectivesPerLocationRule(context) {
    var uniqueDirectiveMap = Object.create(null);
    var schema = context.getSchema();
    var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for(var _i2 = 0; _i2 < definedDirectives.length; _i2++){
        var directive = definedDirectives[_i2];
        uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
    }
    var astDefinitions = context.getDocument().definitions;
    for(var _i4 = 0; _i4 < astDefinitions.length; _i4++){
        var def = astDefinitions[_i4];
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            uniqueDirectiveMap[def.name.value] = !def.repeatable;
        }
    }
    var schemaDirectives = Object.create(null);
    var typeDirectivesMap = Object.create(null);
    return {
        // Many different AST nodes may contain directives. Rather than listing
        // them all, just listen for entering any node, and check to see if it
        // defines any directives.
        enter: function enter(node) {
            if (node.directives == null) {
                return;
            }
            var seenDirectives;
            if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
                seenDirectives = schemaDirectives;
            } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
                var typeName = node.name.value;
                seenDirectives = typeDirectivesMap[typeName];
                if (seenDirectives === undefined) {
                    typeDirectivesMap[typeName] = seenDirectives = Object.create(null);
                }
            } else {
                seenDirectives = Object.create(null);
            }
            for(var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++){
                var _directive = _node$directives2[_i6];
                var directiveName = _directive.name.value;
                if (uniqueDirectiveMap[directiveName]) {
                    if (seenDirectives[directiveName]) {
                        context.reportError(new _GraphQLError.GraphQLError("The directive \"@".concat(directiveName, "\" can only be used once at this location."), [
                            seenDirectives[directiveName],
                            _directive
                        ]));
                    } else {
                        seenDirectives[directiveName] = _directive;
                    }
                }
            }
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/KnownArgumentNamesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KnownArgumentNamesRule = KnownArgumentNamesRule;
exports.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
var _didYouMean = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/didYouMean.js [app-route] (ecmascript)"));
var _suggestionList = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/suggestionList.js [app-route] (ecmascript)"));
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _kinds = __turbopack_context__.r("[project]/node_modules/graphql/language/kinds.js [app-route] (ecmascript)");
var _directives = __turbopack_context__.r("[project]/node_modules/graphql/type/directives.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * Known argument names
 *
 * A GraphQL field is only valid if all supplied arguments are defined by
 * that field.
 */ function KnownArgumentNamesRule(context) {
    return _objectSpread(_objectSpread({}, KnownArgumentNamesOnDirectivesRule(context)), {}, {
        Argument: function Argument(argNode) {
            var argDef = context.getArgument();
            var fieldDef = context.getFieldDef();
            var parentType = context.getParentType();
            if (!argDef && fieldDef && parentType) {
                var argName = argNode.name.value;
                var knownArgsNames = fieldDef.args.map(function(arg) {
                    return arg.name;
                });
                var suggestions = (0, _suggestionList.default)(argName, knownArgsNames);
                context.reportError(new _GraphQLError.GraphQLError("Unknown argument \"".concat(argName, "\" on field \"").concat(parentType.name, ".").concat(fieldDef.name, "\".") + (0, _didYouMean.default)(suggestions), argNode));
            }
        }
    });
}
/**
 * @internal
 */ function KnownArgumentNamesOnDirectivesRule(context) {
    var directiveArgs = Object.create(null);
    var schema = context.getSchema();
    var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for(var _i2 = 0; _i2 < definedDirectives.length; _i2++){
        var directive = definedDirectives[_i2];
        directiveArgs[directive.name] = directive.args.map(function(arg) {
            return arg.name;
        });
    }
    var astDefinitions = context.getDocument().definitions;
    for(var _i4 = 0; _i4 < astDefinitions.length; _i4++){
        var def = astDefinitions[_i4];
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            var _def$arguments;
            // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
            var argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            directiveArgs[def.name.value] = argsNodes.map(function(arg) {
                return arg.name.value;
            });
        }
    }
    return {
        Directive: function Directive(directiveNode) {
            var directiveName = directiveNode.name.value;
            var knownArgs = directiveArgs[directiveName];
            if (directiveNode.arguments && knownArgs) {
                for(var _i6 = 0, _directiveNode$argume2 = directiveNode.arguments; _i6 < _directiveNode$argume2.length; _i6++){
                    var argNode = _directiveNode$argume2[_i6];
                    var argName = argNode.name.value;
                    if (knownArgs.indexOf(argName) === -1) {
                        var suggestions = (0, _suggestionList.default)(argName, knownArgs);
                        context.reportError(new _GraphQLError.GraphQLError("Unknown argument \"".concat(argName, "\" on directive \"@").concat(directiveName, "\".") + (0, _didYouMean.default)(suggestions), argNode));
                    }
                }
            }
            return false;
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
/**
 * Unique argument names
 *
 * A GraphQL field or directive is only valid if all supplied arguments are
 * uniquely named.
 */ function UniqueArgumentNamesRule(context) {
    var knownArgNames = Object.create(null);
    return {
        Field: function Field() {
            knownArgNames = Object.create(null);
        },
        Directive: function Directive() {
            knownArgNames = Object.create(null);
        },
        Argument: function Argument(node) {
            var argName = node.name.value;
            if (knownArgNames[argName]) {
                context.reportError(new _GraphQLError.GraphQLError("There can be only one argument named \"".concat(argName, "\"."), [
                    knownArgNames[argName],
                    node.name
                ]));
            } else {
                knownArgNames[argName] = node.name;
            }
            return false;
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
var _objectValues3 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/polyfills/objectValues.js [app-route] (ecmascript)"));
var _keyMap = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/keyMap.js [app-route] (ecmascript)"));
var _inspect = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/inspect.js [app-route] (ecmascript)"));
var _didYouMean = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/didYouMean.js [app-route] (ecmascript)"));
var _suggestionList = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/suggestionList.js [app-route] (ecmascript)"));
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _printer = __turbopack_context__.r("[project]/node_modules/graphql/language/printer.js [app-route] (ecmascript)");
var _definition = __turbopack_context__.r("[project]/node_modules/graphql/type/definition.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Value literals of correct type
 *
 * A GraphQL document is only valid if all value literals are of the type
 * expected at their position.
 */ function ValuesOfCorrectTypeRule(context) {
    return {
        ListValue: function ListValue(node) {
            // Note: TypeInfo will traverse into a list's item type, so look to the
            // parent input type to check if it is a list.
            var type = (0, _definition.getNullableType)(context.getParentInputType());
            if (!(0, _definition.isListType)(type)) {
                isValidValueNode(context, node);
                return false; // Don't traverse further.
            }
        },
        ObjectValue: function ObjectValue(node) {
            var type = (0, _definition.getNamedType)(context.getInputType());
            if (!(0, _definition.isInputObjectType)(type)) {
                isValidValueNode(context, node);
                return false; // Don't traverse further.
            } // Ensure every required field exists.
            var fieldNodeMap = (0, _keyMap.default)(node.fields, function(field) {
                return field.name.value;
            });
            for(var _i2 = 0, _objectValues2 = (0, _objectValues3.default)(type.getFields()); _i2 < _objectValues2.length; _i2++){
                var fieldDef = _objectValues2[_i2];
                var fieldNode = fieldNodeMap[fieldDef.name];
                if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
                    var typeStr = (0, _inspect.default)(fieldDef.type);
                    context.reportError(new _GraphQLError.GraphQLError("Field \"".concat(type.name, ".").concat(fieldDef.name, "\" of required type \"").concat(typeStr, "\" was not provided."), node));
                }
            }
        },
        ObjectField: function ObjectField(node) {
            var parentType = (0, _definition.getNamedType)(context.getParentInputType());
            var fieldType = context.getInputType();
            if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
                var suggestions = (0, _suggestionList.default)(node.name.value, Object.keys(parentType.getFields()));
                context.reportError(new _GraphQLError.GraphQLError("Field \"".concat(node.name.value, "\" is not defined by type \"").concat(parentType.name, "\".") + (0, _didYouMean.default)(suggestions), node));
            }
        },
        NullValue: function NullValue(node) {
            var type = context.getInputType();
            if ((0, _definition.isNonNullType)(type)) {
                context.reportError(new _GraphQLError.GraphQLError("Expected value of type \"".concat((0, _inspect.default)(type), "\", found ").concat((0, _printer.print)(node), "."), node));
            }
        },
        EnumValue: function EnumValue(node) {
            return isValidValueNode(context, node);
        },
        IntValue: function IntValue(node) {
            return isValidValueNode(context, node);
        },
        FloatValue: function FloatValue(node) {
            return isValidValueNode(context, node);
        },
        StringValue: function StringValue(node) {
            return isValidValueNode(context, node);
        },
        BooleanValue: function BooleanValue(node) {
            return isValidValueNode(context, node);
        }
    };
}
/**
 * Any value literal may be a valid representation of a Scalar, depending on
 * that scalar type.
 */ function isValidValueNode(context, node) {
    // Report any error at the full type expected by the location.
    var locationType = context.getInputType();
    if (!locationType) {
        return;
    }
    var type = (0, _definition.getNamedType)(locationType);
    if (!(0, _definition.isLeafType)(type)) {
        var typeStr = (0, _inspect.default)(locationType);
        context.reportError(new _GraphQLError.GraphQLError("Expected value of type \"".concat(typeStr, "\", found ").concat((0, _printer.print)(node), "."), node));
        return;
    } // Scalars and Enums determine if a literal value is valid via parseLiteral(),
    // which may throw or return an invalid value to indicate failure.
    try {
        var parseResult = type.parseLiteral(node, undefined);
        if (parseResult === undefined) {
            var _typeStr = (0, _inspect.default)(locationType);
            context.reportError(new _GraphQLError.GraphQLError("Expected value of type \"".concat(_typeStr, "\", found ").concat((0, _printer.print)(node), "."), node));
        }
    } catch (error) {
        var _typeStr2 = (0, _inspect.default)(locationType);
        if (error instanceof _GraphQLError.GraphQLError) {
            context.reportError(error);
        } else {
            context.reportError(new _GraphQLError.GraphQLError("Expected value of type \"".concat(_typeStr2, "\", found ").concat((0, _printer.print)(node), "; ") + error.message, node, undefined, undefined, undefined, error));
        }
    }
}
}}),
"[project]/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
exports.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
var _inspect = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/inspect.js [app-route] (ecmascript)"));
var _keyMap = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/keyMap.js [app-route] (ecmascript)"));
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _kinds = __turbopack_context__.r("[project]/node_modules/graphql/language/kinds.js [app-route] (ecmascript)");
var _printer = __turbopack_context__.r("[project]/node_modules/graphql/language/printer.js [app-route] (ecmascript)");
var _directives = __turbopack_context__.r("[project]/node_modules/graphql/type/directives.js [app-route] (ecmascript)");
var _definition = __turbopack_context__.r("[project]/node_modules/graphql/type/definition.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * Provided required arguments
 *
 * A field or directive is only valid if all required (non-null without a
 * default value) field arguments have been provided.
 */ function ProvidedRequiredArgumentsRule(context) {
    return _objectSpread(_objectSpread({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {}, {
        Field: {
            // Validate on leave to allow for deeper errors to appear first.
            leave: function leave(fieldNode) {
                var _fieldNode$arguments;
                var fieldDef = context.getFieldDef();
                if (!fieldDef) {
                    return false;
                } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
                var argNodes = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];
                var argNodeMap = (0, _keyMap.default)(argNodes, function(arg) {
                    return arg.name.value;
                });
                for(var _i2 = 0, _fieldDef$args2 = fieldDef.args; _i2 < _fieldDef$args2.length; _i2++){
                    var argDef = _fieldDef$args2[_i2];
                    var argNode = argNodeMap[argDef.name];
                    if (!argNode && (0, _definition.isRequiredArgument)(argDef)) {
                        var argTypeStr = (0, _inspect.default)(argDef.type);
                        context.reportError(new _GraphQLError.GraphQLError("Field \"".concat(fieldDef.name, "\" argument \"").concat(argDef.name, "\" of type \"").concat(argTypeStr, "\" is required, but it was not provided."), fieldNode));
                    }
                }
            }
        }
    });
}
/**
 * @internal
 */ function ProvidedRequiredArgumentsOnDirectivesRule(context) {
    var requiredArgsMap = Object.create(null);
    var schema = context.getSchema();
    var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for(var _i4 = 0; _i4 < definedDirectives.length; _i4++){
        var directive = definedDirectives[_i4];
        requiredArgsMap[directive.name] = (0, _keyMap.default)(directive.args.filter(_definition.isRequiredArgument), function(arg) {
            return arg.name;
        });
    }
    var astDefinitions = context.getDocument().definitions;
    for(var _i6 = 0; _i6 < astDefinitions.length; _i6++){
        var def = astDefinitions[_i6];
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            var _def$arguments;
            // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
            var argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            requiredArgsMap[def.name.value] = (0, _keyMap.default)(argNodes.filter(isRequiredArgumentNode), function(arg) {
                return arg.name.value;
            });
        }
    }
    return {
        Directive: {
            // Validate on leave to allow for deeper errors to appear first.
            leave: function leave(directiveNode) {
                var directiveName = directiveNode.name.value;
                var requiredArgs = requiredArgsMap[directiveName];
                if (requiredArgs) {
                    var _directiveNode$argume;
                    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
                    var _argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
                    var argNodeMap = (0, _keyMap.default)(_argNodes, function(arg) {
                        return arg.name.value;
                    });
                    for(var _i8 = 0, _Object$keys2 = Object.keys(requiredArgs); _i8 < _Object$keys2.length; _i8++){
                        var argName = _Object$keys2[_i8];
                        if (!argNodeMap[argName]) {
                            var argType = requiredArgs[argName].type;
                            var argTypeStr = (0, _definition.isType)(argType) ? (0, _inspect.default)(argType) : (0, _printer.print)(argType);
                            context.reportError(new _GraphQLError.GraphQLError("Directive \"@".concat(directiveName, "\" argument \"").concat(argName, "\" of type \"").concat(argTypeStr, "\" is required, but it was not provided."), directiveNode));
                        }
                    }
                }
            }
        }
    };
}
function isRequiredArgumentNode(arg) {
    return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
}
}}),
"[project]/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
var _inspect = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/inspect.js [app-route] (ecmascript)"));
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _kinds = __turbopack_context__.r("[project]/node_modules/graphql/language/kinds.js [app-route] (ecmascript)");
var _definition = __turbopack_context__.r("[project]/node_modules/graphql/type/definition.js [app-route] (ecmascript)");
var _typeFromAST = __turbopack_context__.r("[project]/node_modules/graphql/utilities/typeFromAST.js [app-route] (ecmascript)");
var _typeComparators = __turbopack_context__.r("[project]/node_modules/graphql/utilities/typeComparators.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Variables passed to field arguments conform to type
 */ function VariablesInAllowedPositionRule(context) {
    var varDefMap = Object.create(null);
    return {
        OperationDefinition: {
            enter: function enter() {
                varDefMap = Object.create(null);
            },
            leave: function leave(operation) {
                var usages = context.getRecursiveVariableUsages(operation);
                for(var _i2 = 0; _i2 < usages.length; _i2++){
                    var _ref2 = usages[_i2];
                    var node = _ref2.node;
                    var type = _ref2.type;
                    var defaultValue = _ref2.defaultValue;
                    var varName = node.name.value;
                    var varDef = varDefMap[varName];
                    if (varDef && type) {
                        // A var type is allowed if it is the same or more strict (e.g. is
                        // a subtype of) than the expected type. It can be more strict if
                        // the variable type is non-null when the expected type is nullable.
                        // If both are list types, the variable item type can be more strict
                        // than the expected item type (contravariant).
                        var schema = context.getSchema();
                        var varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
                        if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
                            var varTypeStr = (0, _inspect.default)(varType);
                            var typeStr = (0, _inspect.default)(type);
                            context.reportError(new _GraphQLError.GraphQLError("Variable \"$".concat(varName, "\" of type \"").concat(varTypeStr, "\" used in position expecting type \"").concat(typeStr, "\"."), [
                                varDef,
                                node
                            ]));
                        }
                    }
                }
            }
        },
        VariableDefinition: function VariableDefinition(node) {
            varDefMap[node.variable.name.value] = node;
        }
    };
}
/**
 * Returns true if the variable is allowed in the location it was found,
 * which includes considering if default values exist for either the variable
 * or the location at which it is located.
 */ function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
    if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
        var hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
        var hasLocationDefaultValue = locationDefaultValue !== undefined;
        if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
            return false;
        }
        var nullableLocationType = locationType.ofType;
        return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, nullableLocationType);
    }
    return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
}
}}),
"[project]/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
var _find = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/polyfills/find.js [app-route] (ecmascript)"));
var _objectEntries3 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/polyfills/objectEntries.js [app-route] (ecmascript)"));
var _inspect = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/inspect.js [app-route] (ecmascript)"));
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _kinds = __turbopack_context__.r("[project]/node_modules/graphql/language/kinds.js [app-route] (ecmascript)");
var _printer = __turbopack_context__.r("[project]/node_modules/graphql/language/printer.js [app-route] (ecmascript)");
var _definition = __turbopack_context__.r("[project]/node_modules/graphql/type/definition.js [app-route] (ecmascript)");
var _typeFromAST = __turbopack_context__.r("[project]/node_modules/graphql/utilities/typeFromAST.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function reasonMessage(reason) {
    if (Array.isArray(reason)) {
        return reason.map(function(_ref) {
            var responseName = _ref[0], subReason = _ref[1];
            return "subfields \"".concat(responseName, "\" conflict because ") + reasonMessage(subReason);
        }).join(' and ');
    }
    return reason;
}
/**
 * Overlapping fields can be merged
 *
 * A selection set is only valid if all fields (including spreading any
 * fragments) either correspond to distinct response names or can be merged
 * without ambiguity.
 */ function OverlappingFieldsCanBeMergedRule(context) {
    // A memoization for when two fragments are compared "between" each other for
    // conflicts. Two fragments may be compared many times, so memoizing this can
    // dramatically improve the performance of this validator.
    var comparedFragmentPairs = new PairSet(); // A cache for the "field map" and list of fragment names found in any given
    // selection set. Selection sets may be asked for this information multiple
    // times, so this improves the performance of this validator.
    var cachedFieldsAndFragmentNames = new Map();
    return {
        SelectionSet: function SelectionSet(selectionSet) {
            var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
            for(var _i2 = 0; _i2 < conflicts.length; _i2++){
                var _ref3 = conflicts[_i2];
                var _ref2$ = _ref3[0];
                var responseName = _ref2$[0];
                var reason = _ref2$[1];
                var fields1 = _ref3[1];
                var fields2 = _ref3[2];
                var reasonMsg = reasonMessage(reason);
                context.reportError(new _GraphQLError.GraphQLError("Fields \"".concat(responseName, "\" conflict because ").concat(reasonMsg, ". Use different aliases on the fields to fetch both if this was intentional."), fields1.concat(fields2)));
            }
        }
    };
}
/**
 * Algorithm:
 *
 * Conflicts occur when two fields exist in a query which will produce the same
 * response name, but represent differing values, thus creating a conflict.
 * The algorithm below finds all conflicts via making a series of comparisons
 * between fields. In order to compare as few fields as possible, this makes
 * a series of comparisons "within" sets of fields and "between" sets of fields.
 *
 * Given any selection set, a collection produces both a set of fields by
 * also including all inline fragments, as well as a list of fragments
 * referenced by fragment spreads.
 *
 * A) Each selection set represented in the document first compares "within" its
 * collected set of fields, finding any conflicts between every pair of
 * overlapping fields.
 * Note: This is the *only time* that a the fields "within" a set are compared
 * to each other. After this only fields "between" sets are compared.
 *
 * B) Also, if any fragment is referenced in a selection set, then a
 * comparison is made "between" the original set of fields and the
 * referenced fragment.
 *
 * C) Also, if multiple fragments are referenced, then comparisons
 * are made "between" each referenced fragment.
 *
 * D) When comparing "between" a set of fields and a referenced fragment, first
 * a comparison is made between each field in the original set of fields and
 * each field in the the referenced set of fields.
 *
 * E) Also, if any fragment is referenced in the referenced selection set,
 * then a comparison is made "between" the original set of fields and the
 * referenced fragment (recursively referring to step D).
 *
 * F) When comparing "between" two fragments, first a comparison is made between
 * each field in the first referenced set of fields and each field in the the
 * second referenced set of fields.
 *
 * G) Also, any fragments referenced by the first must be compared to the
 * second, and any fragments referenced by the second must be compared to the
 * first (recursively referring to step F).
 *
 * H) When comparing two fields, if both have selection sets, then a comparison
 * is made "between" both selection sets, first comparing the set of fields in
 * the first selection set with the set of fields in the second.
 *
 * I) Also, if any fragment is referenced in either selection set, then a
 * comparison is made "between" the other set of fields and the
 * referenced fragment.
 *
 * J) Also, if two fragments are referenced in both selection sets, then a
 * comparison is made "between" the two fragments.
 *
 */ // Find all conflicts found "within" a selection set, including those found
// via spreading in fragments. Called when visiting each SelectionSet in the
// GraphQL Document.
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
    var conflicts = [];
    var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet), fieldMap = _getFieldsAndFragment[0], fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts "within" the fields of this selection set.
    // Note: this is the *only place* `collectConflictsWithin` is called.
    collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
    if (fragmentNames.length !== 0) {
        // (B) Then collect conflicts between these fields and those represented by
        // each spread fragment name found.
        for(var i = 0; i < fragmentNames.length; i++){
            collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this
            // selection set to collect conflicts between fragments spread together.
            // This compares each item in the list of fragment names to every other
            // item in that same list (except for itself).
            for(var j = i + 1; j < fragmentNames.length; j++){
                collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
            }
        }
    }
    return conflicts;
} // Collect all conflicts found between a set of fields and a fragment reference
// including via spreading in any nested fragments.
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
    var fragment = context.getFragment(fragmentName);
    if (!fragment) {
        return;
    }
    var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment), fieldMap2 = _getReferencedFieldsA[0], fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.
    if (fieldMap === fieldMap2) {
        return;
    } // (D) First collect any conflicts between the provided collection of fields
    // and the collection of fields represented by the given fragment.
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields
    // and any fragment names found in the given fragment.
    for(var i = 0; i < fragmentNames2.length; i++){
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);
    }
} // Collect all conflicts found between two fragments, including via spreading in
// any nested fragments.
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
    // No need to compare a fragment to itself.
    if (fragmentName1 === fragmentName2) {
        return;
    } // Memoize so two fragments are not compared for conflicts more than once.
    if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
        return;
    }
    comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
    var fragment1 = context.getFragment(fragmentName1);
    var fragment2 = context.getFragment(fragmentName2);
    if (!fragment1 || !fragment2) {
        return;
    }
    var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1), fieldMap1 = _getReferencedFieldsA2[0], fragmentNames1 = _getReferencedFieldsA2[1];
    var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2), fieldMap2 = _getReferencedFieldsA3[0], fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields
    // (not including any nested fragments).
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested
    // fragments spread in the second fragment.
    for(var j = 0; j < fragmentNames2.length; j++){
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);
    } // (G) Then collect conflicts between the second fragment and any nested
    // fragments spread in the first fragment.
    for(var i = 0; i < fragmentNames1.length; i++){
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);
    }
} // Find all conflicts found between two selection sets, including those found
// via spreading in fragments. Called when determining if conflicts exist
// between the sub-fields of two overlapping fields.
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
    var conflicts = [];
    var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1), fieldMap1 = _getFieldsAndFragment2[0], fragmentNames1 = _getFieldsAndFragment2[1];
    var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2), fieldMap2 = _getFieldsAndFragment3[0], fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and
    // those referenced by each fragment name associated with the second.
    if (fragmentNames2.length !== 0) {
        for(var j = 0; j < fragmentNames2.length; j++){
            collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);
        }
    } // (I) Then collect conflicts between the second collection of fields and
    // those referenced by each fragment name associated with the first.
    if (fragmentNames1.length !== 0) {
        for(var i = 0; i < fragmentNames1.length; i++){
            collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);
        }
    } // (J) Also collect conflicts between any fragment names by the first and
    // fragment names by the second. This compares each item in the first set of
    // names to each item in the second set of names.
    for(var _i3 = 0; _i3 < fragmentNames1.length; _i3++){
        for(var _j = 0; _j < fragmentNames2.length; _j++){
            collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i3], fragmentNames2[_j]);
        }
    }
    return conflicts;
} // Collect all Conflicts "within" one collection of fields.
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
    // A field map is a keyed collection, where each key represents a response
    // name and the value at that key is a list of all fields which provide that
    // response name. For every response name, if there are multiple fields, they
    // must be compared to find a potential conflict.
    for(var _i5 = 0, _objectEntries2 = (0, _objectEntries3.default)(fieldMap); _i5 < _objectEntries2.length; _i5++){
        var _ref5 = _objectEntries2[_i5];
        var responseName = _ref5[0];
        var fields = _ref5[1];
        // This compares every field in the list to every other field in this list
        // (except to itself). If the list only has one item, nothing needs to
        // be compared.
        if (fields.length > 1) {
            for(var i = 0; i < fields.length; i++){
                for(var j = i + 1; j < fields.length; j++){
                    var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
                    if (conflict) {
                        conflicts.push(conflict);
                    }
                }
            }
        }
    }
} // Collect all Conflicts between two collections of fields. This is similar to,
// but different from the `collectConflictsWithin` function above. This check
// assumes that `collectConflictsWithin` has already been called on each
// provided collection of fields. This is true because this validator traverses
// each individual selection set.
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
    // A field map is a keyed collection, where each key represents a response
    // name and the value at that key is a list of all fields which provide that
    // response name. For any response name which appears in both provided field
    // maps, each field from the first field map must be compared to every field
    // in the second field map to find potential conflicts.
    for(var _i7 = 0, _Object$keys2 = Object.keys(fieldMap1); _i7 < _Object$keys2.length; _i7++){
        var responseName = _Object$keys2[_i7];
        var fields2 = fieldMap2[responseName];
        if (fields2) {
            var fields1 = fieldMap1[responseName];
            for(var i = 0; i < fields1.length; i++){
                for(var j = 0; j < fields2.length; j++){
                    var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);
                    if (conflict) {
                        conflicts.push(conflict);
                    }
                }
            }
        }
    }
} // Determines if there is a conflict between two particular fields, including
// comparing their sub-fields.
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
    var parentType1 = field1[0], node1 = field1[1], def1 = field1[2];
    var parentType2 = field2[0], node2 = field2[1], def2 = field2[2]; // If it is known that two fields could not possibly apply at the same
    // time, due to the parent types, then it is safe to permit them to diverge
    // in aliased field or arguments used as they will not present any ambiguity
    // by differing.
    // It is known that two parent types could never overlap if they are
    // different Object types. Interface or Union types might overlap - if not
    // in the current state of the schema, then perhaps in some future version,
    // thus may not safely diverge.
    var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
    if (!areMutuallyExclusive) {
        var _node1$arguments, _node2$arguments;
        // Two aliases must refer to the same field.
        var name1 = node1.name.value;
        var name2 = node2.name.value;
        if (name1 !== name2) {
            return [
                [
                    responseName,
                    "\"".concat(name1, "\" and \"").concat(name2, "\" are different fields")
                ],
                [
                    node1
                ],
                [
                    node2
                ]
            ];
        } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
        var args1 = (_node1$arguments = node1.arguments) !== null && _node1$arguments !== void 0 ? _node1$arguments : []; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
        var args2 = (_node2$arguments = node2.arguments) !== null && _node2$arguments !== void 0 ? _node2$arguments : []; // Two field calls must have the same arguments.
        if (!sameArguments(args1, args2)) {
            return [
                [
                    responseName,
                    'they have differing arguments'
                ],
                [
                    node1
                ],
                [
                    node2
                ]
            ];
        }
    } // The return type for each field.
    var type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
    var type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
    if (type1 && type2 && doTypesConflict(type1, type2)) {
        return [
            [
                responseName,
                "they return conflicting types \"".concat((0, _inspect.default)(type1), "\" and \"").concat((0, _inspect.default)(type2), "\"")
            ],
            [
                node1
            ],
            [
                node2
            ]
        ];
    } // Collect and compare sub-fields. Use the same "visited fragment names" list
    // for both collections so fields in a fragment reference are never
    // compared to themselves.
    var selectionSet1 = node1.selectionSet;
    var selectionSet2 = node2.selectionSet;
    if (selectionSet1 && selectionSet2) {
        var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);
        return subfieldConflicts(conflicts, responseName, node1, node2);
    }
}
function sameArguments(arguments1, arguments2) {
    if (arguments1.length !== arguments2.length) {
        return false;
    }
    return arguments1.every(function(argument1) {
        var argument2 = (0, _find.default)(arguments2, function(argument) {
            return argument.name.value === argument1.name.value;
        });
        if (!argument2) {
            return false;
        }
        return sameValue(argument1.value, argument2.value);
    });
}
function sameValue(value1, value2) {
    return (0, _printer.print)(value1) === (0, _printer.print)(value2);
} // Two types conflict if both types could not apply to a value simultaneously.
// Composite types are ignored as their individual field types will be compared
// later recursively. However List and Non-Null types must match.
function doTypesConflict(type1, type2) {
    if ((0, _definition.isListType)(type1)) {
        return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if ((0, _definition.isListType)(type2)) {
        return true;
    }
    if ((0, _definition.isNonNullType)(type1)) {
        return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if ((0, _definition.isNonNullType)(type2)) {
        return true;
    }
    if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
        return type1 !== type2;
    }
    return false;
} // Given a selection set, return the collection of fields (a mapping of response
// name to field nodes and definitions) as well as a list of fragment names
// referenced via fragment spreads.
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
    var cached = cachedFieldsAndFragmentNames.get(selectionSet);
    if (!cached) {
        var nodeAndDefs = Object.create(null);
        var fragmentNames = Object.create(null);
        _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
        cached = [
            nodeAndDefs,
            Object.keys(fragmentNames)
        ];
        cachedFieldsAndFragmentNames.set(selectionSet, cached);
    }
    return cached;
} // Given a reference to a fragment, return the represented collection of fields
// as well as a list of nested fragment names referenced via fragment spreads.
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
    // Short-circuit building a type from the node if possible.
    var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
    if (cached) {
        return cached;
    }
    var fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);
    return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
    for(var _i9 = 0, _selectionSet$selecti2 = selectionSet.selections; _i9 < _selectionSet$selecti2.length; _i9++){
        var selection = _selectionSet$selecti2[_i9];
        switch(selection.kind){
            case _kinds.Kind.FIELD:
                {
                    var fieldName = selection.name.value;
                    var fieldDef = void 0;
                    if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
                        fieldDef = parentType.getFields()[fieldName];
                    }
                    var responseName = selection.alias ? selection.alias.value : fieldName;
                    if (!nodeAndDefs[responseName]) {
                        nodeAndDefs[responseName] = [];
                    }
                    nodeAndDefs[responseName].push([
                        parentType,
                        selection,
                        fieldDef
                    ]);
                    break;
                }
            case _kinds.Kind.FRAGMENT_SPREAD:
                fragmentNames[selection.name.value] = true;
                break;
            case _kinds.Kind.INLINE_FRAGMENT:
                {
                    var typeCondition = selection.typeCondition;
                    var inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
                    _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
                    break;
                }
        }
    }
} // Given a series of Conflicts which occurred between two sub-fields, generate
// a single Conflict.
function subfieldConflicts(conflicts, responseName, node1, node2) {
    if (conflicts.length > 0) {
        return [
            [
                responseName,
                conflicts.map(function(_ref6) {
                    var reason = _ref6[0];
                    return reason;
                })
            ],
            conflicts.reduce(function(allFields, _ref7) {
                var fields1 = _ref7[1];
                return allFields.concat(fields1);
            }, [
                node1
            ]),
            conflicts.reduce(function(allFields, _ref8) {
                var fields2 = _ref8[2];
                return allFields.concat(fields2);
            }, [
                node2
            ])
        ];
    }
}
/**
 * A way to keep track of pairs of things when the ordering of the pair does
 * not matter. We do this by maintaining a sort of double adjacency sets.
 */ var PairSet = /*#__PURE__*/ function() {
    function PairSet() {
        this._data = Object.create(null);
    }
    var _proto = PairSet.prototype;
    _proto.has = function has(a, b, areMutuallyExclusive) {
        var first = this._data[a];
        var result = first && first[b];
        if (result === undefined) {
            return false;
        } // areMutuallyExclusive being false is a superset of being true,
        // hence if we want to know if this PairSet "has" these two with no
        // exclusivity, we have to ensure it was added as such.
        if (areMutuallyExclusive === false) {
            return result === false;
        }
        return true;
    };
    _proto.add = function add(a, b, areMutuallyExclusive) {
        _pairSetAdd(this._data, a, b, areMutuallyExclusive);
        _pairSetAdd(this._data, b, a, areMutuallyExclusive);
    };
    return PairSet;
}();
function _pairSetAdd(data, a, b, areMutuallyExclusive) {
    var map = data[a];
    if (!map) {
        map = Object.create(null);
        data[a] = map;
    }
    map[b] = areMutuallyExclusive;
}
}}),
"[project]/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
/**
 * Unique input field names
 *
 * A GraphQL input object value is only valid if all supplied fields are
 * uniquely named.
 */ function UniqueInputFieldNamesRule(context) {
    var knownNameStack = [];
    var knownNames = Object.create(null);
    return {
        ObjectValue: {
            enter: function enter() {
                knownNameStack.push(knownNames);
                knownNames = Object.create(null);
            },
            leave: function leave() {
                knownNames = knownNameStack.pop();
            }
        },
        ObjectField: function ObjectField(node) {
            var fieldName = node.name.value;
            if (knownNames[fieldName]) {
                context.reportError(new _GraphQLError.GraphQLError("There can be only one input field named \"".concat(fieldName, "\"."), [
                    knownNames[fieldName],
                    node.name
                ]));
            } else {
                knownNames[fieldName] = node.name;
            }
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
/**
 * Lone Schema definition
 *
 * A GraphQL document is only valid if it contains only one schema definition.
 */ function LoneSchemaDefinitionRule(context) {
    var _ref, _ref2, _oldSchema$astNode;
    var oldSchema = context.getSchema();
    var alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
    var schemaDefinitionsCount = 0;
    return {
        SchemaDefinition: function SchemaDefinition(node) {
            if (alreadyDefined) {
                context.reportError(new _GraphQLError.GraphQLError('Cannot define a new schema within a schema extension.', node));
                return;
            }
            if (schemaDefinitionsCount > 0) {
                context.reportError(new _GraphQLError.GraphQLError('Must provide only one schema definition.', node));
            }
            ++schemaDefinitionsCount;
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/UniqueOperationTypesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UniqueOperationTypesRule = UniqueOperationTypesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
/**
 * Unique operation types
 *
 * A GraphQL document is only valid if it has only one type per operation.
 */ function UniqueOperationTypesRule(context) {
    var schema = context.getSchema();
    var definedOperationTypes = Object.create(null);
    var existingOperationTypes = schema ? {
        query: schema.getQueryType(),
        mutation: schema.getMutationType(),
        subscription: schema.getSubscriptionType()
    } : {};
    return {
        SchemaDefinition: checkOperationTypes,
        SchemaExtension: checkOperationTypes
    };
    //TURBOPACK unreachable
    ;
    function checkOperationTypes(node) {
        var _node$operationTypes;
        // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
        var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
        for(var _i2 = 0; _i2 < operationTypesNodes.length; _i2++){
            var operationType = operationTypesNodes[_i2];
            var operation = operationType.operation;
            var alreadyDefinedOperationType = definedOperationTypes[operation];
            if (existingOperationTypes[operation]) {
                context.reportError(new _GraphQLError.GraphQLError("Type for ".concat(operation, " already defined in the schema. It cannot be redefined."), operationType));
            } else if (alreadyDefinedOperationType) {
                context.reportError(new _GraphQLError.GraphQLError("There can be only one ".concat(operation, " type in schema."), [
                    alreadyDefinedOperationType,
                    operationType
                ]));
            } else {
                definedOperationTypes[operation] = operationType;
            }
        }
        return false;
    }
}
}}),
"[project]/node_modules/graphql/validation/rules/UniqueTypeNamesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UniqueTypeNamesRule = UniqueTypeNamesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
/**
 * Unique type names
 *
 * A GraphQL document is only valid if all defined types have unique names.
 */ function UniqueTypeNamesRule(context) {
    var knownTypeNames = Object.create(null);
    var schema = context.getSchema();
    return {
        ScalarTypeDefinition: checkTypeName,
        ObjectTypeDefinition: checkTypeName,
        InterfaceTypeDefinition: checkTypeName,
        UnionTypeDefinition: checkTypeName,
        EnumTypeDefinition: checkTypeName,
        InputObjectTypeDefinition: checkTypeName
    };
    //TURBOPACK unreachable
    ;
    function checkTypeName(node) {
        var typeName = node.name.value;
        if (schema === null || schema === void 0 ? void 0 : schema.getType(typeName)) {
            context.reportError(new _GraphQLError.GraphQLError("Type \"".concat(typeName, "\" already exists in the schema. It cannot also be defined in this type definition."), node.name));
            return;
        }
        if (knownTypeNames[typeName]) {
            context.reportError(new _GraphQLError.GraphQLError("There can be only one type named \"".concat(typeName, "\"."), [
                knownTypeNames[typeName],
                node.name
            ]));
        } else {
            knownTypeNames[typeName] = node.name;
        }
        return false;
    }
}
}}),
"[project]/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _definition = __turbopack_context__.r("[project]/node_modules/graphql/type/definition.js [app-route] (ecmascript)");
/**
 * Unique enum value names
 *
 * A GraphQL enum type is only valid if all its values are uniquely named.
 */ function UniqueEnumValueNamesRule(context) {
    var schema = context.getSchema();
    var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
    var knownValueNames = Object.create(null);
    return {
        EnumTypeDefinition: checkValueUniqueness,
        EnumTypeExtension: checkValueUniqueness
    };
    //TURBOPACK unreachable
    ;
    function checkValueUniqueness(node) {
        var _node$values;
        var typeName = node.name.value;
        if (!knownValueNames[typeName]) {
            knownValueNames[typeName] = Object.create(null);
        } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
        var valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
        var valueNames = knownValueNames[typeName];
        for(var _i2 = 0; _i2 < valueNodes.length; _i2++){
            var valueDef = valueNodes[_i2];
            var valueName = valueDef.name.value;
            var existingType = existingTypeMap[typeName];
            if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
                context.reportError(new _GraphQLError.GraphQLError("Enum value \"".concat(typeName, ".").concat(valueName, "\" already exists in the schema. It cannot also be defined in this type extension."), valueDef.name));
            } else if (valueNames[valueName]) {
                context.reportError(new _GraphQLError.GraphQLError("Enum value \"".concat(typeName, ".").concat(valueName, "\" can only be defined once."), [
                    valueNames[valueName],
                    valueDef.name
                ]));
            } else {
                valueNames[valueName] = valueDef.name;
            }
        }
        return false;
    }
}
}}),
"[project]/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _definition = __turbopack_context__.r("[project]/node_modules/graphql/type/definition.js [app-route] (ecmascript)");
/**
 * Unique field definition names
 *
 * A GraphQL complex type is only valid if all its fields are uniquely named.
 */ function UniqueFieldDefinitionNamesRule(context) {
    var schema = context.getSchema();
    var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
    var knownFieldNames = Object.create(null);
    return {
        InputObjectTypeDefinition: checkFieldUniqueness,
        InputObjectTypeExtension: checkFieldUniqueness,
        InterfaceTypeDefinition: checkFieldUniqueness,
        InterfaceTypeExtension: checkFieldUniqueness,
        ObjectTypeDefinition: checkFieldUniqueness,
        ObjectTypeExtension: checkFieldUniqueness
    };
    //TURBOPACK unreachable
    ;
    function checkFieldUniqueness(node) {
        var _node$fields;
        var typeName = node.name.value;
        if (!knownFieldNames[typeName]) {
            knownFieldNames[typeName] = Object.create(null);
        } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')
        var fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
        var fieldNames = knownFieldNames[typeName];
        for(var _i2 = 0; _i2 < fieldNodes.length; _i2++){
            var fieldDef = fieldNodes[_i2];
            var fieldName = fieldDef.name.value;
            if (hasField(existingTypeMap[typeName], fieldName)) {
                context.reportError(new _GraphQLError.GraphQLError("Field \"".concat(typeName, ".").concat(fieldName, "\" already exists in the schema. It cannot also be defined in this type extension."), fieldDef.name));
            } else if (fieldNames[fieldName]) {
                context.reportError(new _GraphQLError.GraphQLError("Field \"".concat(typeName, ".").concat(fieldName, "\" can only be defined once."), [
                    fieldNames[fieldName],
                    fieldDef.name
                ]));
            } else {
                fieldNames[fieldName] = fieldDef.name;
            }
        }
        return false;
    }
}
function hasField(type, fieldName) {
    if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {
        return type.getFields()[fieldName];
    }
    return false;
}
}}),
"[project]/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
/**
 * Unique directive names
 *
 * A GraphQL document is only valid if all defined directives have unique names.
 */ function UniqueDirectiveNamesRule(context) {
    var knownDirectiveNames = Object.create(null);
    var schema = context.getSchema();
    return {
        DirectiveDefinition: function DirectiveDefinition(node) {
            var directiveName = node.name.value;
            if (schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName)) {
                context.reportError(new _GraphQLError.GraphQLError("Directive \"@".concat(directiveName, "\" already exists in the schema. It cannot be redefined."), node.name));
                return;
            }
            if (knownDirectiveNames[directiveName]) {
                context.reportError(new _GraphQLError.GraphQLError("There can be only one directive named \"@".concat(directiveName, "\"."), [
                    knownDirectiveNames[directiveName],
                    node.name
                ]));
            } else {
                knownDirectiveNames[directiveName] = node.name;
            }
            return false;
        }
    };
}
}}),
"[project]/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
var _inspect = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/inspect.js [app-route] (ecmascript)"));
var _invariant = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/invariant.js [app-route] (ecmascript)"));
var _didYouMean = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/didYouMean.js [app-route] (ecmascript)"));
var _suggestionList = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/suggestionList.js [app-route] (ecmascript)"));
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _kinds = __turbopack_context__.r("[project]/node_modules/graphql/language/kinds.js [app-route] (ecmascript)");
var _predicates = __turbopack_context__.r("[project]/node_modules/graphql/language/predicates.js [app-route] (ecmascript)");
var _definition = __turbopack_context__.r("[project]/node_modules/graphql/type/definition.js [app-route] (ecmascript)");
var _defKindToExtKind;
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/**
 * Possible type extension
 *
 * A type extension is only valid if the type is defined and has the same kind.
 */ function PossibleTypeExtensionsRule(context) {
    var schema = context.getSchema();
    var definedTypes = Object.create(null);
    for(var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++){
        var def = _context$getDocument$2[_i2];
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
            definedTypes[def.name.value] = def;
        }
    }
    return {
        ScalarTypeExtension: checkExtension,
        ObjectTypeExtension: checkExtension,
        InterfaceTypeExtension: checkExtension,
        UnionTypeExtension: checkExtension,
        EnumTypeExtension: checkExtension,
        InputObjectTypeExtension: checkExtension
    };
    //TURBOPACK unreachable
    ;
    function checkExtension(node) {
        var typeName = node.name.value;
        var defNode = definedTypes[typeName];
        var existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
        var expectedKind;
        if (defNode) {
            expectedKind = defKindToExtKind[defNode.kind];
        } else if (existingType) {
            expectedKind = typeToExtKind(existingType);
        }
        if (expectedKind) {
            if (expectedKind !== node.kind) {
                var kindStr = extensionKindToTypeName(node.kind);
                context.reportError(new _GraphQLError.GraphQLError("Cannot extend non-".concat(kindStr, " type \"").concat(typeName, "\"."), defNode ? [
                    defNode,
                    node
                ] : node));
            }
        } else {
            var allTypeNames = Object.keys(definedTypes);
            if (schema) {
                allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));
            }
            var suggestedTypes = (0, _suggestionList.default)(typeName, allTypeNames);
            context.reportError(new _GraphQLError.GraphQLError("Cannot extend type \"".concat(typeName, "\" because it is not defined.") + (0, _didYouMean.default)(suggestedTypes), node.name));
        }
    }
}
var defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, _kinds.Kind.SCALAR_TYPE_DEFINITION, _kinds.Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.OBJECT_TYPE_DEFINITION, _kinds.Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.INTERFACE_TYPE_DEFINITION, _kinds.Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.UNION_TYPE_DEFINITION, _kinds.Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.ENUM_TYPE_DEFINITION, _kinds.Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION, _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);
function typeToExtKind(type) {
    if ((0, _definition.isScalarType)(type)) {
        return _kinds.Kind.SCALAR_TYPE_EXTENSION;
    }
    if ((0, _definition.isObjectType)(type)) {
        return _kinds.Kind.OBJECT_TYPE_EXTENSION;
    }
    if ((0, _definition.isInterfaceType)(type)) {
        return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
    }
    if ((0, _definition.isUnionType)(type)) {
        return _kinds.Kind.UNION_TYPE_EXTENSION;
    }
    if ((0, _definition.isEnumType)(type)) {
        return _kinds.Kind.ENUM_TYPE_EXTENSION;
    } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')
    if ((0, _definition.isInputObjectType)(type)) {
        return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    } // istanbul ignore next (Not reachable. All possible types have been considered)
    false || (0, _invariant.default)(0, 'Unexpected type: ' + (0, _inspect.default)(type));
}
function extensionKindToTypeName(kind) {
    switch(kind){
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
            return 'scalar';
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
            return 'object';
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
            return 'interface';
        case _kinds.Kind.UNION_TYPE_EXTENSION:
            return 'union';
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
            return 'enum';
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return 'input object';
    } // istanbul ignore next (Not reachable. All possible types have been considered)
    false || (0, _invariant.default)(0, 'Unexpected kind: ' + (0, _inspect.default)(kind));
}
}}),
"[project]/node_modules/graphql/validation/specifiedRules.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.specifiedSDLRules = exports.specifiedRules = void 0;
var _ExecutableDefinitionsRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js [app-route] (ecmascript)");
var _UniqueOperationNamesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/UniqueOperationNamesRule.js [app-route] (ecmascript)");
var _LoneAnonymousOperationRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js [app-route] (ecmascript)");
var _SingleFieldSubscriptionsRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js [app-route] (ecmascript)");
var _KnownTypeNamesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/KnownTypeNamesRule.js [app-route] (ecmascript)");
var _FragmentsOnCompositeTypesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js [app-route] (ecmascript)");
var _VariablesAreInputTypesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js [app-route] (ecmascript)");
var _ScalarLeafsRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/ScalarLeafsRule.js [app-route] (ecmascript)");
var _FieldsOnCorrectTypeRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js [app-route] (ecmascript)");
var _UniqueFragmentNamesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js [app-route] (ecmascript)");
var _KnownFragmentNamesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/KnownFragmentNamesRule.js [app-route] (ecmascript)");
var _NoUnusedFragmentsRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js [app-route] (ecmascript)");
var _PossibleFragmentSpreadsRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js [app-route] (ecmascript)");
var _NoFragmentCyclesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/NoFragmentCyclesRule.js [app-route] (ecmascript)");
var _UniqueVariableNamesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/UniqueVariableNamesRule.js [app-route] (ecmascript)");
var _NoUndefinedVariablesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js [app-route] (ecmascript)");
var _NoUnusedVariablesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/NoUnusedVariablesRule.js [app-route] (ecmascript)");
var _KnownDirectivesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/KnownDirectivesRule.js [app-route] (ecmascript)");
var _UniqueDirectivesPerLocationRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js [app-route] (ecmascript)");
var _KnownArgumentNamesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/KnownArgumentNamesRule.js [app-route] (ecmascript)");
var _UniqueArgumentNamesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js [app-route] (ecmascript)");
var _ValuesOfCorrectTypeRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js [app-route] (ecmascript)");
var _ProvidedRequiredArgumentsRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js [app-route] (ecmascript)");
var _VariablesInAllowedPositionRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js [app-route] (ecmascript)");
var _OverlappingFieldsCanBeMergedRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js [app-route] (ecmascript)");
var _UniqueInputFieldNamesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js [app-route] (ecmascript)");
var _LoneSchemaDefinitionRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js [app-route] (ecmascript)");
var _UniqueOperationTypesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/UniqueOperationTypesRule.js [app-route] (ecmascript)");
var _UniqueTypeNamesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/UniqueTypeNamesRule.js [app-route] (ecmascript)");
var _UniqueEnumValueNamesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js [app-route] (ecmascript)");
var _UniqueFieldDefinitionNamesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js [app-route] (ecmascript)");
var _UniqueDirectiveNamesRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js [app-route] (ecmascript)");
var _PossibleTypeExtensionsRule = __turbopack_context__.r("[project]/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js [app-route] (ecmascript)");
// Spec Section: "Executable Definitions"
// Spec Section: "Operation Name Uniqueness"
// Spec Section: "Lone Anonymous Operation"
// Spec Section: "Subscriptions with Single Root Field"
// Spec Section: "Fragment Spread Type Existence"
// Spec Section: "Fragments on Composite Types"
// Spec Section: "Variables are Input Types"
// Spec Section: "Leaf Field Selections"
// Spec Section: "Field Selections on Objects, Interfaces, and Unions Types"
// Spec Section: "Fragment Name Uniqueness"
// Spec Section: "Fragment spread target defined"
// Spec Section: "Fragments must be used"
// Spec Section: "Fragment spread is possible"
// Spec Section: "Fragments must not form cycles"
// Spec Section: "Variable Uniqueness"
// Spec Section: "All Variable Used Defined"
// Spec Section: "All Variables Used"
// Spec Section: "Directives Are Defined"
// Spec Section: "Directives Are Unique Per Location"
// Spec Section: "Argument Names"
// Spec Section: "Argument Uniqueness"
// Spec Section: "Value Type Correctness"
// Spec Section: "Argument Optionality"
// Spec Section: "All Variable Usages Are Allowed"
// Spec Section: "Field Selection Merging"
// Spec Section: "Input Object Field Uniqueness"
// SDL-specific validation rules
/**
 * This set includes all validation rules defined by the GraphQL spec.
 *
 * The order of the rules in this list has been adjusted to lead to the
 * most clear output when encountering multiple validation errors.
 */ var specifiedRules = Object.freeze([
    _ExecutableDefinitionsRule.ExecutableDefinitionsRule,
    _UniqueOperationNamesRule.UniqueOperationNamesRule,
    _LoneAnonymousOperationRule.LoneAnonymousOperationRule,
    _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,
    _KnownTypeNamesRule.KnownTypeNamesRule,
    _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,
    _VariablesAreInputTypesRule.VariablesAreInputTypesRule,
    _ScalarLeafsRule.ScalarLeafsRule,
    _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,
    _UniqueFragmentNamesRule.UniqueFragmentNamesRule,
    _KnownFragmentNamesRule.KnownFragmentNamesRule,
    _NoUnusedFragmentsRule.NoUnusedFragmentsRule,
    _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,
    _NoFragmentCyclesRule.NoFragmentCyclesRule,
    _UniqueVariableNamesRule.UniqueVariableNamesRule,
    _NoUndefinedVariablesRule.NoUndefinedVariablesRule,
    _NoUnusedVariablesRule.NoUnusedVariablesRule,
    _KnownDirectivesRule.KnownDirectivesRule,
    _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
    _KnownArgumentNamesRule.KnownArgumentNamesRule,
    _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
    _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,
    _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,
    _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,
    _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,
    _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule
]);
/**
 * @internal
 */ exports.specifiedRules = specifiedRules;
var specifiedSDLRules = Object.freeze([
    _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,
    _UniqueOperationTypesRule.UniqueOperationTypesRule,
    _UniqueTypeNamesRule.UniqueTypeNamesRule,
    _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,
    _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,
    _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,
    _KnownTypeNamesRule.KnownTypeNamesRule,
    _KnownDirectivesRule.KnownDirectivesRule,
    _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
    _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,
    _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,
    _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
    _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
    _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule
]);
exports.specifiedSDLRules = specifiedSDLRules;
}}),
"[project]/node_modules/graphql/validation/ValidationContext.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = void 0;
var _kinds = __turbopack_context__.r("[project]/node_modules/graphql/language/kinds.js [app-route] (ecmascript)");
var _visitor = __turbopack_context__.r("[project]/node_modules/graphql/language/visitor.js [app-route] (ecmascript)");
var _TypeInfo = __turbopack_context__.r("[project]/node_modules/graphql/utilities/TypeInfo.js [app-route] (ecmascript)");
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
}
/**
 * An instance of this class is passed as the "this" context to all validators,
 * allowing access to commonly useful contextual information from within a
 * validation rule.
 */ var ASTValidationContext = /*#__PURE__*/ function() {
    function ASTValidationContext(ast, onError) {
        this._ast = ast;
        this._fragments = undefined;
        this._fragmentSpreads = new Map();
        this._recursivelyReferencedFragments = new Map();
        this._onError = onError;
    }
    var _proto = ASTValidationContext.prototype;
    _proto.reportError = function reportError(error) {
        this._onError(error);
    };
    _proto.getDocument = function getDocument() {
        return this._ast;
    };
    _proto.getFragment = function getFragment(name) {
        var fragments = this._fragments;
        if (!fragments) {
            this._fragments = fragments = this.getDocument().definitions.reduce(function(frags, statement) {
                if (statement.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                    frags[statement.name.value] = statement;
                }
                return frags;
            }, Object.create(null));
        }
        return fragments[name];
    };
    _proto.getFragmentSpreads = function getFragmentSpreads(node) {
        var spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
            spreads = [];
            var setsToVisit = [
                node
            ];
            while(setsToVisit.length !== 0){
                var set = setsToVisit.pop();
                for(var _i2 = 0, _set$selections2 = set.selections; _i2 < _set$selections2.length; _i2++){
                    var selection = _set$selections2[_i2];
                    if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
                        spreads.push(selection);
                    } else if (selection.selectionSet) {
                        setsToVisit.push(selection.selectionSet);
                    }
                }
            }
            this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
    };
    _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {
        var fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
            fragments = [];
            var collectedNames = Object.create(null);
            var nodesToVisit = [
                operation.selectionSet
            ];
            while(nodesToVisit.length !== 0){
                var node = nodesToVisit.pop();
                for(var _i4 = 0, _this$getFragmentSpre2 = this.getFragmentSpreads(node); _i4 < _this$getFragmentSpre2.length; _i4++){
                    var spread = _this$getFragmentSpre2[_i4];
                    var fragName = spread.name.value;
                    if (collectedNames[fragName] !== true) {
                        collectedNames[fragName] = true;
                        var fragment = this.getFragment(fragName);
                        if (fragment) {
                            fragments.push(fragment);
                            nodesToVisit.push(fragment.selectionSet);
                        }
                    }
                }
            }
            this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
    };
    return ASTValidationContext;
}();
exports.ASTValidationContext = ASTValidationContext;
var SDLValidationContext = /*#__PURE__*/ function(_ASTValidationContext) {
    _inheritsLoose(SDLValidationContext, _ASTValidationContext);
    function SDLValidationContext(ast, schema, onError) {
        var _this;
        _this = _ASTValidationContext.call(this, ast, onError) || this;
        _this._schema = schema;
        return _this;
    }
    var _proto2 = SDLValidationContext.prototype;
    _proto2.getSchema = function getSchema() {
        return this._schema;
    };
    return SDLValidationContext;
}(ASTValidationContext);
exports.SDLValidationContext = SDLValidationContext;
var ValidationContext = /*#__PURE__*/ function(_ASTValidationContext2) {
    _inheritsLoose(ValidationContext, _ASTValidationContext2);
    function ValidationContext(schema, ast, typeInfo, onError) {
        var _this2;
        _this2 = _ASTValidationContext2.call(this, ast, onError) || this;
        _this2._schema = schema;
        _this2._typeInfo = typeInfo;
        _this2._variableUsages = new Map();
        _this2._recursiveVariableUsages = new Map();
        return _this2;
    }
    var _proto3 = ValidationContext.prototype;
    _proto3.getSchema = function getSchema() {
        return this._schema;
    };
    _proto3.getVariableUsages = function getVariableUsages(node) {
        var usages = this._variableUsages.get(node);
        if (!usages) {
            var newUsages = [];
            var typeInfo = new _TypeInfo.TypeInfo(this._schema);
            (0, _visitor.visit)(node, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
                VariableDefinition: function VariableDefinition() {
                    return false;
                },
                Variable: function Variable(variable) {
                    newUsages.push({
                        node: variable,
                        type: typeInfo.getInputType(),
                        defaultValue: typeInfo.getDefaultValue()
                    });
                }
            }));
            usages = newUsages;
            this._variableUsages.set(node, usages);
        }
        return usages;
    };
    _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {
        var usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
            usages = this.getVariableUsages(operation);
            for(var _i6 = 0, _this$getRecursivelyR2 = this.getRecursivelyReferencedFragments(operation); _i6 < _this$getRecursivelyR2.length; _i6++){
                var frag = _this$getRecursivelyR2[_i6];
                usages = usages.concat(this.getVariableUsages(frag));
            }
            this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
    };
    _proto3.getType = function getType() {
        return this._typeInfo.getType();
    };
    _proto3.getParentType = function getParentType() {
        return this._typeInfo.getParentType();
    };
    _proto3.getInputType = function getInputType() {
        return this._typeInfo.getInputType();
    };
    _proto3.getParentInputType = function getParentInputType() {
        return this._typeInfo.getParentInputType();
    };
    _proto3.getFieldDef = function getFieldDef() {
        return this._typeInfo.getFieldDef();
    };
    _proto3.getDirective = function getDirective() {
        return this._typeInfo.getDirective();
    };
    _proto3.getArgument = function getArgument() {
        return this._typeInfo.getArgument();
    };
    _proto3.getEnumValue = function getEnumValue() {
        return this._typeInfo.getEnumValue();
    };
    return ValidationContext;
}(ASTValidationContext);
exports.ValidationContext = ValidationContext;
}}),
"[project]/node_modules/graphql/validation/validate.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validate = validate;
exports.validateSDL = validateSDL;
exports.assertValidSDL = assertValidSDL;
exports.assertValidSDLExtension = assertValidSDLExtension;
var _devAssert = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/graphql/jsutils/devAssert.js [app-route] (ecmascript)"));
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _visitor = __turbopack_context__.r("[project]/node_modules/graphql/language/visitor.js [app-route] (ecmascript)");
var _validate = __turbopack_context__.r("[project]/node_modules/graphql/type/validate.js [app-route] (ecmascript)");
var _TypeInfo = __turbopack_context__.r("[project]/node_modules/graphql/utilities/TypeInfo.js [app-route] (ecmascript)");
var _specifiedRules = __turbopack_context__.r("[project]/node_modules/graphql/validation/specifiedRules.js [app-route] (ecmascript)");
var _ValidationContext = __turbopack_context__.r("[project]/node_modules/graphql/validation/ValidationContext.js [app-route] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Implements the "Validation" section of the spec.
 *
 * Validation runs synchronously, returning an array of encountered errors, or
 * an empty array if no errors were encountered and the document is valid.
 *
 * A list of specific validation rules may be provided. If not provided, the
 * default list of rules defined by the GraphQL specification will be used.
 *
 * Each validation rules is a function which returns a visitor
 * (see the language/visitor API). Visitor methods are expected to return
 * GraphQLErrors, or Arrays of GraphQLErrors when invalid.
 *
 * Optionally a custom TypeInfo instance may be provided. If not provided, one
 * will be created from the provided schema.
 */ function validate(schema, documentAST) {
    var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _specifiedRules.specifiedRules;
    var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _TypeInfo.TypeInfo(schema);
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
        maxErrors: undefined
    };
    documentAST || (0, _devAssert.default)(0, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.
    (0, _validate.assertValidSchema)(schema);
    var abortObj = Object.freeze({});
    var errors = [];
    var context = new _ValidationContext.ValidationContext(schema, documentAST, typeInfo, function(error) {
        if (options.maxErrors != null && errors.length >= options.maxErrors) {
            errors.push(new _GraphQLError.GraphQLError('Too many validation errors, error limit reached. Validation aborted.'));
            throw abortObj;
        }
        errors.push(error);
    }); // This uses a specialized visitor which runs multiple visitors in parallel,
    // while maintaining the visitor skip and break API.
    var visitor = (0, _visitor.visitInParallel)(rules.map(function(rule) {
        return rule(context);
    })); // Visit the whole document with each instance of all provided rules.
    try {
        (0, _visitor.visit)(documentAST, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor));
    } catch (e) {
        if (e !== abortObj) {
            throw e;
        }
    }
    return errors;
}
/**
 * @internal
 */ function validateSDL(documentAST, schemaToExtend) {
    var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _specifiedRules.specifiedSDLRules;
    var errors = [];
    var context = new _ValidationContext.SDLValidationContext(documentAST, schemaToExtend, function(error) {
        errors.push(error);
    });
    var visitors = rules.map(function(rule) {
        return rule(context);
    });
    (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
    return errors;
}
/**
 * Utility function which asserts a SDL document is valid by throwing an error
 * if it is invalid.
 *
 * @internal
 */ function assertValidSDL(documentAST) {
    var errors = validateSDL(documentAST);
    if (errors.length !== 0) {
        throw new Error(errors.map(function(error) {
            return error.message;
        }).join('\n\n'));
    }
}
/**
 * Utility function which asserts a SDL document is valid by throwing an error
 * if it is invalid.
 *
 * @internal
 */ function assertValidSDLExtension(documentAST, schema) {
    var errors = validateSDL(documentAST, schema);
    if (errors.length !== 0) {
        throw new Error(errors.map(function(error) {
            return error.message;
        }).join('\n\n'));
    }
}
}}),
"[project]/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
var _GraphQLError = __turbopack_context__.r("[project]/node_modules/graphql/error/GraphQLError.js [app-route] (ecmascript)");
var _definition = __turbopack_context__.r("[project]/node_modules/graphql/type/definition.js [app-route] (ecmascript)");
/**
 * No deprecated
 *
 * A GraphQL document is only valid if all selected fields and all used enum values have not been
 * deprecated.
 *
 * Note: This rule is optional and is not part of the Validation section of the GraphQL
 * Specification. The main purpose of this rule is detection of deprecated usages and not
 * necessarily to forbid their use when querying a service.
 */ function NoDeprecatedCustomRule(context) {
    return {
        Field: function Field(node) {
            var fieldDef = context.getFieldDef();
            var parentType = context.getParentType();
            if (parentType && (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason) != null) {
                context.reportError(new _GraphQLError.GraphQLError("The field ".concat(parentType.name, ".").concat(fieldDef.name, " is deprecated. ") + fieldDef.deprecationReason, node));
            }
        },
        EnumValue: function EnumValue(node) {
            var type = (0, _definition.getNamedType)(context.getInputType());
            var enumValue = context.getEnumValue();
            if (type && (enumValue === null || enumValue === void 0 ? void 0 : enumValue.deprecationReason) != null) {
                context.reportError(new _GraphQLError.GraphQLError("The enum value \"".concat(type.name, ".").concat(enumValue.name, "\" is deprecated. ") + enumValue.deprecationReason, node));
            }
        }
    };
}
}}),

};

//# sourceMappingURL=node_modules_graphql_validation_7b891eaf._.js.map