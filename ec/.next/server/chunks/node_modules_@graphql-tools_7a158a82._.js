module.exports = {

"[project]/node_modules/@graphql-tools/mock/cjs/types.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isRecord = exports.assertIsRef = exports.isRef = void 0;
function isRef(maybeRef) {
    return !!(maybeRef && typeof maybeRef === 'object' && '$ref' in maybeRef);
}
exports.isRef = isRef;
function assertIsRef(maybeRef, message) {
    if (!isRef(maybeRef)) {
        throw new Error(message || `Expected ${maybeRef} to be a valid Ref.`);
    }
}
exports.assertIsRef = assertIsRef;
function isRecord(obj) {
    return typeof obj === 'object' && obj !== null;
}
exports.isRecord = isRecord;
}}),
"[project]/node_modules/@graphql-tools/mock/cjs/utils.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isRootType = exports.copyOwnProps = exports.copyOwnPropsIfNotPresent = exports.isObject = exports.makeRef = exports.takeRandom = exports.randomListLength = exports.uuidv4 = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c)=>{
        const r = Math.random() * 16 | 0;
        // eslint-disable-next-line eqeqeq
        const v = c == 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
    });
}
exports.uuidv4 = uuidv4;
const randomListLength = ()=>{
    // Mocking has always returned list of length 2 by default
    // return 1 + Math.round(Math.random() * 10)
    return 2;
};
exports.randomListLength = randomListLength;
const takeRandom = (arr)=>arr[Math.floor(Math.random() * arr.length)];
exports.takeRandom = takeRandom;
function makeRef(typeName, key) {
    return {
        $ref: {
            key,
            typeName
        }
    };
}
exports.makeRef = makeRef;
function isObject(thing) {
    return thing === Object(thing) && !Array.isArray(thing);
}
exports.isObject = isObject;
function copyOwnPropsIfNotPresent(target, source) {
    for (const prop of Object.getOwnPropertyNames(source)){
        if (!Object.getOwnPropertyDescriptor(target, prop)) {
            const propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
            Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);
        }
    }
}
exports.copyOwnPropsIfNotPresent = copyOwnPropsIfNotPresent;
function copyOwnProps(target, ...sources) {
    for (const source of sources){
        let chain = source;
        while(chain != null){
            copyOwnPropsIfNotPresent(target, chain);
            chain = Object.getPrototypeOf(chain);
        }
    }
    return target;
}
exports.copyOwnProps = copyOwnProps;
const isRootType = (type, schema)=>{
    const rootTypeNames = (0, utils_1.getRootTypeNames)(schema);
    return rootTypeNames.has(type.name);
};
exports.isRootType = isRootType;
}}),
"[project]/node_modules/@graphql-tools/mock/cjs/MockList.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deepResolveMockList = exports.MockList = exports.isMockList = void 0;
/**
 * @internal
 */ function isMockList(obj) {
    if (typeof (obj === null || obj === void 0 ? void 0 : obj.len) === 'number' || Array.isArray(obj === null || obj === void 0 ? void 0 : obj.len) && typeof (obj === null || obj === void 0 ? void 0 : obj.len[0]) === 'number') {
        if (typeof obj.wrappedFunction === 'undefined' || typeof obj.wrappedFunction === 'function') {
            return true;
        }
    }
    return false;
}
exports.isMockList = isMockList;
/**
 * This is an object you can return from your mock resolvers which calls the
 * provided `mockFunction` once for each list item.
 */ class MockList {
    /**
     * @param length Either the exact length of items to return or an inclusive
     * range of possible lengths.
     * @param mockFunction The function to call for each item in the list to
     * resolve it. It can return another MockList or a value.
     */ constructor(length, mockFunction){
        this.len = length;
        if (typeof mockFunction !== 'undefined') {
            if (typeof mockFunction !== 'function') {
                throw new Error('Second argument to MockList must be a function or undefined');
            }
            this.wrappedFunction = mockFunction;
        }
    }
    /**
     * @internal
     */ mock() {
        let arr;
        if (Array.isArray(this.len)) {
            arr = new Array(this.randint(this.len[0], this.len[1]));
        } else {
            arr = new Array(this.len);
        }
        for(let i = 0; i < arr.length; i++){
            if (typeof this.wrappedFunction === 'function') {
                const res = this.wrappedFunction();
                if (isMockList(res)) {
                    arr[i] = res.mock();
                } else {
                    arr[i] = res;
                }
            } else {
                arr[i] = undefined;
            }
        }
        return arr;
    }
    randint(low, high) {
        return Math.floor(Math.random() * (high - low + 1) + low);
    }
}
exports.MockList = MockList;
function deepResolveMockList(mockList) {
    return mockList.mock().map((v)=>{
        if (isMockList(v)) return deepResolveMockList(v);
        return v;
    });
}
exports.deepResolveMockList = deepResolveMockList;
}}),
"[project]/node_modules/@graphql-tools/mock/cjs/MockStore.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createMockStore = exports.MockStore = exports.defaultMocks = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const fast_json_stable_stringify_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/fast-json-stable-stringify/index.js [app-route] (ecmascript)"));
const types_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/types.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/utils.js [app-route] (ecmascript)");
const MockList_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/MockList.js [app-route] (ecmascript)");
exports.defaultMocks = {
    Int: ()=>Math.round(Math.random() * 200) - 100,
    Float: ()=>Math.random() * 200 - 100,
    String: ()=>'Hello World',
    Boolean: ()=>Math.random() > 0.5,
    ID: ()=>(0, utils_js_1.uuidv4)()
};
const defaultKeyFieldNames = [
    'id',
    '_id'
];
class MockStore {
    constructor({ schema, mocks, typePolicies }){
        this.store = {};
        this.schema = schema;
        this.mocks = {
            ...exports.defaultMocks,
            ...mocks
        };
        this.typePolicies = typePolicies || {};
    }
    has(typeName, key) {
        return !!this.store[typeName] && !!this.store[typeName][key];
    }
    get(_typeName, _key, _fieldName, _fieldArgs) {
        if (typeof _typeName !== 'string') {
            if (_key === undefined) {
                if ((0, types_js_1.isRef)(_typeName)) {
                    throw new Error("Can't provide a ref as first argument and no other argument");
                }
                // get({...})
                return this.getImpl(_typeName);
            } else {
                (0, types_js_1.assertIsRef)(_typeName);
                const { $ref } = _typeName;
                // arguments shift
                _fieldArgs = _fieldName;
                _fieldName = _key;
                _key = $ref.key;
                _typeName = $ref.typeName;
            }
        }
        const args = {
            typeName: _typeName
        };
        if ((0, types_js_1.isRecord)(_key) || _key === undefined) {
            // get('User', { name: 'Alex'})
            args.defaultValue = _key;
            return this.getImpl(args);
        }
        args.key = _key;
        if (Array.isArray(_fieldName) && _fieldName.length === 1) {
            _fieldName = _fieldName[0];
        }
        if (typeof _fieldName !== 'string' && !Array.isArray(_fieldName)) {
            // get('User', 'me', { name: 'Alex'})
            args.defaultValue = _fieldName;
            return this.getImpl(args);
        }
        if (Array.isArray(_fieldName)) {
            // get('User', 'me', ['father', 'name'])
            const ref = this.get(_typeName, _key, _fieldName[0], _fieldArgs);
            (0, types_js_1.assertIsRef)(ref);
            return this.get(ref.$ref.typeName, ref.$ref.key, _fieldName.slice(1, _fieldName.length));
        }
        // get('User', 'me', 'name'...);
        args.fieldName = _fieldName;
        args.fieldArgs = _fieldArgs;
        return this.getImpl(args);
    }
    set(_typeName, _key, _fieldName, _value) {
        if (typeof _typeName !== 'string') {
            if (_key === undefined) {
                if ((0, types_js_1.isRef)(_typeName)) {
                    throw new Error("Can't provide a ref as first argument and no other argument");
                }
                // set({...})
                return this.setImpl(_typeName);
            } else {
                (0, types_js_1.assertIsRef)(_typeName);
                const { $ref } = _typeName;
                // arguments shift
                _value = _fieldName;
                _fieldName = _key;
                _key = $ref.key;
                _typeName = $ref.typeName;
            }
        }
        assertIsDefined(_key, 'key was not provided');
        const args = {
            typeName: _typeName,
            key: _key
        };
        if (typeof _fieldName !== 'string') {
            // set('User', 1, { name: 'Foo' })
            if (!(0, types_js_1.isRecord)(_fieldName)) throw new Error('Expected value to be a record');
            args.value = _fieldName;
            return this.setImpl(args);
        }
        args.fieldName = _fieldName;
        args.value = _value;
        return this.setImpl(args);
    }
    reset() {
        this.store = {};
    }
    filter(key, predicate) {
        const entity = this.store[key];
        return Object.values(entity).filter(predicate);
    }
    find(key, predicate) {
        const entity = this.store[key];
        return Object.values(entity).find(predicate);
    }
    getImpl(args) {
        const { typeName, key, fieldName, fieldArgs, defaultValue } = args;
        if (!fieldName) {
            if (defaultValue !== undefined && !(0, types_js_1.isRecord)(defaultValue)) {
                throw new Error('`defaultValue` should be an object');
            }
            let valuesToInsert = defaultValue || {};
            if (key) {
                valuesToInsert = {
                    ...valuesToInsert,
                    ...(0, utils_js_1.makeRef)(typeName, key)
                };
            }
            return this.insert(typeName, valuesToInsert, true);
        }
        assertIsDefined(key, 'key argument should be given when fieldName is given');
        const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);
        if (this.store[typeName] === undefined || this.store[typeName][key] === undefined || this.store[typeName][key][fieldNameInStore] === undefined) {
            let value;
            if (defaultValue !== undefined) {
                value = defaultValue;
            } else if (this.isKeyField(typeName, fieldName)) {
                value = key;
            } else {
                value = this.generateFieldValue(typeName, fieldName, (otherFieldName, otherValue)=>{
                    // if we get a key field in the mix we don't care
                    if (this.isKeyField(typeName, otherFieldName)) return;
                    this.set({
                        typeName,
                        key,
                        fieldName: otherFieldName,
                        value: otherValue,
                        noOverride: true
                    });
                });
            }
            this.set({
                typeName,
                key,
                fieldName,
                fieldArgs,
                value,
                noOverride: true
            });
        }
        return this.store[typeName][key][fieldNameInStore];
    }
    setImpl(args) {
        const { typeName, key, fieldName, fieldArgs, noOverride } = args;
        let { value } = args;
        if ((0, MockList_js_1.isMockList)(value)) {
            value = (0, MockList_js_1.deepResolveMockList)(value);
        }
        if (this.store[typeName] === undefined) {
            this.store[typeName] = {};
        }
        if (this.store[typeName][key] === undefined) {
            this.store[typeName][key] = {};
        }
        if (!fieldName) {
            if (!(0, types_js_1.isRecord)(value)) {
                throw new Error('When no `fieldName` is provided, `value` should be a record.');
            }
            for(const fieldName in value){
                this.setImpl({
                    typeName,
                    key,
                    fieldName,
                    value: value[fieldName],
                    noOverride
                });
            }
            return;
        }
        const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);
        if (this.isKeyField(typeName, fieldName) && value !== key) {
            throw new Error(`Field ${fieldName} is a key field of ${typeName} and you are trying to set it to ${value} while the key is ${key}`);
        }
        // if already set and we don't override
        if (this.store[typeName][key][fieldNameInStore] !== undefined && noOverride) {
            return;
        }
        const fieldType = this.getFieldType(typeName, fieldName);
        const currentValue = this.store[typeName][key][fieldNameInStore];
        let valueToStore;
        try {
            valueToStore = this.normalizeValueToStore(fieldType, value, currentValue, (typeName, values)=>this.insert(typeName, values, noOverride));
        } catch (e) {
            throw new Error(`Value to set in ${typeName}.${fieldName} in not normalizable: ${e.message}`);
        }
        this.store[typeName][key] = {
            ...this.store[typeName][key],
            [fieldNameInStore]: valueToStore
        };
    }
    normalizeValueToStore(fieldType, value, currentValue, onInsertType) {
        const fieldTypeName = fieldType.toString();
        if (value === null) {
            if (!(0, graphql_1.isNullableType)(fieldType)) {
                throw new Error(`should not be null because ${fieldTypeName} is not nullable. Received null.`);
            }
            return null;
        }
        const nullableFieldType = (0, graphql_1.getNullableType)(fieldType);
        if (value === undefined) return this.generateValueFromType(nullableFieldType);
        // deal with nesting insert
        if ((0, graphql_1.isCompositeType)(nullableFieldType)) {
            if (!(0, types_js_1.isRecord)(value)) throw new Error(`should be an object or null or undefined. Received ${value}`);
            let joinedTypeName;
            if ((0, graphql_1.isAbstractType)(nullableFieldType)) {
                if ((0, types_js_1.isRef)(value)) {
                    joinedTypeName = value.$ref.typeName;
                } else {
                    if (typeof value['__typename'] !== 'string') {
                        throw new Error(`should contain a '__typename' because ${nullableFieldType.name} an abstract type`);
                    }
                    joinedTypeName = value['__typename'];
                }
            } else {
                joinedTypeName = nullableFieldType.name;
            }
            return onInsertType(joinedTypeName, (0, types_js_1.isRef)(currentValue) ? {
                ...currentValue,
                ...value
            } : value);
        }
        if ((0, graphql_1.isListType)(nullableFieldType)) {
            if (!Array.isArray(value)) throw new Error(`should be an array or null or undefined. Received ${value}`);
            return value.map((v, index)=>{
                return this.normalizeValueToStore(nullableFieldType.ofType, v, typeof currentValue === 'object' && currentValue != null && currentValue[index] ? currentValue : undefined, onInsertType);
            });
        }
        return value;
    }
    insert(typeName, values, noOverride) {
        const keyFieldName = this.getKeyFieldName(typeName);
        let key;
        // when we generate a key for the type, we might produce
        // other associated values with it
        // We keep track of them and we'll insert them, with propririty
        // for the ones that we areasked to insert
        const otherValues = {};
        if ((0, types_js_1.isRef)(values)) {
            key = values.$ref.key;
        } else if (keyFieldName && keyFieldName in values) {
            key = values[keyFieldName];
        } else {
            key = this.generateKeyForType(typeName, (otherFieldName, otherFieldValue)=>{
                otherValues[otherFieldName] = otherFieldValue;
            });
        }
        const toInsert = {
            ...otherValues,
            ...values
        };
        for(const fieldName in toInsert){
            if (fieldName === '$ref') continue;
            if (fieldName === '__typename') continue;
            this.set({
                typeName,
                key,
                fieldName,
                value: toInsert[fieldName],
                noOverride
            });
        }
        if (this.store[typeName] === undefined) {
            this.store[typeName] = {};
        }
        if (this.store[typeName][key] === undefined) {
            this.store[typeName][key] = {};
        }
        return (0, utils_js_1.makeRef)(typeName, key);
    }
    generateFieldValue(typeName, fieldName, onOtherFieldsGenerated) {
        const mockedValue = this.generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated);
        if (mockedValue !== undefined) return mockedValue;
        const fieldType = this.getFieldType(typeName, fieldName);
        return this.generateValueFromType(fieldType);
    }
    generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated) {
        let value;
        const mock = this.mocks ? this.mocks[typeName] : undefined;
        if (mock) {
            if (typeof mock === 'function') {
                const values = mock();
                if (typeof values !== 'object' || values == null) {
                    throw new Error(`Value returned by the mock for ${typeName} is not an object`);
                }
                for(const otherFieldName in values){
                    if (otherFieldName === fieldName) continue;
                    if (typeof values[otherFieldName] === 'function') continue;
                    onOtherFieldsGenerated && onOtherFieldsGenerated(otherFieldName, values[otherFieldName]);
                }
                value = values[fieldName];
                if (typeof value === 'function') value = value();
            } else if (typeof mock === 'object' && mock != null && typeof mock[fieldName] === 'function') {
                value = mock[fieldName]();
            }
        }
        if (value !== undefined) return value;
        const type = this.getType(typeName);
        // GraphQL 14 Compatibility
        const interfaces = 'getInterfaces' in type ? type.getInterfaces() : [];
        if (interfaces.length > 0) {
            for (const interface_ of interfaces){
                if (value) break;
                value = this.generateFieldValueFromMocks(interface_.name, fieldName, onOtherFieldsGenerated);
            }
        }
        return value;
    }
    generateKeyForType(typeName, onOtherFieldsGenerated) {
        const keyFieldName = this.getKeyFieldName(typeName);
        if (!keyFieldName) return (0, utils_js_1.uuidv4)();
        return this.generateFieldValue(typeName, keyFieldName, onOtherFieldsGenerated);
    }
    generateValueFromType(fieldType) {
        const nullableType = (0, graphql_1.getNullableType)(fieldType);
        if ((0, graphql_1.isScalarType)(nullableType)) {
            const mockFn = this.mocks[nullableType.name];
            if (typeof mockFn !== 'function') throw new Error(`No mock defined for type "${nullableType.name}"`);
            return mockFn();
        } else if ((0, graphql_1.isEnumType)(nullableType)) {
            const mockFn = this.mocks[nullableType.name];
            if (typeof mockFn === 'function') return mockFn();
            const values = nullableType.getValues().map((v)=>v.value);
            return (0, utils_js_1.takeRandom)(values);
        } else if ((0, graphql_1.isObjectType)(nullableType)) {
            // this will create a new random ref
            return this.insert(nullableType.name, {});
        } else if ((0, graphql_1.isListType)(nullableType)) {
            return [
                ...new Array((0, utils_js_1.randomListLength)())
            ].map(()=>this.generateValueFromType(nullableType.ofType));
        } else if ((0, graphql_1.isAbstractType)(nullableType)) {
            const mock = this.mocks[nullableType.name];
            let typeName;
            let values = {};
            if (!mock) {
                typeName = (0, utils_js_1.takeRandom)(this.schema.getPossibleTypes(nullableType).map((t)=>t.name));
            } else if (typeof mock === 'function') {
                const mockRes = mock();
                if (mockRes === null) return null;
                if (!(0, types_js_1.isRecord)(mockRes)) {
                    throw new Error(`Value returned by the mock for ${nullableType.name} is not an object or null`);
                }
                values = mockRes;
                if (typeof values['__typename'] !== 'string') {
                    throw new Error(`Please return a __typename in "${nullableType.name}"`);
                }
                typeName = values['__typename'];
            } else if (typeof mock === 'object' && mock != null && typeof mock['__typename'] === 'function') {
                const mockRes = mock['__typename']();
                if (typeof mockRes !== 'string') throw new Error(`'__typename' returned by the mock for abstract type ${nullableType.name} is not a string`);
                typeName = mockRes;
            } else {
                throw new Error(`Please return a __typename in "${nullableType.name}"`);
            }
            const toInsert = {};
            for(const fieldName in values){
                if (fieldName === '__typename') continue;
                const fieldValue = values[fieldName];
                toInsert[fieldName] = typeof fieldValue === 'function' ? fieldValue() : fieldValue;
            }
            return this.insert(typeName, toInsert);
        } else {
            throw new Error(`${nullableType} not implemented`);
        }
    }
    getFieldType(typeName, fieldName) {
        if (fieldName === '__typename') {
            return graphql_1.GraphQLString;
        }
        const type = this.getType(typeName);
        const field = type.getFields()[fieldName];
        if (!field) {
            throw new Error(`${fieldName} does not exist on type ${typeName}`);
        }
        return field.type;
    }
    getType(typeName) {
        const type = this.schema.getType(typeName);
        if (!type || !((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type))) {
            throw new Error(`${typeName} does not exist on schema or is not an object or interface`);
        }
        return type;
    }
    isKeyField(typeName, fieldName) {
        return this.getKeyFieldName(typeName) === fieldName;
    }
    getKeyFieldName(typeName) {
        var _a;
        const typePolicyKeyField = (_a = this.typePolicies[typeName]) === null || _a === void 0 ? void 0 : _a.keyFieldName;
        if (typePolicyKeyField !== undefined) {
            if (typePolicyKeyField === false) return null;
            return typePolicyKeyField;
        }
        // How about common key field names?
        const gqlType = this.getType(typeName);
        for(const fieldName in gqlType.getFields()){
            if (defaultKeyFieldNames.includes(fieldName)) {
                return fieldName;
            }
        }
        return null;
    }
}
exports.MockStore = MockStore;
const getFieldNameInStore = (fieldName, fieldArgs)=>{
    if (!fieldArgs) return fieldName;
    if (typeof fieldArgs === 'string') {
        return `${fieldName}:${fieldArgs}`;
    }
    // empty args
    if (Object.keys(fieldArgs).length === 0) {
        return fieldName;
    }
    return `${fieldName}:${(0, fast_json_stable_stringify_1.default)(fieldArgs)}`;
};
function assertIsDefined(value, message) {
    if (value !== undefined && value !== null) {
        return;
    }
    throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : `Invariant failed: ${message || ''}`);
}
/**
 * Will create `MockStore` for the given `schema`.
 *
 * A `MockStore` will generate mock values for the given schem when queried.
 *
 * It will stores generated mocks, so that, provided with same arguments
 * the returned values will be the same.
 *
 * Its API also allows to modify the stored values.
 *
 * Basic example:
 * ```ts
 * store.get('User', 1, 'name');
 * // > "Hello World"
 * store.set('User', 1, 'name', 'Alexandre');
 * store.get('User', 1, 'name');
 * // > "Alexandre"
 * ```
 *
 * The storage key will correspond to the "key field"
 * of the type. Field with name `id` or `_id` will be
 * by default considered as the key field for the type.
 * However, use `typePolicies` to precise the field to use
 * as key.
 */ function createMockStore(options) {
    return new MockStore(options);
}
exports.createMockStore = createMockStore;
}}),
"[project]/node_modules/@graphql-tools/mock/cjs/addMocksToSchema.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addMocksToSchema = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
const schema_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/index.js [app-route] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/types.js [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/utils.js [app-route] (ecmascript)");
const MockStore_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/MockStore.js [app-route] (ecmascript)");
// todo: add option to preserve resolver
/**
 * Given a `schema` and a `MockStore`, returns an executable schema that
 * will use the provided `MockStore` to execute queries.
 *
 * ```ts
 * const schema = buildSchema(`
 *  type User {
 *    id: ID!
 *    name: String!
 *  }
 *  type Query {
 *    me: User!
 *  }
 * `)
 *
 * const store = createMockStore({ schema });
 * const mockedSchema = addMocksToSchema({ schema, store });
 * ```
 *
 *
 * If a `resolvers` parameter is passed, the query execution will use
 * the provided `resolvers` if, one exists, instead of the default mock
 * resolver.
 *
 *
 * ```ts
 * const schema = buildSchema(`
 *   type User {
 *     id: ID!
 *     name: String!
 *   }
 *   type Query {
 *     me: User!
 *   }
 *   type Mutation {
 *     setMyName(newName: String!): User!
 *   }
 * `)
 *
 * const store = createMockStore({ schema });
 * const mockedSchema = addMocksToSchema({
 *   schema,
 *   store,
 *   resolvers: {
 *     Mutation: {
 *       setMyName: (_, { newName }) => {
 *          const ref = store.get('Query', 'ROOT', 'viewer');
 *          store.set(ref, 'name', newName);
 *          return ref;
 *       }
 *     }
 *   }
 *  });
 * ```
 *
 *
 * `Query` and `Mutation` type will use `key` `'ROOT'`.
 */ function addMocksToSchema({ schema, store: maybeStore, mocks, typePolicies, resolvers: resolversOrFnResolvers, preserveResolvers = false }) {
    if (!schema) {
        throw new Error('Must provide schema to mock');
    }
    if (!(0, graphql_1.isSchema)(schema)) {
        throw new Error('Value at "schema" must be of type GraphQLSchema');
    }
    if (mocks && !(0, utils_js_1.isObject)(mocks)) {
        throw new Error('mocks must be of type Object');
    }
    const store = maybeStore || (0, MockStore_js_1.createMockStore)({
        schema,
        mocks,
        typePolicies
    });
    const resolvers = typeof resolversOrFnResolvers === 'function' ? resolversOrFnResolvers(store) : resolversOrFnResolvers;
    const mockResolver = (source, args, contex, info)=>{
        const defaultResolvedValue = (0, graphql_1.defaultFieldResolver)(source, args, contex, info);
        // priority to default resolved value
        if (defaultResolvedValue !== undefined) return defaultResolvedValue;
        if ((0, types_js_1.isRef)(source)) {
            return store.get({
                typeName: source.$ref.typeName,
                key: source.$ref.key,
                fieldName: info.fieldName,
                fieldArgs: args
            });
        }
        // we have to handle the root mutation, root query and root subscription types
        // differently, because no resolver is called at the root
        if ((0, utils_js_1.isRootType)(info.parentType, info.schema)) {
            return store.get({
                typeName: info.parentType.name,
                key: 'ROOT',
                fieldName: info.fieldName,
                fieldArgs: args
            });
        }
        if (defaultResolvedValue === undefined) {
            // any is used here because generateFieldValue is a private method at time of writing
            return store.generateFieldValue(info.parentType.name, info.fieldName);
        }
        return undefined;
    };
    const typeResolver = (data)=>{
        if ((0, types_js_1.isRef)(data)) {
            return data.$ref.typeName;
        }
    };
    const mockSubscriber = ()=>({
            [Symbol.asyncIterator] () {
                return {
                    async next () {
                        return {
                            done: true,
                            value: {}
                        };
                    }
                };
            }
        });
    const schemaWithMocks = (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.OBJECT_FIELD]: (fieldConfig)=>{
            const newFieldConfig = {
                ...fieldConfig
            };
            const oldResolver = fieldConfig.resolve;
            if (!preserveResolvers || !oldResolver) {
                newFieldConfig.resolve = mockResolver;
            } else {
                newFieldConfig.resolve = async (rootObject, args, context, info)=>{
                    const [mockedValue, resolvedValue] = await Promise.all([
                        mockResolver(rootObject, args, context, info),
                        oldResolver(rootObject, args, context, info)
                    ]);
                    // In case we couldn't mock
                    if (mockedValue instanceof Error) {
                        // only if value was not resolved, populate the error.
                        if (undefined === resolvedValue) {
                            throw mockedValue;
                        }
                        return resolvedValue;
                    }
                    if (resolvedValue instanceof Date && mockedValue instanceof Date) {
                        return undefined !== resolvedValue ? resolvedValue : mockedValue;
                    }
                    if ((0, utils_js_1.isObject)(mockedValue) && (0, utils_js_1.isObject)(resolvedValue)) {
                        // Object.assign() won't do here, as we need to all properties, including
                        // the non-enumerable ones and defined using Object.defineProperty
                        const emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));
                        return (0, utils_js_1.copyOwnProps)(emptyObject, resolvedValue, mockedValue);
                    }
                    return undefined !== resolvedValue ? resolvedValue : mockedValue;
                };
            }
            const fieldSubscriber = fieldConfig.subscribe;
            if (!preserveResolvers || !fieldSubscriber) {
                newFieldConfig.subscribe = mockSubscriber;
            } else {
                newFieldConfig.subscribe = async (rootObject, args, context, info)=>{
                    const [mockAsyncIterable, oldAsyncIterable] = await Promise.all([
                        mockSubscriber(rootObject, args, context, info),
                        fieldSubscriber(rootObject, args, context, info)
                    ]);
                    return oldAsyncIterable || mockAsyncIterable;
                };
            }
            return newFieldConfig;
        },
        [utils_1.MapperKind.ABSTRACT_TYPE]: (type)=>{
            if (preserveResolvers && type.resolveType != null && type.resolveType.length) {
                return;
            }
            if ((0, graphql_1.isUnionType)(type)) {
                return new graphql_1.GraphQLUnionType({
                    ...type.toConfig(),
                    resolveType: typeResolver
                });
            } else {
                return new graphql_1.GraphQLInterfaceType({
                    ...type.toConfig(),
                    resolveType: typeResolver
                });
            }
        }
    });
    return resolvers ? (0, schema_1.addResolversToSchema)({
        schema: schemaWithMocks,
        resolvers: resolvers
    }) : schemaWithMocks;
}
exports.addMocksToSchema = addMocksToSchema;
}}),
"[project]/node_modules/@graphql-tools/mock/cjs/mockServer.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mockServer = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const schema_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/index.js [app-route] (ecmascript)");
const addMocksToSchema_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/addMocksToSchema.js [app-route] (ecmascript)");
/**
 * A convenience wrapper on top of addMocksToSchema. It adds your mock resolvers
 * to your schema and returns a client that will correctly execute your query with
 * variables. Note: when executing queries from the returned server, context and
 * root will both equal `{}`.
 * @param schema The schema to which to add mocks. This can also be a set of type
 * definitions instead.
 * @param mocks The mocks to add to the schema.
 * @param preserveResolvers Set to `true` to prevent existing resolvers from being
 * overwritten to provide mock data. This can be used to mock some parts of the
 * server and not others.
 */ function mockServer(schema, mocks, preserveResolvers = false) {
    const mockedSchema = (0, addMocksToSchema_js_1.addMocksToSchema)({
        schema: (0, graphql_1.isSchema)(schema) ? schema : (0, schema_1.makeExecutableSchema)({
            typeDefs: schema
        }),
        mocks,
        preserveResolvers
    });
    return {
        query: (query, vars)=>(0, graphql_1.graphql)({
                schema: mockedSchema,
                source: query,
                rootValue: {},
                contextValue: {},
                variableValues: vars
            })
    };
}
exports.mockServer = mockServer;
}}),
"[project]/node_modules/@graphql-tools/mock/cjs/pagination.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.relayStylePaginationMock = void 0;
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/utils.js [app-route] (ecmascript)");
/**
 * Produces a resolver that'll mock a [Relay-style cursor pagination](https://relay.dev/graphql/connections.htm).
 *
 * ```ts
 * const schemaWithMocks = addMocksToSchema({
 *   schema,
 *   resolvers: (store) => ({
 *     User: {
 *       friends: relayStylePaginationMock(store),
 *     }
 *   }),
 * })
 * ```
 * @param store the MockStore
 */ const relayStylePaginationMock = (store, { cursorFn = (node)=>`${node.$ref.key}`, applyOnNodes, allNodesFn } = {})=>{
    return (parent, args, context, info)=>{
        const source = (0, utils_js_1.isRootType)(info.parentType, info.schema) ? (0, utils_js_1.makeRef)(info.parentType.name, 'ROOT') : parent;
        const allNodesFn_ = allNodesFn !== null && allNodesFn !== void 0 ? allNodesFn : defaultAllNodesFn(store);
        let allNodes = allNodesFn_(source, args, context, info);
        if (applyOnNodes) {
            allNodes = applyOnNodes(allNodes, args);
        }
        const allEdges = allNodes.map((node)=>({
                node,
                cursor: cursorFn(node)
            }));
        let start, end;
        const { first, after, last, before } = args;
        if (typeof first === 'number') {
            // forward pagination
            if (last || before) {
                throw new Error("if `first` is provided, `last` or `before` can't be provided");
            }
            const afterIndex = after ? allEdges.findIndex((e)=>e.cursor === after) : -1;
            start = afterIndex + 1;
            end = afterIndex + 1 + first;
        } else if (typeof last === 'number') {
            // backward pagination
            if (first || after) {
                throw new Error("if `last` is provided, `first` or `after` can't be provided");
            }
            const foundBeforeIndex = before ? allEdges.findIndex((e)=>e.cursor === before) : -1;
            const beforeIndex = foundBeforeIndex !== -1 ? foundBeforeIndex : allNodes.length;
            start = allEdges.length - (allEdges.length - beforeIndex) - last;
            // negative index on Array.slice indicate offset from end of sequence => we don't want
            if (start < 0) start = 0;
            end = beforeIndex;
        } else {
            throw new Error('A `first` or a `last` arguments should be provided');
        }
        const edges = allEdges.slice(start, end);
        const pageInfo = {
            startCursor: edges.length > 0 ? edges[0].cursor : '',
            endCursor: edges.length > 0 ? edges[edges.length - 1].cursor : '',
            hasNextPage: end < allEdges.length - 1,
            hasPreviousPage: start > 0
        };
        return {
            edges,
            pageInfo,
            totalCount: allEdges.length
        };
    };
};
exports.relayStylePaginationMock = relayStylePaginationMock;
const defaultAllNodesFn = (store)=>(parent, _, __, info)=>store.get(parent, [
            info.fieldName,
            'edges'
        ]).map((e)=>store.get(e, 'node'));
}}),
"[project]/node_modules/@graphql-tools/mock/cjs/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/MockStore.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/addMocksToSchema.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/mockServer.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/types.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/MockList.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/cjs/pagination.js [app-route] (ecmascript)"), exports);
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertResolversPresent = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
function assertResolversPresent(schema, resolverValidationOptions = {}) {
    const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
    if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' + 'Please configure either requireResolversForAllFields or requireResolversForArgs / ' + 'requireResolversForNonScalar, but not a combination of them.');
    }
    (0, utils_1.forEachField)(schema, (field, typeName, fieldName)=>{
        // requires a resolver for *every* field.
        if (requireResolversForAllFields) {
            expectResolver('requireResolversForAllFields', requireResolversForAllFields, field, typeName, fieldName);
        }
        // requires a resolver on every field that has arguments
        if (requireResolversForArgs && field.args.length > 0) {
            expectResolver('requireResolversForArgs', requireResolversForArgs, field, typeName, fieldName);
        }
        // requires a resolver on every field that returns a non-scalar type
        if (requireResolversForNonScalar !== 'ignore' && !(0, graphql_1.isScalarType)((0, graphql_1.getNamedType)(field.type))) {
            expectResolver('requireResolversForNonScalar', requireResolversForNonScalar, field, typeName, fieldName);
        }
    });
}
exports.assertResolversPresent = assertResolversPresent;
function expectResolver(validator, behavior, field, typeName, fieldName) {
    if (!field.resolve) {
        const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
        if (behavior === 'error') {
            throw new Error(message);
        }
        if (behavior === 'warn') {
            console.warn(message);
        }
        return;
    }
    if (typeof field.resolve !== 'function') {
        throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
    }
}
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/chainResolvers.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.chainResolvers = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
function chainResolvers(resolvers) {
    return (root, args, ctx, info)=>resolvers.reduce((prev, curResolver)=>{
            if (curResolver != null) {
                return curResolver(prev, args, ctx, info);
            }
            return (0, graphql_1.defaultFieldResolver)(prev, args, ctx, info);
        }, root);
}
exports.chainResolvers = chainResolvers;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkForResolveTypeResolver = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
// If we have any union or interface types throw if no there is no resolveType resolver
function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
    (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.ABSTRACT_TYPE]: (type)=>{
            if (!type.resolveType) {
                const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into ` + '"resolverValidationOptions.requireResolversForResolveType" to disable this error.';
                if (requireResolversForResolveType === 'error') {
                    throw new Error(message);
                }
                if (requireResolversForResolveType === 'warn') {
                    console.warn(message);
                }
            }
            return undefined;
        }
    });
}
exports.checkForResolveTypeResolver = checkForResolveTypeResolver;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extendResolversFromInterfaces = void 0;
function extendResolversFromInterfaces(schema, resolvers) {
    const extendedResolvers = {};
    const typeMap = schema.getTypeMap();
    for(const typeName in typeMap){
        const type = typeMap[typeName];
        if ('getInterfaces' in type) {
            extendedResolvers[typeName] = {};
            for (const iFace of type.getInterfaces()){
                if (resolvers[iFace.name]) {
                    for(const fieldName in resolvers[iFace.name]){
                        if (fieldName === '__isTypeOf' || !fieldName.startsWith('__')) {
                            extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
                        }
                    }
                }
            }
            const typeResolvers = resolvers[typeName];
            extendedResolvers[typeName] = {
                ...extendedResolvers[typeName],
                ...typeResolvers
            };
        } else {
            const typeResolvers = resolvers[typeName];
            if (typeResolvers != null) {
                extendedResolvers[typeName] = typeResolvers;
            }
        }
    }
    return extendedResolvers;
}
exports.extendResolversFromInterfaces = extendResolversFromInterfaces;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addResolversToSchema = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
const checkForResolveTypeResolver_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js [app-route] (ecmascript)");
const extendResolversFromInterfaces_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js [app-route] (ecmascript)");
function addResolversToSchema({ schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false }) {
    const { requireResolversToMatchSchema = 'error', requireResolversForResolveType } = resolverValidationOptions;
    const resolvers = inheritResolversFromInterfaces ? (0, extendResolversFromInterfaces_js_1.extendResolversFromInterfaces)(schema, inputResolvers) : inputResolvers;
    for(const typeName in resolvers){
        const resolverValue = resolvers[typeName];
        const resolverType = typeof resolverValue;
        if (resolverType !== 'object') {
            throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
        }
        const type = schema.getType(typeName);
        if (type == null) {
            if (requireResolversToMatchSchema === 'ignore') {
                continue;
            }
            throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
        } else if ((0, graphql_1.isSpecifiedScalarType)(type)) {
            // allow -- without recommending -- overriding of specified scalar types
            for(const fieldName in resolverValue){
                if (fieldName.startsWith('__')) {
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                } else {
                    type[fieldName] = resolverValue[fieldName];
                }
            }
        } else if ((0, graphql_1.isEnumType)(type)) {
            const values = type.getValues();
            for(const fieldName in resolverValue){
                if (!fieldName.startsWith('__') && !values.some((value)=>value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {
                    throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);
                }
            }
        } else if ((0, graphql_1.isUnionType)(type)) {
            for(const fieldName in resolverValue){
                if (!fieldName.startsWith('__') && requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {
                    throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);
                }
            }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
            for(const fieldName in resolverValue){
                if (!fieldName.startsWith('__')) {
                    const fields = type.getFields();
                    const field = fields[fieldName];
                    if (field == null) {
                        // Field present in resolver but not in schema
                        if (requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {
                            throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
                        }
                    } else {
                        // Field present in both the resolver and schema
                        const fieldResolve = resolverValue[fieldName];
                        if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {
                            throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
                        }
                    }
                }
            }
        }
    }
    schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);
    if (requireResolversForResolveType && requireResolversForResolveType !== 'ignore') {
        (0, checkForResolveTypeResolver_js_1.checkForResolveTypeResolver)(schema, requireResolversForResolveType);
    }
    return schema;
}
exports.addResolversToSchema = addResolversToSchema;
function addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const typeMap = schema.getTypeMap();
    for(const typeName in resolvers){
        const type = schema.getType(typeName);
        const resolverValue = resolvers[typeName];
        if ((0, graphql_1.isScalarType)(type)) {
            for(const fieldName in resolverValue){
                if (fieldName.startsWith('__')) {
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                } else if (fieldName === 'astNode' && type.astNode != null) {
                    type.astNode = {
                        ...type.astNode,
                        description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.astNode.description,
                        directives: ((_c = type.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                    };
                } else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {
                    type.extensionASTNodes = type.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
                } else if (fieldName === 'extensions' && type.extensions != null && resolverValue.extensions != null) {
                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
                } else {
                    type[fieldName] = resolverValue[fieldName];
                }
            }
        } else if ((0, graphql_1.isEnumType)(type)) {
            const config = type.toConfig();
            const enumValueConfigMap = config.values;
            for(const fieldName in resolverValue){
                if (fieldName.startsWith('__')) {
                    config[fieldName.substring(2)] = resolverValue[fieldName];
                } else if (fieldName === 'astNode' && config.astNode != null) {
                    config.astNode = {
                        ...config.astNode,
                        description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config.astNode.description,
                        directives: ((_j = config.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : [])
                    };
                } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {
                    config.extensionASTNodes = config.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);
                } else if (fieldName === 'extensions' && type.extensions != null && resolverValue.extensions != null) {
                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
                } else if (enumValueConfigMap[fieldName]) {
                    enumValueConfigMap[fieldName].value = resolverValue[fieldName];
                }
            }
            typeMap[typeName] = new graphql_1.GraphQLEnumType(config);
        } else if ((0, graphql_1.isUnionType)(type)) {
            for(const fieldName in resolverValue){
                if (fieldName.startsWith('__')) {
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                }
            }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
            for(const fieldName in resolverValue){
                if (fieldName.startsWith('__')) {
                    // this is for isTypeOf and resolveType and all the other stuff.
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                    continue;
                }
                const fields = type.getFields();
                const field = fields[fieldName];
                if (field != null) {
                    const fieldResolve = resolverValue[fieldName];
                    if (typeof fieldResolve === 'function') {
                        // for convenience. Allows shorter syntax in resolver definition file
                        field.resolve = fieldResolve.bind(resolverValue);
                    } else {
                        setFieldProperties(field, fieldResolve);
                    }
                }
            }
        }
    }
    // serialize all default values prior to healing fields with new scalar/enum types.
    (0, utils_1.forEachDefaultValue)(schema, utils_1.serializeInputValue);
    // schema may have new scalar/enum types that require healing
    (0, utils_1.healSchema)(schema);
    // reparse all default values with new parsing functions.
    (0, utils_1.forEachDefaultValue)(schema, utils_1.parseInputValue);
    if (defaultFieldResolver != null) {
        (0, utils_1.forEachField)(schema, (field)=>{
            if (!field.resolve) {
                field.resolve = defaultFieldResolver;
            }
        });
    }
    return schema;
}
function createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {
    schema = (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.SCALAR_TYPE]: (type)=>{
            var _a, _b, _c, _d, _e, _f;
            const config = type.toConfig();
            const resolverValue = resolvers[type.name];
            if (!(0, graphql_1.isSpecifiedScalarType)(type) && resolverValue != null) {
                for(const fieldName in resolverValue){
                    if (fieldName.startsWith('__')) {
                        config[fieldName.substring(2)] = resolverValue[fieldName];
                    } else if (fieldName === 'astNode' && config.astNode != null) {
                        config.astNode = {
                            ...config.astNode,
                            description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
                            directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                        };
                    } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {
                        config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
                    } else if (fieldName === 'extensions' && config.extensions != null && resolverValue.extensions != null) {
                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
                    } else {
                        config[fieldName] = resolverValue[fieldName];
                    }
                }
                return new graphql_1.GraphQLScalarType(config);
            }
        },
        [utils_1.MapperKind.ENUM_TYPE]: (type)=>{
            var _a, _b, _c, _d, _e, _f;
            const resolverValue = resolvers[type.name];
            const config = type.toConfig();
            const enumValueConfigMap = config.values;
            if (resolverValue != null) {
                for(const fieldName in resolverValue){
                    if (fieldName.startsWith('__')) {
                        config[fieldName.substring(2)] = resolverValue[fieldName];
                    } else if (fieldName === 'astNode' && config.astNode != null) {
                        config.astNode = {
                            ...config.astNode,
                            description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
                            directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                        };
                    } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {
                        config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
                    } else if (fieldName === 'extensions' && config.extensions != null && resolverValue.extensions != null) {
                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
                    } else if (enumValueConfigMap[fieldName]) {
                        enumValueConfigMap[fieldName].value = resolverValue[fieldName];
                    }
                }
                return new graphql_1.GraphQLEnumType(config);
            }
        },
        [utils_1.MapperKind.UNION_TYPE]: (type)=>{
            const resolverValue = resolvers[type.name];
            if (resolverValue != null) {
                const config = type.toConfig();
                if (resolverValue['__resolveType']) {
                    config.resolveType = resolverValue['__resolveType'];
                }
                return new graphql_1.GraphQLUnionType(config);
            }
        },
        [utils_1.MapperKind.OBJECT_TYPE]: (type)=>{
            const resolverValue = resolvers[type.name];
            if (resolverValue != null) {
                const config = type.toConfig();
                if (resolverValue['__isTypeOf']) {
                    config.isTypeOf = resolverValue['__isTypeOf'];
                }
                return new graphql_1.GraphQLObjectType(config);
            }
        },
        [utils_1.MapperKind.INTERFACE_TYPE]: (type)=>{
            const resolverValue = resolvers[type.name];
            if (resolverValue != null) {
                const config = type.toConfig();
                if (resolverValue['__resolveType']) {
                    config.resolveType = resolverValue['__resolveType'];
                }
                return new graphql_1.GraphQLInterfaceType(config);
            }
        },
        [utils_1.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName)=>{
            const resolverValue = resolvers[typeName];
            if (resolverValue != null) {
                const fieldResolve = resolverValue[fieldName];
                if (fieldResolve != null) {
                    const newFieldConfig = {
                        ...fieldConfig
                    };
                    if (typeof fieldResolve === 'function') {
                        // for convenience. Allows shorter syntax in resolver definition file
                        newFieldConfig.resolve = fieldResolve.bind(resolverValue);
                    } else {
                        setFieldProperties(newFieldConfig, fieldResolve);
                    }
                    return newFieldConfig;
                }
            }
        }
    });
    if (defaultFieldResolver != null) {
        schema = (0, utils_1.mapSchema)(schema, {
            [utils_1.MapperKind.OBJECT_FIELD]: (fieldConfig)=>({
                    ...fieldConfig,
                    resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver
                })
        });
    }
    return schema;
}
function setFieldProperties(field, propertiesObj) {
    for(const propertyName in propertiesObj){
        field[propertyName] = propertiesObj[propertyName];
    }
}
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeExecutableSchema = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
const addResolversToSchema_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js [app-route] (ecmascript)");
const assertResolversPresent_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js [app-route] (ecmascript)");
const merge_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/index.js [app-route] (ecmascript)");
/**
 * Builds a schema from the provided type definitions and resolvers.
 *
 * The type definitions are written using Schema Definition Language (SDL). They
 * can be provided as a string, a `DocumentNode`, a function, or an array of any
 * of these. If a function is provided, it will be passed no arguments and
 * should return an array of strings or `DocumentNode`s.
 *
 * Note: You can use GraphQL magic comment provide additional syntax
 * highlighting in your editor (with the appropriate editor plugin).
 *
 * ```js
 * const typeDefs = /* GraphQL *\/ `
 *   type Query {
 *     posts: [Post]
 *     author(id: Int!): Author
 *   }
 * `;
 * ```
 *
 * The `resolvers` object should be a map of type names to nested object, which
 * themselves map the type's fields to their appropriate resolvers.
 * See the [Resolvers](/docs/resolvers) section of the documentation for more details.
 *
 * ```js
 * const resolvers = {
 *   Query: {
 *     posts: (obj, args, ctx, info) => getAllPosts(),
 *     author: (obj, args, ctx, info) => getAuthorById(args.id)
 *   }
 * };
 * ```
 *
 * Once you've defined both the `typeDefs` and `resolvers`, you can create your
 * schema:
 *
 * ```js
 * const schema = makeExecutableSchema({
 *   typeDefs,
 *   resolvers,
 * })
 * ```
 */ function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, schemaExtensions, ...otherOptions }) {
    // Validate and clean up arguments
    if (typeof resolverValidationOptions !== 'object') {
        throw new Error('Expected `resolverValidationOptions` to be an object');
    }
    if (!typeDefs) {
        throw new Error('Must provide typeDefs');
    }
    let schema;
    if ((0, graphql_1.isSchema)(typeDefs)) {
        schema = typeDefs;
    } else if (otherOptions === null || otherOptions === void 0 ? void 0 : otherOptions.commentDescriptions) {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, {
            ...otherOptions,
            commentDescriptions: true
        });
        schema = (0, graphql_1.buildSchema)(mergedTypeDefs, otherOptions);
    } else {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, otherOptions);
        schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, otherOptions);
    }
    // We allow passing in an array of resolver maps, in which case we merge them
    schema = (0, addResolversToSchema_js_1.addResolversToSchema)({
        schema,
        resolvers: (0, merge_1.mergeResolvers)(resolvers),
        resolverValidationOptions,
        inheritResolversFromInterfaces,
        updateResolversInPlace
    });
    if (Object.keys(resolverValidationOptions).length > 0) {
        (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);
    }
    if (schemaExtensions) {
        schemaExtensions = (0, merge_1.mergeExtensions)((0, utils_1.asArray)(schemaExtensions));
        (0, merge_1.applyExtensions)(schema, schemaExtensions);
    }
    return schema;
}
exports.makeExecutableSchema = makeExecutableSchema;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/types.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/merge-schemas.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeSchemas = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
const makeExecutableSchema_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js [app-route] (ecmascript)");
/**
 * Synchronously merges multiple schemas, typeDefinitions and/or resolvers into a single schema.
 * @param config Configuration object
 */ function mergeSchemas(config) {
    const extractedTypeDefs = [];
    const extractedResolvers = [];
    const extractedSchemaExtensions = [];
    if (config.schemas != null) {
        for (const schema of config.schemas){
            extractedTypeDefs.push(schema);
            extractedResolvers.push((0, utils_1.getResolversFromSchema)(schema));
            extractedSchemaExtensions.push((0, utils_1.extractExtensionsFromSchema)(schema));
        }
    }
    if (config.typeDefs != null) {
        extractedTypeDefs.push(config.typeDefs);
    }
    if (config.resolvers != null) {
        const additionalResolvers = (0, utils_1.asArray)(config.resolvers);
        extractedResolvers.push(...additionalResolvers);
    }
    if (config.schemaExtensions != null) {
        const additionalSchemaExtensions = (0, utils_1.asArray)(config.schemaExtensions);
        extractedSchemaExtensions.push(...additionalSchemaExtensions);
    }
    return (0, makeExecutableSchema_js_1.makeExecutableSchema)({
        ...config,
        typeDefs: extractedTypeDefs,
        resolvers: extractedResolvers,
        schemaExtensions: extractedSchemaExtensions
    });
}
exports.mergeSchemas = mergeSchemas;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extractExtensionsFromSchema = exports.extendResolversFromInterfaces = exports.checkForResolveTypeResolver = exports.addResolversToSchema = exports.chainResolvers = exports.assertResolversPresent = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
var assertResolversPresent_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js [app-route] (ecmascript)");
Object.defineProperty(exports, "assertResolversPresent", {
    enumerable: true,
    get: function() {
        return assertResolversPresent_js_1.assertResolversPresent;
    }
});
var chainResolvers_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/chainResolvers.js [app-route] (ecmascript)");
Object.defineProperty(exports, "chainResolvers", {
    enumerable: true,
    get: function() {
        return chainResolvers_js_1.chainResolvers;
    }
});
var addResolversToSchema_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js [app-route] (ecmascript)");
Object.defineProperty(exports, "addResolversToSchema", {
    enumerable: true,
    get: function() {
        return addResolversToSchema_js_1.addResolversToSchema;
    }
});
var checkForResolveTypeResolver_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js [app-route] (ecmascript)");
Object.defineProperty(exports, "checkForResolveTypeResolver", {
    enumerable: true,
    get: function() {
        return checkForResolveTypeResolver_js_1.checkForResolveTypeResolver;
    }
});
var extendResolversFromInterfaces_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js [app-route] (ecmascript)");
Object.defineProperty(exports, "extendResolversFromInterfaces", {
    enumerable: true,
    get: function() {
        return extendResolversFromInterfaces_js_1.extendResolversFromInterfaces;
    }
});
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/types.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/merge-schemas.js [app-route] (ecmascript)"), exports);
var utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "extractExtensionsFromSchema", {
    enumerable: true,
    get: function() {
        return utils_1.extractExtensionsFromSchema;
    }
});
}}),
"[project]/node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertResolversPresent = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
function assertResolversPresent(schema, resolverValidationOptions = {}) {
    const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
    if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' + 'Please configure either requireResolversForAllFields or requireResolversForArgs / ' + 'requireResolversForNonScalar, but not a combination of them.');
    }
    (0, utils_1.forEachField)(schema, (field, typeName, fieldName)=>{
        // requires a resolver for *every* field.
        if (requireResolversForAllFields) {
            expectResolver('requireResolversForAllFields', requireResolversForAllFields, field, typeName, fieldName);
        }
        // requires a resolver on every field that has arguments
        if (requireResolversForArgs && field.args.length > 0) {
            expectResolver('requireResolversForArgs', requireResolversForArgs, field, typeName, fieldName);
        }
        // requires a resolver on every field that returns a non-scalar type
        if (requireResolversForNonScalar !== 'ignore' && !(0, graphql_1.isScalarType)((0, graphql_1.getNamedType)(field.type))) {
            expectResolver('requireResolversForNonScalar', requireResolversForNonScalar, field, typeName, fieldName);
        }
    });
}
exports.assertResolversPresent = assertResolversPresent;
function expectResolver(validator, behavior, field, typeName, fieldName) {
    if (!field.resolve) {
        const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
        if (behavior === 'error') {
            throw new Error(message);
        }
        if (behavior === 'warn') {
            console.warn(message);
        }
        return;
    }
    if (typeof field.resolve !== 'function') {
        throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
    }
}
}}),
"[project]/node_modules/@graphql-tools/schema/cjs/chainResolvers.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.chainResolvers = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
function chainResolvers(resolvers) {
    return (root, args, ctx, info)=>resolvers.reduce((prev, curResolver)=>{
            if (curResolver != null) {
                return curResolver(prev, args, ctx, info);
            }
            return (0, graphql_1.defaultFieldResolver)(prev, args, ctx, info);
        }, root);
}
exports.chainResolvers = chainResolvers;
}}),
"[project]/node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkForResolveTypeResolver = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
// If we have any union or interface types throw if no there is no resolveType resolver
function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
    (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.ABSTRACT_TYPE]: (type)=>{
            if (!type.resolveType) {
                const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into ` + '"resolverValidationOptions.requireResolversForResolveType" to disable this error.';
                if (requireResolversForResolveType === 'error') {
                    throw new Error(message);
                }
                if (requireResolversForResolveType === 'warn') {
                    console.warn(message);
                }
            }
            return undefined;
        }
    });
}
exports.checkForResolveTypeResolver = checkForResolveTypeResolver;
}}),
"[project]/node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extendResolversFromInterfaces = void 0;
function extendResolversFromInterfaces(schema, resolvers) {
    const extendedResolvers = {};
    const typeMap = schema.getTypeMap();
    for(const typeName in typeMap){
        const type = typeMap[typeName];
        if ('getInterfaces' in type) {
            extendedResolvers[typeName] = {};
            for (const iFace of type.getInterfaces()){
                if (resolvers[iFace.name]) {
                    for(const fieldName in resolvers[iFace.name]){
                        if (fieldName === '__isTypeOf' || !fieldName.startsWith('__')) {
                            extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
                        }
                    }
                }
            }
            const typeResolvers = resolvers[typeName];
            extendedResolvers[typeName] = {
                ...extendedResolvers[typeName],
                ...typeResolvers
            };
        } else {
            const typeResolvers = resolvers[typeName];
            if (typeResolvers != null) {
                extendedResolvers[typeName] = typeResolvers;
            }
        }
    }
    return extendedResolvers;
}
exports.extendResolversFromInterfaces = extendResolversFromInterfaces;
}}),
"[project]/node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addResolversToSchema = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
const checkForResolveTypeResolver_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js [app-route] (ecmascript)");
const extendResolversFromInterfaces_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js [app-route] (ecmascript)");
function addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
    const options = (0, graphql_1.isSchema)(schemaOrOptions) ? {
        schema: schemaOrOptions,
        resolvers: legacyInputResolvers !== null && legacyInputResolvers !== void 0 ? legacyInputResolvers : {},
        resolverValidationOptions: legacyInputValidationOptions
    } : schemaOrOptions;
    let { schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false } = options;
    const { requireResolversToMatchSchema = 'error', requireResolversForResolveType } = resolverValidationOptions;
    const resolvers = inheritResolversFromInterfaces ? (0, extendResolversFromInterfaces_js_1.extendResolversFromInterfaces)(schema, inputResolvers) : inputResolvers;
    for(const typeName in resolvers){
        const resolverValue = resolvers[typeName];
        const resolverType = typeof resolverValue;
        if (resolverType !== 'object') {
            throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
        }
        const type = schema.getType(typeName);
        if (type == null) {
            if (requireResolversToMatchSchema === 'ignore') {
                continue;
            }
            throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
        } else if ((0, graphql_1.isSpecifiedScalarType)(type)) {
            // allow -- without recommending -- overriding of specified scalar types
            for(const fieldName in resolverValue){
                if (fieldName.startsWith('__')) {
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                } else {
                    type[fieldName] = resolverValue[fieldName];
                }
            }
        } else if ((0, graphql_1.isEnumType)(type)) {
            const values = type.getValues();
            for(const fieldName in resolverValue){
                if (!fieldName.startsWith('__') && !values.some((value)=>value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {
                    throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);
                }
            }
        } else if ((0, graphql_1.isUnionType)(type)) {
            for(const fieldName in resolverValue){
                if (!fieldName.startsWith('__') && requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {
                    throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);
                }
            }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
            for(const fieldName in resolverValue){
                if (!fieldName.startsWith('__')) {
                    const fields = type.getFields();
                    const field = fields[fieldName];
                    if (field == null) {
                        // Field present in resolver but not in schema
                        if (requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {
                            throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
                        }
                    } else {
                        // Field present in both the resolver and schema
                        const fieldResolve = resolverValue[fieldName];
                        if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {
                            throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
                        }
                    }
                }
            }
        }
    }
    schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);
    if (requireResolversForResolveType && requireResolversForResolveType !== 'ignore') {
        (0, checkForResolveTypeResolver_js_1.checkForResolveTypeResolver)(schema, requireResolversForResolveType);
    }
    return schema;
}
exports.addResolversToSchema = addResolversToSchema;
function addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const typeMap = schema.getTypeMap();
    for(const typeName in resolvers){
        const type = schema.getType(typeName);
        const resolverValue = resolvers[typeName];
        if ((0, graphql_1.isScalarType)(type)) {
            for(const fieldName in resolverValue){
                if (fieldName.startsWith('__')) {
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                } else if (fieldName === 'astNode' && type.astNode != null) {
                    type.astNode = {
                        ...type.astNode,
                        description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.astNode.description,
                        directives: ((_c = type.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                    };
                } else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {
                    type.extensionASTNodes = type.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
                } else if (fieldName === 'extensions' && type.extensions != null && resolverValue.extensions != null) {
                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
                } else {
                    type[fieldName] = resolverValue[fieldName];
                }
            }
        } else if ((0, graphql_1.isEnumType)(type)) {
            const config = type.toConfig();
            const enumValueConfigMap = config.values;
            for(const fieldName in resolverValue){
                if (fieldName.startsWith('__')) {
                    config[fieldName.substring(2)] = resolverValue[fieldName];
                } else if (fieldName === 'astNode' && config.astNode != null) {
                    config.astNode = {
                        ...config.astNode,
                        description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config.astNode.description,
                        directives: ((_j = config.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : [])
                    };
                } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {
                    config.extensionASTNodes = config.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);
                } else if (fieldName === 'extensions' && type.extensions != null && resolverValue.extensions != null) {
                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
                } else if (enumValueConfigMap[fieldName]) {
                    enumValueConfigMap[fieldName].value = resolverValue[fieldName];
                }
            }
            typeMap[typeName] = new graphql_1.GraphQLEnumType(config);
        } else if ((0, graphql_1.isUnionType)(type)) {
            for(const fieldName in resolverValue){
                if (fieldName.startsWith('__')) {
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                }
            }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
            for(const fieldName in resolverValue){
                if (fieldName.startsWith('__')) {
                    // this is for isTypeOf and resolveType and all the other stuff.
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                    continue;
                }
                const fields = type.getFields();
                const field = fields[fieldName];
                if (field != null) {
                    const fieldResolve = resolverValue[fieldName];
                    if (typeof fieldResolve === 'function') {
                        // for convenience. Allows shorter syntax in resolver definition file
                        field.resolve = fieldResolve.bind(resolverValue);
                    } else {
                        setFieldProperties(field, fieldResolve);
                    }
                }
            }
        }
    }
    // serialize all default values prior to healing fields with new scalar/enum types.
    (0, utils_1.forEachDefaultValue)(schema, utils_1.serializeInputValue);
    // schema may have new scalar/enum types that require healing
    (0, utils_1.healSchema)(schema);
    // reparse all default values with new parsing functions.
    (0, utils_1.forEachDefaultValue)(schema, utils_1.parseInputValue);
    if (defaultFieldResolver != null) {
        (0, utils_1.forEachField)(schema, (field)=>{
            if (!field.resolve) {
                field.resolve = defaultFieldResolver;
            }
        });
    }
    return schema;
}
function createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {
    schema = (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.SCALAR_TYPE]: (type)=>{
            var _a, _b, _c, _d, _e, _f;
            const config = type.toConfig();
            const resolverValue = resolvers[type.name];
            if (!(0, graphql_1.isSpecifiedScalarType)(type) && resolverValue != null) {
                for(const fieldName in resolverValue){
                    if (fieldName.startsWith('__')) {
                        config[fieldName.substring(2)] = resolverValue[fieldName];
                    } else if (fieldName === 'astNode' && config.astNode != null) {
                        config.astNode = {
                            ...config.astNode,
                            description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
                            directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                        };
                    } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {
                        config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
                    } else if (fieldName === 'extensions' && config.extensions != null && resolverValue.extensions != null) {
                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
                    } else {
                        config[fieldName] = resolverValue[fieldName];
                    }
                }
                return new graphql_1.GraphQLScalarType(config);
            }
        },
        [utils_1.MapperKind.ENUM_TYPE]: (type)=>{
            var _a, _b, _c, _d, _e, _f;
            const resolverValue = resolvers[type.name];
            const config = type.toConfig();
            const enumValueConfigMap = config.values;
            if (resolverValue != null) {
                for(const fieldName in resolverValue){
                    if (fieldName.startsWith('__')) {
                        config[fieldName.substring(2)] = resolverValue[fieldName];
                    } else if (fieldName === 'astNode' && config.astNode != null) {
                        config.astNode = {
                            ...config.astNode,
                            description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
                            directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                        };
                    } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {
                        config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
                    } else if (fieldName === 'extensions' && config.extensions != null && resolverValue.extensions != null) {
                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
                    } else if (enumValueConfigMap[fieldName]) {
                        enumValueConfigMap[fieldName].value = resolverValue[fieldName];
                    }
                }
                return new graphql_1.GraphQLEnumType(config);
            }
        },
        [utils_1.MapperKind.UNION_TYPE]: (type)=>{
            const resolverValue = resolvers[type.name];
            if (resolverValue != null) {
                const config = type.toConfig();
                if (resolverValue['__resolveType']) {
                    config.resolveType = resolverValue['__resolveType'];
                }
                return new graphql_1.GraphQLUnionType(config);
            }
        },
        [utils_1.MapperKind.OBJECT_TYPE]: (type)=>{
            const resolverValue = resolvers[type.name];
            if (resolverValue != null) {
                const config = type.toConfig();
                if (resolverValue['__isTypeOf']) {
                    config.isTypeOf = resolverValue['__isTypeOf'];
                }
                return new graphql_1.GraphQLObjectType(config);
            }
        },
        [utils_1.MapperKind.INTERFACE_TYPE]: (type)=>{
            const resolverValue = resolvers[type.name];
            if (resolverValue != null) {
                const config = type.toConfig();
                if (resolverValue['__resolveType']) {
                    config.resolveType = resolverValue['__resolveType'];
                }
                return new graphql_1.GraphQLInterfaceType(config);
            }
        },
        [utils_1.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName)=>{
            const resolverValue = resolvers[typeName];
            if (resolverValue != null) {
                const fieldResolve = resolverValue[fieldName];
                if (fieldResolve != null) {
                    const newFieldConfig = {
                        ...fieldConfig
                    };
                    if (typeof fieldResolve === 'function') {
                        // for convenience. Allows shorter syntax in resolver definition file
                        newFieldConfig.resolve = fieldResolve.bind(resolverValue);
                    } else {
                        setFieldProperties(newFieldConfig, fieldResolve);
                    }
                    return newFieldConfig;
                }
            }
        }
    });
    if (defaultFieldResolver != null) {
        schema = (0, utils_1.mapSchema)(schema, {
            [utils_1.MapperKind.OBJECT_FIELD]: (fieldConfig)=>({
                    ...fieldConfig,
                    resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver
                })
        });
    }
    return schema;
}
function setFieldProperties(field, propertiesObj) {
    for(const propertyName in propertiesObj){
        field[propertyName] = propertiesObj[propertyName];
    }
}
}}),
"[project]/node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeExecutableSchema = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
const addResolversToSchema_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js [app-route] (ecmascript)");
const assertResolversPresent_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js [app-route] (ecmascript)");
const merge_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/index.js [app-route] (ecmascript)");
/**
 * Builds a schema from the provided type definitions and resolvers.
 *
 * The type definitions are written using Schema Definition Language (SDL). They
 * can be provided as a string, a `DocumentNode`, a function, or an array of any
 * of these. If a function is provided, it will be passed no arguments and
 * should return an array of strings or `DocumentNode`s.
 *
 * Note: You can use `graphql-tag` to not only parse a string into a
 * `DocumentNode` but also to provide additional syntax highlighting in your
 * editor (with the appropriate editor plugin).
 *
 * ```js
 * const typeDefs = gql`
 *   type Query {
 *     posts: [Post]
 *     author(id: Int!): Author
 *   }
 * `;
 * ```
 *
 * The `resolvers` object should be a map of type names to nested object, which
 * themselves map the type's fields to their appropriate resolvers.
 * See the [Resolvers](/docs/resolvers) section of the documentation for more details.
 *
 * ```js
 * const resolvers = {
 *   Query: {
 *     posts: (obj, args, ctx, info) => getAllPosts(),
 *     author: (obj, args, ctx, info) => getAuthorById(args.id)
 *   }
 * };
 * ```
 *
 * Once you've defined both the `typeDefs` and `resolvers`, you can create your
 * schema:
 *
 * ```js
 * const schema = makeExecutableSchema({
 *   typeDefs,
 *   resolvers,
 * })
 * ```
 */ function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, parseOptions = {}, inheritResolversFromInterfaces = false, pruningOptions, updateResolversInPlace = false, schemaExtensions }) {
    // Validate and clean up arguments
    if (typeof resolverValidationOptions !== 'object') {
        throw new Error('Expected `resolverValidationOptions` to be an object');
    }
    if (!typeDefs) {
        throw new Error('Must provide typeDefs');
    }
    let schema;
    if ((0, graphql_1.isSchema)(typeDefs)) {
        schema = typeDefs;
    } else if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.commentDescriptions) {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, {
            ...parseOptions,
            commentDescriptions: true
        });
        schema = (0, graphql_1.buildSchema)(mergedTypeDefs, parseOptions);
    } else {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, parseOptions);
        schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, parseOptions);
    }
    if (pruningOptions) {
        schema = (0, utils_1.pruneSchema)(schema);
    }
    // We allow passing in an array of resolver maps, in which case we merge them
    schema = (0, addResolversToSchema_js_1.addResolversToSchema)({
        schema,
        resolvers: (0, merge_1.mergeResolvers)(resolvers),
        resolverValidationOptions,
        inheritResolversFromInterfaces,
        updateResolversInPlace
    });
    if (Object.keys(resolverValidationOptions).length > 0) {
        (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);
    }
    if (schemaExtensions) {
        schemaExtensions = (0, merge_1.mergeExtensions)((0, utils_1.asArray)(schemaExtensions));
        (0, merge_1.applyExtensions)(schema, schemaExtensions);
    }
    return schema;
}
exports.makeExecutableSchema = makeExecutableSchema;
}}),
"[project]/node_modules/@graphql-tools/schema/cjs/types.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
}}),
"[project]/node_modules/@graphql-tools/schema/cjs/merge-schemas.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeSchemas = void 0;
const merge_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
const makeExecutableSchema_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js [app-route] (ecmascript)");
/**
 * Synchronously merges multiple schemas, typeDefinitions and/or resolvers into a single schema.
 * @param config Configuration object
 */ function mergeSchemas(config) {
    const extractedTypeDefs = (0, utils_1.asArray)(config.typeDefs || []);
    const extractedResolvers = (0, utils_1.asArray)(config.resolvers || []);
    const extractedSchemaExtensions = (0, utils_1.asArray)(config.schemaExtensions || []);
    const schemas = config.schemas || [];
    for (const schema of schemas){
        extractedTypeDefs.push(schema);
        extractedResolvers.push((0, utils_1.getResolversFromSchema)(schema, true));
        extractedSchemaExtensions.push((0, merge_1.extractExtensionsFromSchema)(schema));
    }
    return (0, makeExecutableSchema_js_1.makeExecutableSchema)({
        parseOptions: config,
        ...config,
        typeDefs: extractedTypeDefs,
        resolvers: extractedResolvers,
        schemaExtensions: extractedSchemaExtensions
    });
}
exports.mergeSchemas = mergeSchemas;
}}),
"[project]/node_modules/@graphql-tools/schema/cjs/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extendResolversFromInterfaces = exports.checkForResolveTypeResolver = exports.addResolversToSchema = exports.chainResolvers = exports.assertResolversPresent = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
var assertResolversPresent_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js [app-route] (ecmascript)");
Object.defineProperty(exports, "assertResolversPresent", {
    enumerable: true,
    get: function() {
        return assertResolversPresent_js_1.assertResolversPresent;
    }
});
var chainResolvers_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/cjs/chainResolvers.js [app-route] (ecmascript)");
Object.defineProperty(exports, "chainResolvers", {
    enumerable: true,
    get: function() {
        return chainResolvers_js_1.chainResolvers;
    }
});
var addResolversToSchema_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js [app-route] (ecmascript)");
Object.defineProperty(exports, "addResolversToSchema", {
    enumerable: true,
    get: function() {
        return addResolversToSchema_js_1.addResolversToSchema;
    }
});
var checkForResolveTypeResolver_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js [app-route] (ecmascript)");
Object.defineProperty(exports, "checkForResolveTypeResolver", {
    enumerable: true,
    get: function() {
        return checkForResolveTypeResolver_js_1.checkForResolveTypeResolver;
    }
});
var extendResolversFromInterfaces_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js [app-route] (ecmascript)");
Object.defineProperty(exports, "extendResolversFromInterfaces", {
    enumerable: true,
    get: function() {
        return extendResolversFromInterfaces_js_1.extendResolversFromInterfaces;
    }
});
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/cjs/types.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/schema/cjs/merge-schemas.js [app-route] (ecmascript)"), exports);
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/merge-resolvers.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeResolvers = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
/**
 * Deep merges multiple resolver definition objects into a single definition.
 * @param resolversDefinitions Resolver definitions to be merged
 * @param options Additional options
 *
 * ```js
 * const { mergeResolvers } = require('@graphql-tools/merge');
 * const clientResolver = require('./clientResolver');
 * const productResolver = require('./productResolver');
 *
 * const resolvers = mergeResolvers([
 *  clientResolver,
 *  productResolver,
 * ]);
 * ```
 *
 * If you don't want to manually create the array of resolver objects, you can
 * also use this function along with loadFiles:
 *
 * ```js
 * const path = require('path');
 * const { mergeResolvers } = require('@graphql-tools/merge');
 * const { loadFilesSync } = require('@graphql-tools/load-files');
 *
 * const resolversArray = loadFilesSync(path.join(__dirname, './resolvers'));
 *
 * const resolvers = mergeResolvers(resolversArray)
 * ```
 */ function mergeResolvers(resolversDefinitions, options) {
    if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
        return {};
    }
    if (!Array.isArray(resolversDefinitions)) {
        return resolversDefinitions;
    }
    if (resolversDefinitions.length === 1) {
        return resolversDefinitions[0] || {};
    }
    const resolvers = new Array();
    for (let resolversDefinition of resolversDefinitions){
        if (Array.isArray(resolversDefinition)) {
            resolversDefinition = mergeResolvers(resolversDefinition);
        }
        if (typeof resolversDefinition === 'object' && resolversDefinition) {
            resolvers.push(resolversDefinition);
        }
    }
    const result = (0, utils_1.mergeDeep)(resolvers, true);
    if (options === null || options === void 0 ? void 0 : options.exclusions) {
        for (const exclusion of options.exclusions){
            const [typeName, fieldName] = exclusion.split('.');
            if (!fieldName || fieldName === '*') {
                delete result[typeName];
            } else if (result[typeName]) {
                delete result[typeName][fieldName];
            }
        }
    }
    return result;
}
exports.mergeResolvers = mergeResolvers;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeArguments = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
function mergeArguments(args1, args2, config) {
    const result = deduplicateArguments([
        ...args2,
        ...args1
    ].filter(utils_1.isSome), config);
    if (config && config.sort) {
        result.sort(utils_1.compareNodes);
    }
    return result;
}
exports.mergeArguments = mergeArguments;
function deduplicateArguments(args, config) {
    return args.reduce((acc, current)=>{
        const dupIndex = acc.findIndex((arg)=>arg.name.value === current.name.value);
        if (dupIndex === -1) {
            return acc.concat([
                current
            ]);
        } else if (!(config === null || config === void 0 ? void 0 : config.reverseArguments)) {
            acc[dupIndex] = current;
        }
        return acc;
    }, []);
}
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeDirective = exports.mergeDirectives = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
function directiveAlreadyExists(directivesArr, otherDirective) {
    return !!directivesArr.find((directive)=>directive.name.value === otherDirective.name.value);
}
function isRepeatableDirective(directive, directives) {
    var _a;
    return !!((_a = directives === null || directives === void 0 ? void 0 : directives[directive.name.value]) === null || _a === void 0 ? void 0 : _a.repeatable);
}
function nameAlreadyExists(name, namesArr) {
    return namesArr.some(({ value })=>value === name.value);
}
function mergeArguments(a1, a2) {
    const result = [
        ...a2
    ];
    for (const argument of a1){
        const existingIndex = result.findIndex((a)=>a.name.value === argument.name.value);
        if (existingIndex > -1) {
            const existingArg = result[existingIndex];
            if (existingArg.value.kind === 'ListValue') {
                const source = existingArg.value.values;
                const target = argument.value.values;
                // merge values of two lists
                existingArg.value.values = deduplicateLists(source, target, (targetVal, source)=>{
                    const value = targetVal.value;
                    return !value || !source.some((sourceVal)=>sourceVal.value === value);
                });
            } else {
                existingArg.value = argument.value;
            }
        } else {
            result.push(argument);
        }
    }
    return result;
}
function deduplicateDirectives(directives, definitions) {
    return directives.map((directive, i, all)=>{
        const firstAt = all.findIndex((d)=>d.name.value === directive.name.value);
        if (firstAt !== i && !isRepeatableDirective(directive, definitions)) {
            const dup = all[firstAt];
            directive.arguments = mergeArguments(directive.arguments, dup.arguments);
            return null;
        }
        return directive;
    }).filter(utils_1.isSome);
}
function mergeDirectives(d1 = [], d2 = [], config, directives) {
    const reverseOrder = config && config.reverseDirectives;
    const asNext = reverseOrder ? d1 : d2;
    const asFirst = reverseOrder ? d2 : d1;
    const result = deduplicateDirectives([
        ...asNext
    ], directives);
    for (const directive of asFirst){
        if (directiveAlreadyExists(result, directive) && !isRepeatableDirective(directive, directives)) {
            const existingDirectiveIndex = result.findIndex((d)=>d.name.value === directive.name.value);
            const existingDirective = result[existingDirectiveIndex];
            result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);
        } else {
            result.push(directive);
        }
    }
    return result;
}
exports.mergeDirectives = mergeDirectives;
function validateInputs(node, existingNode) {
    const printedNode = (0, graphql_1.print)({
        ...node,
        description: undefined
    });
    const printedExistingNode = (0, graphql_1.print)({
        ...existingNode,
        description: undefined
    });
    // eslint-disable-next-line
    const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');
    const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');
    if (!sameArguments) {
        throw new Error(`Unable to merge GraphQL directive "${node.name.value}". \nExisting directive:  \n\t${printedExistingNode} \nReceived directive: \n\t${printedNode}`);
    }
}
function mergeDirective(node, existingNode) {
    if (existingNode) {
        validateInputs(node, existingNode);
        return {
            ...node,
            locations: [
                ...existingNode.locations,
                ...node.locations.filter((name)=>!nameAlreadyExists(name, existingNode.locations))
            ]
        };
    }
    return node;
}
exports.mergeDirective = mergeDirective;
function deduplicateLists(source, target, filterFn) {
    return source.concat(target.filter((val)=>filterFn(val, source)));
}
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeEnumValues = void 0;
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
function mergeEnumValues(first, second, config, directives) {
    if (config === null || config === void 0 ? void 0 : config.consistentEnumMerge) {
        const reversed = [];
        if (first) {
            reversed.push(...first);
        }
        first = second;
        second = reversed;
    }
    const enumValueMap = new Map();
    if (first) {
        for (const firstValue of first){
            enumValueMap.set(firstValue.name.value, firstValue);
        }
    }
    if (second) {
        for (const secondValue of second){
            const enumValue = secondValue.name.value;
            if (enumValueMap.has(enumValue)) {
                const firstValue = enumValueMap.get(enumValue);
                firstValue.description = secondValue.description || firstValue.description;
                firstValue.directives = (0, directives_js_1.mergeDirectives)(secondValue.directives, firstValue.directives, directives);
            } else {
                enumValueMap.set(enumValue, secondValue);
            }
        }
    }
    const result = [
        ...enumValueMap.values()
    ];
    if (config && config.sort) {
        result.sort(utils_1.compareNodes);
    }
    return result;
}
exports.mergeEnumValues = mergeEnumValues;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeEnum = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
const enum_values_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js [app-route] (ecmascript)");
function mergeEnum(e1, e2, config, directives) {
    if (e2) {
        return {
            name: e1.name,
            description: e1['description'] || e2['description'],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || e1.kind === 'EnumTypeDefinition' || e2.kind === 'EnumTypeDefinition' ? 'EnumTypeDefinition' : 'EnumTypeExtension',
            loc: e1.loc,
            directives: (0, directives_js_1.mergeDirectives)(e1.directives, e2.directives, config, directives),
            values: (0, enum_values_js_1.mergeEnumValues)(e1.values, e2.values, config)
        };
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...e1,
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION
    } : e1;
}
exports.mergeEnum = mergeEnum;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defaultStringComparator = exports.CompareVal = exports.printTypeNode = exports.isNonNullTypeNode = exports.isListTypeNode = exports.isWrappingTypeNode = exports.extractType = exports.isSourceTypes = exports.isStringTypes = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
function isStringTypes(types) {
    return typeof types === 'string';
}
exports.isStringTypes = isStringTypes;
function isSourceTypes(types) {
    return types instanceof graphql_1.Source;
}
exports.isSourceTypes = isSourceTypes;
function extractType(type) {
    let visitedType = type;
    while(visitedType.kind === graphql_1.Kind.LIST_TYPE || visitedType.kind === 'NonNullType'){
        visitedType = visitedType.type;
    }
    return visitedType;
}
exports.extractType = extractType;
function isWrappingTypeNode(type) {
    return type.kind !== graphql_1.Kind.NAMED_TYPE;
}
exports.isWrappingTypeNode = isWrappingTypeNode;
function isListTypeNode(type) {
    return type.kind === graphql_1.Kind.LIST_TYPE;
}
exports.isListTypeNode = isListTypeNode;
function isNonNullTypeNode(type) {
    return type.kind === graphql_1.Kind.NON_NULL_TYPE;
}
exports.isNonNullTypeNode = isNonNullTypeNode;
function printTypeNode(type) {
    if (isListTypeNode(type)) {
        return `[${printTypeNode(type.type)}]`;
    }
    if (isNonNullTypeNode(type)) {
        return `${printTypeNode(type.type)}!`;
    }
    return type.name.value;
}
exports.printTypeNode = printTypeNode;
var CompareVal;
(function(CompareVal) {
    CompareVal[CompareVal["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
    CompareVal[CompareVal["A_EQUALS_B"] = 0] = "A_EQUALS_B";
    CompareVal[CompareVal["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
})(CompareVal = exports.CompareVal || (exports.CompareVal = {}));
function defaultStringComparator(a, b) {
    if (a == null && b == null) {
        return CompareVal.A_EQUALS_B;
    }
    if (a == null) {
        return CompareVal.A_SMALLER_THAN_B;
    }
    if (b == null) {
        return CompareVal.A_GREATER_THAN_B;
    }
    if (a < b) return CompareVal.A_SMALLER_THAN_B;
    if (a > b) return CompareVal.A_GREATER_THAN_B;
    return CompareVal.A_EQUALS_B;
}
exports.defaultStringComparator = defaultStringComparator;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeFields = void 0;
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
const arguments_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js [app-route] (ecmascript)");
function fieldAlreadyExists(fieldsArr, otherField) {
    const resultIndex = fieldsArr.findIndex((field)=>field.name.value === otherField.name.value);
    return [
        resultIndex > -1 ? fieldsArr[resultIndex] : null,
        resultIndex
    ];
}
function mergeFields(type, f1, f2, config, directives) {
    const result = [];
    if (f2 != null) {
        result.push(...f2);
    }
    if (f1 != null) {
        for (const field of f1){
            const [existing, existingIndex] = fieldAlreadyExists(result, field);
            if (existing && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {
                const newField = (config === null || config === void 0 ? void 0 : config.onFieldTypeConflict) && config.onFieldTypeConflict(existing, field, type, config === null || config === void 0 ? void 0 : config.throwOnConflict) || preventConflicts(type, existing, field, config === null || config === void 0 ? void 0 : config.throwOnConflict);
                newField.arguments = (0, arguments_js_1.mergeArguments)(field['arguments'] || [], existing['arguments'] || [], config);
                newField.directives = (0, directives_js_1.mergeDirectives)(field.directives, existing.directives, config, directives);
                newField.description = field.description || existing.description;
                result[existingIndex] = newField;
            } else {
                result.push(field);
            }
        }
    }
    if (config && config.sort) {
        result.sort(utils_1.compareNodes);
    }
    if (config && config.exclusions) {
        const exclusions = config.exclusions;
        return result.filter((field)=>!exclusions.includes(`${type.name.value}.${field.name.value}`));
    }
    return result;
}
exports.mergeFields = mergeFields;
function preventConflicts(type, a, b, ignoreNullability = false) {
    const aType = (0, utils_js_1.printTypeNode)(a.type);
    const bType = (0, utils_js_1.printTypeNode)(b.type);
    if (aType !== bType) {
        const t1 = (0, utils_js_1.extractType)(a.type);
        const t2 = (0, utils_js_1.extractType)(b.type);
        if (t1.name.value !== t2.name.value) {
            throw new Error(`Field "${b.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
        }
        if (!safeChangeForFieldType(a.type, b.type, !ignoreNullability)) {
            throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
        }
    }
    if ((0, utils_js_1.isNonNullTypeNode)(b.type) && !(0, utils_js_1.isNonNullTypeNode)(a.type)) {
        a.type = b.type;
    }
    return a;
}
function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
    // both are named
    if (!(0, utils_js_1.isWrappingTypeNode)(oldType) && !(0, utils_js_1.isWrappingTypeNode)(newType)) {
        return oldType.toString() === newType.toString();
    }
    // new is non-null
    if ((0, utils_js_1.isNonNullTypeNode)(newType)) {
        const ofType = (0, utils_js_1.isNonNullTypeNode)(oldType) ? oldType.type : oldType;
        return safeChangeForFieldType(ofType, newType.type);
    }
    // old is non-null
    if ((0, utils_js_1.isNonNullTypeNode)(oldType)) {
        return safeChangeForFieldType(newType, oldType, ignoreNullability);
    }
    // old is list
    if ((0, utils_js_1.isListTypeNode)(oldType)) {
        return (0, utils_js_1.isListTypeNode)(newType) && safeChangeForFieldType(oldType.type, newType.type) || (0, utils_js_1.isNonNullTypeNode)(newType) && safeChangeForFieldType(oldType, newType['type']);
    }
    return false;
}
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeInputType = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const fields_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
function mergeInputType(node, existingNode, config, directives) {
    if (existingNode) {
        try {
            return {
                name: node.name,
                description: node['description'] || existingNode['description'],
                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'InputObjectTypeDefinition' || existingNode.kind === 'InputObjectTypeDefinition' ? 'InputObjectTypeDefinition' : 'InputObjectTypeExtension',
                loc: node.loc,
                fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
                directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives)
            };
        } catch (e) {
            throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
        }
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION
    } : node;
}
exports.mergeInputType = mergeInputType;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeNamedTypeArray = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
function alreadyExists(arr, other) {
    return !!arr.find((i)=>i.name.value === other.name.value);
}
function mergeNamedTypeArray(first = [], second = [], config = {}) {
    const result = [
        ...second,
        ...first.filter((d)=>!alreadyExists(second, d))
    ];
    if (config && config.sort) {
        result.sort(utils_1.compareNodes);
    }
    return result;
}
exports.mergeNamedTypeArray = mergeNamedTypeArray;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeInterface = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const fields_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
const merge_named_type_array_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js [app-route] (ecmascript)");
function mergeInterface(node, existingNode, config, directives) {
    if (existingNode) {
        try {
            return {
                name: node.name,
                description: node['description'] || existingNode['description'],
                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'InterfaceTypeDefinition' || existingNode.kind === 'InterfaceTypeDefinition' ? 'InterfaceTypeDefinition' : 'InterfaceTypeExtension',
                loc: node.loc,
                fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
                directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives),
                interfaces: node['interfaces'] ? (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node['interfaces'], existingNode['interfaces'], config) : undefined
            };
        } catch (e) {
            throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
        }
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION
    } : node;
}
exports.mergeInterface = mergeInterface;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeType = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const fields_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
const merge_named_type_array_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js [app-route] (ecmascript)");
function mergeType(node, existingNode, config, directives) {
    if (existingNode) {
        try {
            return {
                name: node.name,
                description: node['description'] || existingNode['description'],
                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'ObjectTypeDefinition' || existingNode.kind === 'ObjectTypeDefinition' ? 'ObjectTypeDefinition' : 'ObjectTypeExtension',
                loc: node.loc,
                fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
                directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives),
                interfaces: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node.interfaces, existingNode.interfaces, config)
            };
        } catch (e) {
            throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
        }
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION
    } : node;
}
exports.mergeType = mergeType;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeScalar = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
function mergeScalar(node, existingNode, config, directives) {
    if (existingNode) {
        return {
            name: node.name,
            description: node['description'] || existingNode['description'],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'ScalarTypeDefinition' || existingNode.kind === 'ScalarTypeDefinition' ? 'ScalarTypeDefinition' : 'ScalarTypeExtension',
            loc: node.loc,
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives)
        };
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION
    } : node;
}
exports.mergeScalar = mergeScalar;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeUnion = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
const merge_named_type_array_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js [app-route] (ecmascript)");
function mergeUnion(first, second, config, directives) {
    if (second) {
        return {
            name: first.name,
            description: first['description'] || second['description'],
            // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
            directives: (0, directives_js_1.mergeDirectives)(first.directives, second.directives, config, directives),
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || first.kind === 'UnionTypeDefinition' || second.kind === 'UnionTypeDefinition' ? graphql_1.Kind.UNION_TYPE_DEFINITION : graphql_1.Kind.UNION_TYPE_EXTENSION,
            loc: first.loc,
            types: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(first.types, second.types, config)
        };
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...first,
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION
    } : first;
}
exports.mergeUnion = mergeUnion;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeSchemaDefs = exports.DEFAULT_OPERATION_TYPE_NAME_MAP = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
exports.DEFAULT_OPERATION_TYPE_NAME_MAP = {
    query: 'Query',
    mutation: 'Mutation',
    subscription: 'Subscription'
};
function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
    const finalOpNodeList = [];
    for(const opNodeType in exports.DEFAULT_OPERATION_TYPE_NAME_MAP){
        const opNode = opNodeList.find((n)=>n.operation === opNodeType) || existingOpNodeList.find((n)=>n.operation === opNodeType);
        if (opNode) {
            finalOpNodeList.push(opNode);
        }
    }
    return finalOpNodeList;
}
function mergeSchemaDefs(node, existingNode, config, directives) {
    if (existingNode) {
        return {
            kind: node.kind === graphql_1.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql_1.Kind.SCHEMA_DEFINITION ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
            description: node['description'] || existingNode['description'],
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config, directives),
            operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
        };
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCHEMA_DEFINITION
    } : node;
}
exports.mergeSchemaDefs = mergeSchemaDefs;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeGraphQLNodes = exports.isNamedDefinitionNode = exports.schemaDefSymbol = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js [app-route] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js [app-route] (ecmascript)");
const scalar_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js [app-route] (ecmascript)");
const union_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js [app-route] (ecmascript)");
const input_type_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js [app-route] (ecmascript)");
const interface_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
const schema_def_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
exports.schemaDefSymbol = 'SCHEMA_DEF_SYMBOL';
function isNamedDefinitionNode(definitionNode) {
    return 'name' in definitionNode;
}
exports.isNamedDefinitionNode = isNamedDefinitionNode;
function mergeGraphQLNodes(nodes, config, directives = {}) {
    var _a, _b, _c;
    const mergedResultMap = directives;
    for (const nodeDefinition of nodes){
        if (isNamedDefinitionNode(nodeDefinition)) {
            const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;
            if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
                (0, utils_1.collectComment)(nodeDefinition);
            }
            if (name == null) {
                continue;
            }
            if (((_b = config === null || config === void 0 ? void 0 : config.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + '.*')) || ((_c = config === null || config === void 0 ? void 0 : config.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {
                delete mergedResultMap[name];
            } else {
                switch(nodeDefinition.kind){
                    case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
                    case graphql_1.Kind.OBJECT_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, type_js_1.mergeType)(nodeDefinition, mergedResultMap[name], config, directives);
                        break;
                    case graphql_1.Kind.ENUM_TYPE_DEFINITION:
                    case graphql_1.Kind.ENUM_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, enum_js_1.mergeEnum)(nodeDefinition, mergedResultMap[name], config, directives);
                        break;
                    case graphql_1.Kind.UNION_TYPE_DEFINITION:
                    case graphql_1.Kind.UNION_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, union_js_1.mergeUnion)(nodeDefinition, mergedResultMap[name], config, directives);
                        break;
                    case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
                    case graphql_1.Kind.SCALAR_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, scalar_js_1.mergeScalar)(nodeDefinition, mergedResultMap[name], config, directives);
                        break;
                    case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
                    case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, input_type_js_1.mergeInputType)(nodeDefinition, mergedResultMap[name], config, directives);
                        break;
                    case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
                    case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, interface_js_1.mergeInterface)(nodeDefinition, mergedResultMap[name], config, directives);
                        break;
                    case graphql_1.Kind.DIRECTIVE_DEFINITION:
                        mergedResultMap[name] = (0, directives_js_1.mergeDirective)(nodeDefinition, mergedResultMap[name]);
                        break;
                }
            }
        } else if (nodeDefinition.kind === graphql_1.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
            mergedResultMap[exports.schemaDefSymbol] = (0, schema_def_js_1.mergeSchemaDefs)(nodeDefinition, mergedResultMap[exports.schemaDefSymbol], config);
        }
    }
    return mergedResultMap;
}
exports.mergeGraphQLNodes = mergeGraphQLNodes;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeGraphQLTypes = exports.mergeTypeDefs = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js [app-route] (ecmascript)");
const merge_nodes_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
const schema_def_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js [app-route] (ecmascript)");
function mergeTypeDefs(typeSource, config) {
    (0, utils_1.resetComments)();
    const doc = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: mergeGraphQLTypes(typeSource, {
            useSchemaDefinition: true,
            forceSchemaDefinition: false,
            throwOnConflict: false,
            commentDescriptions: false,
            ...config
        })
    };
    let result;
    if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
        result = (0, utils_1.printWithComments)(doc);
    } else {
        result = doc;
    }
    (0, utils_1.resetComments)();
    return result;
}
exports.mergeTypeDefs = mergeTypeDefs;
function visitTypeSources(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = new Set()) {
    if (typeSource && !visitedTypeSources.has(typeSource)) {
        visitedTypeSources.add(typeSource);
        if (typeof typeSource === 'function') {
            visitTypeSources(typeSource(), options, allDirectives, allNodes, visitedTypeSources);
        } else if (Array.isArray(typeSource)) {
            for (const type of typeSource){
                visitTypeSources(type, options, allDirectives, allNodes, visitedTypeSources);
            }
        } else if ((0, graphql_1.isSchema)(typeSource)) {
            const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);
            visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
        } else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {
            const documentNode = (0, graphql_1.parse)(typeSource, options);
            visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
        } else if (typeof typeSource === 'object' && (0, graphql_1.isDefinitionNode)(typeSource)) {
            if (typeSource.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {
                allDirectives.push(typeSource);
            } else {
                allNodes.push(typeSource);
            }
        } else if ((0, utils_1.isDocumentNode)(typeSource)) {
            visitTypeSources(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources);
        } else {
            throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
        }
    }
    return {
        allDirectives,
        allNodes
    };
}
function mergeGraphQLTypes(typeSource, config) {
    var _a, _b, _c;
    (0, utils_1.resetComments)();
    const { allDirectives, allNodes } = visitTypeSources(typeSource, config);
    const mergedDirectives = (0, merge_nodes_js_1.mergeGraphQLNodes)(allDirectives, config);
    const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config, mergedDirectives);
    if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {
        // XXX: right now we don't handle multiple schema definitions
        const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {
            kind: graphql_1.Kind.SCHEMA_DEFINITION,
            operationTypes: []
        };
        const operationTypes = schemaDef.operationTypes;
        for(const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP){
            const opTypeDefNode = operationTypes.find((operationType)=>operationType.operation === opTypeDefNodeType);
            if (!opTypeDefNode) {
                const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
                const existingPossibleRootType = mergedNodes[possibleRootTypeName];
                if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
                    operationTypes.push({
                        kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                        type: {
                            kind: graphql_1.Kind.NAMED_TYPE,
                            name: existingPossibleRootType.name
                        },
                        operation: opTypeDefNodeType
                    });
                }
            }
        }
        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {
            mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;
        }
    }
    if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {
        mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {
            kind: graphql_1.Kind.SCHEMA_DEFINITION,
            operationTypes: [
                {
                    kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                    operation: 'query',
                    type: {
                        kind: graphql_1.Kind.NAMED_TYPE,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: 'Query'
                        }
                    }
                }
            ]
        };
    }
    const mergedNodeDefinitions = Object.values(mergedNodes);
    if (config === null || config === void 0 ? void 0 : config.sort) {
        const sortFn = typeof config.sort === 'function' ? config.sort : utils_js_1.defaultStringComparator;
        mergedNodeDefinitions.sort((a, b)=>{
            var _a, _b;
            return sortFn((_a = a.name) === null || _a === void 0 ? void 0 : _a.value, (_b = b.name) === null || _b === void 0 ? void 0 : _b.value);
        });
    }
    return mergedNodeDefinitions;
}
exports.mergeGraphQLTypes = mergeGraphQLTypes;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js [app-route] (ecmascript)"), exports);
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/extensions.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.applyExtensions = exports.mergeExtensions = exports.extractExtensionsFromSchema = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
var utils_2 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "extractExtensionsFromSchema", {
    enumerable: true,
    get: function() {
        return utils_2.extractExtensionsFromSchema;
    }
});
function mergeExtensions(extensions) {
    return (0, utils_1.mergeDeep)(extensions);
}
exports.mergeExtensions = mergeExtensions;
function applyExtensionObject(obj, extensions) {
    if (!obj) {
        return;
    }
    obj.extensions = (0, utils_1.mergeDeep)([
        obj.extensions || {},
        extensions || {}
    ]);
}
function applyExtensions(schema, extensions) {
    applyExtensionObject(schema, extensions.schemaExtensions);
    for (const [typeName, data] of Object.entries(extensions.types || {})){
        const type = schema.getType(typeName);
        if (type) {
            applyExtensionObject(type, data.extensions);
            if (data.type === 'object' || data.type === 'interface') {
                for (const [fieldName, fieldData] of Object.entries(data.fields)){
                    const field = type.getFields()[fieldName];
                    if (field) {
                        applyExtensionObject(field, fieldData.extensions);
                        for (const [arg, argData] of Object.entries(fieldData.arguments)){
                            applyExtensionObject(field.args.find((a)=>a.name === arg), argData);
                        }
                    }
                }
            } else if (data.type === 'input') {
                for (const [fieldName, fieldData] of Object.entries(data.fields)){
                    const field = type.getFields()[fieldName];
                    applyExtensionObject(field, fieldData.extensions);
                }
            } else if (data.type === 'enum') {
                for (const [valueName, valueData] of Object.entries(data.values)){
                    const value = type.getValue(valueName);
                    applyExtensionObject(value, valueData);
                }
            }
        }
    }
    return schema;
}
exports.applyExtensions = applyExtensions;
}}),
"[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/merge-resolvers.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/extensions.js [app-route] (ecmascript)"), exports);
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/merge-resolvers.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeResolvers = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
/**
 * Deep merges multiple resolver definition objects into a single definition.
 * @param resolversDefinitions Resolver definitions to be merged
 * @param options Additional options
 *
 * ```js
 * const { mergeResolvers } = require('@graphql-tools/merge');
 * const clientResolver = require('./clientResolver');
 * const productResolver = require('./productResolver');
 *
 * const resolvers = mergeResolvers([
 *  clientResolver,
 *  productResolver,
 * ]);
 * ```
 *
 * If you don't want to manually create the array of resolver objects, you can
 * also use this function along with loadFiles:
 *
 * ```js
 * const path = require('path');
 * const { mergeResolvers } = require('@graphql-tools/merge');
 * const { loadFilesSync } = require('@graphql-tools/load-files');
 *
 * const resolversArray = loadFilesSync(path.join(__dirname, './resolvers'));
 *
 * const resolvers = mergeResolvers(resolversArray)
 * ```
 */ function mergeResolvers(resolversDefinitions, options) {
    if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
        return {};
    }
    if (!Array.isArray(resolversDefinitions)) {
        return resolversDefinitions;
    }
    if (resolversDefinitions.length === 1) {
        return resolversDefinitions[0] || {};
    }
    const resolvers = new Array();
    for (let resolversDefinition of resolversDefinitions){
        if (Array.isArray(resolversDefinition)) {
            resolversDefinition = mergeResolvers(resolversDefinition);
        }
        if (typeof resolversDefinition === 'object' && resolversDefinition) {
            resolvers.push(resolversDefinition);
        }
    }
    const result = (0, utils_1.mergeDeep)(resolvers, true);
    if (options === null || options === void 0 ? void 0 : options.exclusions) {
        for (const exclusion of options.exclusions){
            const [typeName, fieldName] = exclusion.split('.');
            if (!fieldName || fieldName === '*') {
                delete result[typeName];
            } else if (result[typeName]) {
                delete result[typeName][fieldName];
            }
        }
    }
    return result;
}
exports.mergeResolvers = mergeResolvers;
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeArguments = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
function mergeArguments(args1, args2, config) {
    const result = deduplicateArguments([
        ...args2,
        ...args1
    ].filter(utils_1.isSome));
    if (config && config.sort) {
        result.sort(utils_1.compareNodes);
    }
    return result;
}
exports.mergeArguments = mergeArguments;
function deduplicateArguments(args) {
    return args.reduce((acc, current)=>{
        const dup = acc.find((arg)=>arg.name.value === current.name.value);
        if (!dup) {
            return acc.concat([
                current
            ]);
        }
        return acc;
    }, []);
}
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeDirective = exports.mergeDirectives = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
function directiveAlreadyExists(directivesArr, otherDirective) {
    return !!directivesArr.find((directive)=>directive.name.value === otherDirective.name.value);
}
function nameAlreadyExists(name, namesArr) {
    return namesArr.some(({ value })=>value === name.value);
}
function mergeArguments(a1, a2) {
    const result = [
        ...a2
    ];
    for (const argument of a1){
        const existingIndex = result.findIndex((a)=>a.name.value === argument.name.value);
        if (existingIndex > -1) {
            const existingArg = result[existingIndex];
            if (existingArg.value.kind === 'ListValue') {
                const source = existingArg.value.values;
                const target = argument.value.values;
                // merge values of two lists
                existingArg.value.values = deduplicateLists(source, target, (targetVal, source)=>{
                    const value = targetVal.value;
                    return !value || !source.some((sourceVal)=>sourceVal.value === value);
                });
            } else {
                existingArg.value = argument.value;
            }
        } else {
            result.push(argument);
        }
    }
    return result;
}
function deduplicateDirectives(directives) {
    return directives.map((directive, i, all)=>{
        const firstAt = all.findIndex((d)=>d.name.value === directive.name.value);
        if (firstAt !== i) {
            const dup = all[firstAt];
            directive.arguments = mergeArguments(directive.arguments, dup.arguments);
            return null;
        }
        return directive;
    }).filter(utils_1.isSome);
}
function mergeDirectives(d1 = [], d2 = [], config) {
    const reverseOrder = config && config.reverseDirectives;
    const asNext = reverseOrder ? d1 : d2;
    const asFirst = reverseOrder ? d2 : d1;
    const result = deduplicateDirectives([
        ...asNext
    ]);
    for (const directive of asFirst){
        if (directiveAlreadyExists(result, directive)) {
            const existingDirectiveIndex = result.findIndex((d)=>d.name.value === directive.name.value);
            const existingDirective = result[existingDirectiveIndex];
            result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);
        } else {
            result.push(directive);
        }
    }
    return result;
}
exports.mergeDirectives = mergeDirectives;
function validateInputs(node, existingNode) {
    const printedNode = (0, graphql_1.print)({
        ...node,
        description: undefined
    });
    const printedExistingNode = (0, graphql_1.print)({
        ...existingNode,
        description: undefined
    });
    // eslint-disable-next-line
    const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');
    const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');
    if (!sameArguments) {
        throw new Error(`Unable to merge GraphQL directive "${node.name.value}". \nExisting directive:  \n\t${printedExistingNode} \nReceived directive: \n\t${printedNode}`);
    }
}
function mergeDirective(node, existingNode) {
    if (existingNode) {
        validateInputs(node, existingNode);
        return {
            ...node,
            locations: [
                ...existingNode.locations,
                ...node.locations.filter((name)=>!nameAlreadyExists(name, existingNode.locations))
            ]
        };
    }
    return node;
}
exports.mergeDirective = mergeDirective;
function deduplicateLists(source, target, filterFn) {
    return source.concat(target.filter((val)=>filterFn(val, source)));
}
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeEnumValues = void 0;
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
function mergeEnumValues(first, second, config) {
    if (config === null || config === void 0 ? void 0 : config.consistentEnumMerge) {
        const reversed = [];
        if (first) {
            reversed.push(...first);
        }
        first = second;
        second = reversed;
    }
    const enumValueMap = new Map();
    if (first) {
        for (const firstValue of first){
            enumValueMap.set(firstValue.name.value, firstValue);
        }
    }
    if (second) {
        for (const secondValue of second){
            const enumValue = secondValue.name.value;
            if (enumValueMap.has(enumValue)) {
                const firstValue = enumValueMap.get(enumValue);
                firstValue.description = secondValue.description || firstValue.description;
                firstValue.directives = (0, directives_js_1.mergeDirectives)(secondValue.directives, firstValue.directives);
            } else {
                enumValueMap.set(enumValue, secondValue);
            }
        }
    }
    const result = [
        ...enumValueMap.values()
    ];
    if (config && config.sort) {
        result.sort(utils_1.compareNodes);
    }
    return result;
}
exports.mergeEnumValues = mergeEnumValues;
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeEnum = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
const enum_values_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js [app-route] (ecmascript)");
function mergeEnum(e1, e2, config) {
    if (e2) {
        return {
            name: e1.name,
            description: e1['description'] || e2['description'],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || e1.kind === 'EnumTypeDefinition' || e2.kind === 'EnumTypeDefinition' ? 'EnumTypeDefinition' : 'EnumTypeExtension',
            loc: e1.loc,
            directives: (0, directives_js_1.mergeDirectives)(e1.directives, e2.directives, config),
            values: (0, enum_values_js_1.mergeEnumValues)(e1.values, e2.values, config)
        };
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...e1,
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION
    } : e1;
}
exports.mergeEnum = mergeEnum;
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defaultStringComparator = exports.CompareVal = exports.printTypeNode = exports.isNonNullTypeNode = exports.isListTypeNode = exports.isWrappingTypeNode = exports.extractType = exports.isSourceTypes = exports.isStringTypes = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
function isStringTypes(types) {
    return typeof types === 'string';
}
exports.isStringTypes = isStringTypes;
function isSourceTypes(types) {
    return types instanceof graphql_1.Source;
}
exports.isSourceTypes = isSourceTypes;
function extractType(type) {
    let visitedType = type;
    while(visitedType.kind === graphql_1.Kind.LIST_TYPE || visitedType.kind === 'NonNullType'){
        visitedType = visitedType.type;
    }
    return visitedType;
}
exports.extractType = extractType;
function isWrappingTypeNode(type) {
    return type.kind !== graphql_1.Kind.NAMED_TYPE;
}
exports.isWrappingTypeNode = isWrappingTypeNode;
function isListTypeNode(type) {
    return type.kind === graphql_1.Kind.LIST_TYPE;
}
exports.isListTypeNode = isListTypeNode;
function isNonNullTypeNode(type) {
    return type.kind === graphql_1.Kind.NON_NULL_TYPE;
}
exports.isNonNullTypeNode = isNonNullTypeNode;
function printTypeNode(type) {
    if (isListTypeNode(type)) {
        return `[${printTypeNode(type.type)}]`;
    }
    if (isNonNullTypeNode(type)) {
        return `${printTypeNode(type.type)}!`;
    }
    return type.name.value;
}
exports.printTypeNode = printTypeNode;
var CompareVal;
(function(CompareVal) {
    CompareVal[CompareVal["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
    CompareVal[CompareVal["A_EQUALS_B"] = 0] = "A_EQUALS_B";
    CompareVal[CompareVal["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
})(CompareVal = exports.CompareVal || (exports.CompareVal = {}));
function defaultStringComparator(a, b) {
    if (a == null && b == null) {
        return CompareVal.A_EQUALS_B;
    }
    if (a == null) {
        return CompareVal.A_SMALLER_THAN_B;
    }
    if (b == null) {
        return CompareVal.A_GREATER_THAN_B;
    }
    if (a < b) return CompareVal.A_SMALLER_THAN_B;
    if (a > b) return CompareVal.A_GREATER_THAN_B;
    return CompareVal.A_EQUALS_B;
}
exports.defaultStringComparator = defaultStringComparator;
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeFields = void 0;
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
const arguments_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js [app-route] (ecmascript)");
function fieldAlreadyExists(fieldsArr, otherField, config) {
    const result = fieldsArr.find((field)=>field.name.value === otherField.name.value);
    if (result && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {
        const t1 = (0, utils_js_1.extractType)(result.type);
        const t2 = (0, utils_js_1.extractType)(otherField.type);
        if (t1.name.value !== t2.name.value) {
            throw new Error(`Field "${otherField.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
        }
    }
    return !!result;
}
function mergeFields(type, f1, f2, config) {
    const result = [];
    if (f2 != null) {
        result.push(...f2);
    }
    if (f1 != null) {
        for (const field of f1){
            if (fieldAlreadyExists(result, field, config)) {
                const existing = result.find((f)=>f.name.value === field.name.value);
                if (!(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {
                    if (config === null || config === void 0 ? void 0 : config.throwOnConflict) {
                        preventConflicts(type, existing, field, false);
                    } else {
                        preventConflicts(type, existing, field, true);
                    }
                    if ((0, utils_js_1.isNonNullTypeNode)(field.type) && !(0, utils_js_1.isNonNullTypeNode)(existing.type)) {
                        existing.type = field.type;
                    }
                }
                existing.arguments = (0, arguments_js_1.mergeArguments)(field['arguments'] || [], existing.arguments || [], config);
                existing.directives = (0, directives_js_1.mergeDirectives)(field.directives, existing.directives, config);
                existing.description = field.description || existing.description;
            } else {
                result.push(field);
            }
        }
    }
    if (config && config.sort) {
        result.sort(utils_1.compareNodes);
    }
    if (config && config.exclusions) {
        const exclusions = config.exclusions;
        return result.filter((field)=>!exclusions.includes(`${type.name.value}.${field.name.value}`));
    }
    return result;
}
exports.mergeFields = mergeFields;
function preventConflicts(type, a, b, ignoreNullability = false) {
    const aType = (0, utils_js_1.printTypeNode)(a.type);
    const bType = (0, utils_js_1.printTypeNode)(b.type);
    if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {
        throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
    }
}
function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
    // both are named
    if (!(0, utils_js_1.isWrappingTypeNode)(oldType) && !(0, utils_js_1.isWrappingTypeNode)(newType)) {
        return oldType.toString() === newType.toString();
    }
    // new is non-null
    if ((0, utils_js_1.isNonNullTypeNode)(newType)) {
        const ofType = (0, utils_js_1.isNonNullTypeNode)(oldType) ? oldType.type : oldType;
        return safeChangeForFieldType(ofType, newType.type);
    }
    // old is non-null
    if ((0, utils_js_1.isNonNullTypeNode)(oldType)) {
        return safeChangeForFieldType(newType, oldType, ignoreNullability);
    }
    // old is list
    if ((0, utils_js_1.isListTypeNode)(oldType)) {
        return (0, utils_js_1.isListTypeNode)(newType) && safeChangeForFieldType(oldType.type, newType.type) || (0, utils_js_1.isNonNullTypeNode)(newType) && safeChangeForFieldType(oldType, newType['type']);
    }
    return false;
}
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeInputType = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const fields_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
function mergeInputType(node, existingNode, config) {
    if (existingNode) {
        try {
            return {
                name: node.name,
                description: node['description'] || existingNode['description'],
                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'InputObjectTypeDefinition' || existingNode.kind === 'InputObjectTypeDefinition' ? 'InputObjectTypeDefinition' : 'InputObjectTypeExtension',
                loc: node.loc,
                fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
                directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config)
            };
        } catch (e) {
            throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
        }
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION
    } : node;
}
exports.mergeInputType = mergeInputType;
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeInterface = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const fields_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
const index_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js [app-route] (ecmascript)");
function mergeInterface(node, existingNode, config) {
    if (existingNode) {
        try {
            return {
                name: node.name,
                description: node['description'] || existingNode['description'],
                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'InterfaceTypeDefinition' || existingNode.kind === 'InterfaceTypeDefinition' ? 'InterfaceTypeDefinition' : 'InterfaceTypeExtension',
                loc: node.loc,
                fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
                directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config),
                interfaces: node['interfaces'] ? (0, index_js_1.mergeNamedTypeArray)(node['interfaces'], existingNode['interfaces'], config) : undefined
            };
        } catch (e) {
            throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
        }
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION
    } : node;
}
exports.mergeInterface = mergeInterface;
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeNamedTypeArray = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
function alreadyExists(arr, other) {
    return !!arr.find((i)=>i.name.value === other.name.value);
}
function mergeNamedTypeArray(first = [], second = [], config = {}) {
    const result = [
        ...second,
        ...first.filter((d)=>!alreadyExists(second, d))
    ];
    if (config && config.sort) {
        result.sort(utils_1.compareNodes);
    }
    return result;
}
exports.mergeNamedTypeArray = mergeNamedTypeArray;
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeType = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const fields_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
const merge_named_type_array_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js [app-route] (ecmascript)");
function mergeType(node, existingNode, config) {
    if (existingNode) {
        try {
            return {
                name: node.name,
                description: node['description'] || existingNode['description'],
                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'ObjectTypeDefinition' || existingNode.kind === 'ObjectTypeDefinition' ? 'ObjectTypeDefinition' : 'ObjectTypeExtension',
                loc: node.loc,
                fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
                directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config),
                interfaces: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node.interfaces, existingNode.interfaces, config)
            };
        } catch (e) {
            throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
        }
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION
    } : node;
}
exports.mergeType = mergeType;
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeScalar = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
function mergeScalar(node, existingNode, config) {
    if (existingNode) {
        return {
            name: node.name,
            description: node['description'] || existingNode['description'],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === 'ScalarTypeDefinition' || existingNode.kind === 'ScalarTypeDefinition' ? 'ScalarTypeDefinition' : 'ScalarTypeExtension',
            loc: node.loc,
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config)
        };
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION
    } : node;
}
exports.mergeScalar = mergeScalar;
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeUnion = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
const merge_named_type_array_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js [app-route] (ecmascript)");
function mergeUnion(first, second, config) {
    if (second) {
        return {
            name: first.name,
            description: first['description'] || second['description'],
            // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
            directives: (0, directives_js_1.mergeDirectives)(first.directives, second.directives, config),
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || first.kind === 'UnionTypeDefinition' || second.kind === 'UnionTypeDefinition' ? graphql_1.Kind.UNION_TYPE_DEFINITION : graphql_1.Kind.UNION_TYPE_EXTENSION,
            loc: first.loc,
            types: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(first.types, second.types, config)
        };
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...first,
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION
    } : first;
}
exports.mergeUnion = mergeUnion;
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeSchemaDefs = exports.DEFAULT_OPERATION_TYPE_NAME_MAP = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
exports.DEFAULT_OPERATION_TYPE_NAME_MAP = {
    query: 'Query',
    mutation: 'Mutation',
    subscription: 'Subscription'
};
function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
    const finalOpNodeList = [];
    for(const opNodeType in exports.DEFAULT_OPERATION_TYPE_NAME_MAP){
        const opNode = opNodeList.find((n)=>n.operation === opNodeType) || existingOpNodeList.find((n)=>n.operation === opNodeType);
        if (opNode) {
            finalOpNodeList.push(opNode);
        }
    }
    return finalOpNodeList;
}
function mergeSchemaDefs(node, existingNode, config) {
    if (existingNode) {
        return {
            kind: node.kind === graphql_1.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql_1.Kind.SCHEMA_DEFINITION ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
            description: node['description'] || existingNode['description'],
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config),
            operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
        };
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCHEMA_DEFINITION
    } : node;
}
exports.mergeSchemaDefs = mergeSchemaDefs;
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeGraphQLNodes = exports.isNamedDefinitionNode = exports.schemaDefSymbol = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js [app-route] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js [app-route] (ecmascript)");
const scalar_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js [app-route] (ecmascript)");
const union_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js [app-route] (ecmascript)");
const input_type_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js [app-route] (ecmascript)");
const interface_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js [app-route] (ecmascript)");
const directives_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)");
const schema_def_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
exports.schemaDefSymbol = 'SCHEMA_DEF_SYMBOL';
function isNamedDefinitionNode(definitionNode) {
    return 'name' in definitionNode;
}
exports.isNamedDefinitionNode = isNamedDefinitionNode;
function mergeGraphQLNodes(nodes, config) {
    var _a, _b, _c;
    const mergedResultMap = {};
    for (const nodeDefinition of nodes){
        if (isNamedDefinitionNode(nodeDefinition)) {
            const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;
            if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
                (0, utils_1.collectComment)(nodeDefinition);
            }
            if (name == null) {
                continue;
            }
            if (((_b = config === null || config === void 0 ? void 0 : config.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + '.*')) || ((_c = config === null || config === void 0 ? void 0 : config.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {
                delete mergedResultMap[name];
            } else {
                switch(nodeDefinition.kind){
                    case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
                    case graphql_1.Kind.OBJECT_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, type_js_1.mergeType)(nodeDefinition, mergedResultMap[name], config);
                        break;
                    case graphql_1.Kind.ENUM_TYPE_DEFINITION:
                    case graphql_1.Kind.ENUM_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, enum_js_1.mergeEnum)(nodeDefinition, mergedResultMap[name], config);
                        break;
                    case graphql_1.Kind.UNION_TYPE_DEFINITION:
                    case graphql_1.Kind.UNION_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, union_js_1.mergeUnion)(nodeDefinition, mergedResultMap[name], config);
                        break;
                    case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
                    case graphql_1.Kind.SCALAR_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, scalar_js_1.mergeScalar)(nodeDefinition, mergedResultMap[name], config);
                        break;
                    case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
                    case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, input_type_js_1.mergeInputType)(nodeDefinition, mergedResultMap[name], config);
                        break;
                    case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
                    case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, interface_js_1.mergeInterface)(nodeDefinition, mergedResultMap[name], config);
                        break;
                    case graphql_1.Kind.DIRECTIVE_DEFINITION:
                        mergedResultMap[name] = (0, directives_js_1.mergeDirective)(nodeDefinition, mergedResultMap[name]);
                        break;
                }
            }
        } else if (nodeDefinition.kind === graphql_1.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
            mergedResultMap[exports.schemaDefSymbol] = (0, schema_def_js_1.mergeSchemaDefs)(nodeDefinition, mergedResultMap[exports.schemaDefSymbol], config);
        }
    }
    return mergedResultMap;
}
exports.mergeGraphQLNodes = mergeGraphQLNodes;
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeGraphQLTypes = exports.mergeTypeDefs = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js [app-route] (ecmascript)");
const merge_nodes_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
const schema_def_js_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js [app-route] (ecmascript)");
function mergeTypeDefs(typeSource, config) {
    (0, utils_1.resetComments)();
    const doc = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: mergeGraphQLTypes(typeSource, {
            useSchemaDefinition: true,
            forceSchemaDefinition: false,
            throwOnConflict: false,
            commentDescriptions: false,
            ...config
        })
    };
    let result;
    if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
        result = (0, utils_1.printWithComments)(doc);
    } else {
        result = doc;
    }
    (0, utils_1.resetComments)();
    return result;
}
exports.mergeTypeDefs = mergeTypeDefs;
function visitTypeSources(typeSource, options, allNodes = [], visitedTypeSources = new Set()) {
    if (typeSource && !visitedTypeSources.has(typeSource)) {
        visitedTypeSources.add(typeSource);
        if (typeof typeSource === 'function') {
            visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);
        } else if (Array.isArray(typeSource)) {
            for (const type of typeSource){
                visitTypeSources(type, options, allNodes, visitedTypeSources);
            }
        } else if ((0, graphql_1.isSchema)(typeSource)) {
            const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);
            visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
        } else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {
            const documentNode = (0, graphql_1.parse)(typeSource, options);
            visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
        } else if (typeof typeSource === 'object' && (0, graphql_1.isDefinitionNode)(typeSource)) {
            allNodes.push(typeSource);
        } else if ((0, utils_1.isDocumentNode)(typeSource)) {
            visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);
        } else {
            throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
        }
    }
    return allNodes;
}
function mergeGraphQLTypes(typeSource, config) {
    var _a, _b, _c;
    (0, utils_1.resetComments)();
    const allNodes = visitTypeSources(typeSource, config);
    const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config);
    if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {
        // XXX: right now we don't handle multiple schema definitions
        const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {
            kind: graphql_1.Kind.SCHEMA_DEFINITION,
            operationTypes: []
        };
        const operationTypes = schemaDef.operationTypes;
        for(const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP){
            const opTypeDefNode = operationTypes.find((operationType)=>operationType.operation === opTypeDefNodeType);
            if (!opTypeDefNode) {
                const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
                const existingPossibleRootType = mergedNodes[possibleRootTypeName];
                if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
                    operationTypes.push({
                        kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                        type: {
                            kind: graphql_1.Kind.NAMED_TYPE,
                            name: existingPossibleRootType.name
                        },
                        operation: opTypeDefNodeType
                    });
                }
            }
        }
        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {
            mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;
        }
    }
    if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {
        mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {
            kind: graphql_1.Kind.SCHEMA_DEFINITION,
            operationTypes: [
                {
                    kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                    operation: 'query',
                    type: {
                        kind: graphql_1.Kind.NAMED_TYPE,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: 'Query'
                        }
                    }
                }
            ]
        };
    }
    const mergedNodeDefinitions = Object.values(mergedNodes);
    if (config === null || config === void 0 ? void 0 : config.sort) {
        const sortFn = typeof config.sort === 'function' ? config.sort : utils_js_1.defaultStringComparator;
        mergedNodeDefinitions.sort((a, b)=>{
            var _a, _b;
            return sortFn((_a = a.name) === null || _a === void 0 ? void 0 : _a.value, (_b = b.name) === null || _b === void 0 ? void 0 : _b.value);
        });
    }
    return mergedNodeDefinitions;
}
exports.mergeGraphQLTypes = mergeGraphQLTypes;
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js [app-route] (ecmascript)"), exports);
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/extensions.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extractExtensionsFromSchema = exports.applyExtensions = exports.mergeExtensions = exports.travelSchemaPossibleExtensions = void 0;
const graphql_1 = __turbopack_context__.r("[project]/node_modules/graphql/index.mjs [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/index.js [app-route] (ecmascript)");
function travelSchemaPossibleExtensions(schema, hooks) {
    hooks.onSchema(schema);
    const typesMap = schema.getTypeMap();
    for (const [, type] of Object.entries(typesMap)){
        const isPredefinedScalar = (0, graphql_1.isScalarType)(type) && (0, graphql_1.isSpecifiedScalarType)(type);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type);
        if (isPredefinedScalar || isIntrospection) {
            continue;
        }
        if ((0, graphql_1.isObjectType)(type)) {
            hooks.onObjectType(type);
            const fields = type.getFields();
            for (const [, field] of Object.entries(fields)){
                hooks.onObjectField(type, field);
                const args = field.args || [];
                for (const arg of args){
                    hooks.onObjectFieldArg(type, field, arg);
                }
            }
        } else if ((0, graphql_1.isInterfaceType)(type)) {
            hooks.onInterface(type);
            const fields = type.getFields();
            for (const [, field] of Object.entries(fields)){
                hooks.onInterfaceField(type, field);
                const args = field.args || [];
                for (const arg of args){
                    hooks.onInterfaceFieldArg(type, field, arg);
                }
            }
        } else if ((0, graphql_1.isInputObjectType)(type)) {
            hooks.onInputType(type);
            const fields = type.getFields();
            for (const [, field] of Object.entries(fields)){
                hooks.onInputFieldType(type, field);
            }
        } else if ((0, graphql_1.isUnionType)(type)) {
            hooks.onUnion(type);
        } else if ((0, graphql_1.isScalarType)(type)) {
            hooks.onScalar(type);
        } else if ((0, graphql_1.isEnumType)(type)) {
            hooks.onEnum(type);
            for (const value of type.getValues()){
                hooks.onEnumValue(type, value);
            }
        }
    }
}
exports.travelSchemaPossibleExtensions = travelSchemaPossibleExtensions;
function mergeExtensions(extensions) {
    return (0, utils_1.mergeDeep)(extensions);
}
exports.mergeExtensions = mergeExtensions;
function applyExtensionObject(obj, extensions) {
    if (!obj) {
        return;
    }
    obj.extensions = (0, utils_1.mergeDeep)([
        obj.extensions || {},
        extensions || {}
    ]);
}
function applyExtensions(schema, extensions) {
    applyExtensionObject(schema, extensions.schemaExtensions);
    for (const [typeName, data] of Object.entries(extensions.types || {})){
        const type = schema.getType(typeName);
        if (type) {
            applyExtensionObject(type, data.extensions);
            if (data.type === 'object' || data.type === 'interface') {
                for (const [fieldName, fieldData] of Object.entries(data.fields)){
                    const field = type.getFields()[fieldName];
                    if (field) {
                        applyExtensionObject(field, fieldData.extensions);
                        for (const [arg, argData] of Object.entries(fieldData.arguments)){
                            applyExtensionObject(field.args.find((a)=>a.name === arg), argData);
                        }
                    }
                }
            } else if (data.type === 'input') {
                for (const [fieldName, fieldData] of Object.entries(data.fields)){
                    const field = type.getFields()[fieldName];
                    applyExtensionObject(field, fieldData.extensions);
                }
            } else if (data.type === 'enum') {
                for (const [valueName, valueData] of Object.entries(data.values)){
                    const value = type.getValue(valueName);
                    applyExtensionObject(value, valueData);
                }
            }
        }
    }
    return schema;
}
exports.applyExtensions = applyExtensions;
function extractExtensionsFromSchema(schema) {
    const result = {
        schemaExtensions: {},
        types: {}
    };
    travelSchemaPossibleExtensions(schema, {
        onSchema: (schema)=>result.schemaExtensions = schema.extensions || {},
        onObjectType: (type)=>result.types[type.name] = {
                fields: {},
                type: 'object',
                extensions: type.extensions || {}
            },
        onObjectField: (type, field)=>result.types[type.name].fields[field.name] = {
                arguments: {},
                extensions: field.extensions || {}
            },
        onObjectFieldArg: (type, field, arg)=>result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},
        onInterface: (type)=>result.types[type.name] = {
                fields: {},
                type: 'interface',
                extensions: type.extensions || {}
            },
        onInterfaceField: (type, field)=>result.types[type.name].fields[field.name] = {
                arguments: {},
                extensions: field.extensions || {}
            },
        onInterfaceFieldArg: (type, field, arg)=>result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {},
        onEnum: (type)=>result.types[type.name] = {
                values: {},
                type: 'enum',
                extensions: type.extensions || {}
            },
        onEnumValue: (type, value)=>result.types[type.name].values[value.name] = value.extensions || {},
        onScalar: (type)=>result.types[type.name] = {
                type: 'scalar',
                extensions: type.extensions || {}
            },
        onUnion: (type)=>result.types[type.name] = {
                type: 'union',
                extensions: type.extensions || {}
            },
        onInputType: (type)=>result.types[type.name] = {
                fields: {},
                type: 'input',
                extensions: type.extensions || {}
            },
        onInputFieldType: (type, field)=>result.types[type.name].fields[field.name] = {
                extensions: field.extensions || {}
            }
    });
    return result;
}
exports.extractExtensionsFromSchema = extractExtensionsFromSchema;
}}),
"[project]/node_modules/@graphql-tools/merge/cjs/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/merge-resolvers.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@graphql-tools/merge/cjs/extensions.js [app-route] (ecmascript)"), exports);
}}),

};

//# sourceMappingURL=node_modules_%40graphql-tools_7a158a82._.js.map