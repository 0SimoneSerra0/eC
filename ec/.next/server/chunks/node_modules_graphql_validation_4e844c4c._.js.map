{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isExecutableDefinitionNode } from '../../language/predicates.mjs';\n\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n *\n * See https://spec.graphql.org/draft/#sec-Executable-Definitions\n */\nexport function ExecutableDefinitionsRule(context) {\n  return {\n    Document(node) {\n      for (const definition of node.definitions) {\n        if (!isExecutableDefinitionNode(definition)) {\n          const defName =\n            definition.kind === Kind.SCHEMA_DEFINITION ||\n            definition.kind === Kind.SCHEMA_EXTENSION\n              ? 'schema'\n              : '\"' + definition.name.value + '\"';\n          context.reportError(\n            new GraphQLError(`The ${defName} definition is not executable.`, {\n              nodes: definition,\n            }),\n          );\n        }\n      }\n\n      return false;\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAUO,SAAS,0BAA0B,OAAO;IAC/C,OAAO;QACL,UAAS,IAAI;YACX,KAAK,MAAM,cAAc,KAAK,WAAW,CAAE;gBACzC,IAAI,CAAC,CAAA,GAAA,oJAAA,CAAA,6BAA0B,AAAD,EAAE,aAAa;oBAC3C,MAAM,UACJ,WAAW,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,iBAAiB,IAC1C,WAAW,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,gBAAgB,GACrC,WACA,MAAM,WAAW,IAAI,CAAC,KAAK,GAAG;oBACpC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CAAC,CAAC,IAAI,EAAE,QAAQ,8BAA8B,CAAC,EAAE;wBAC/D,OAAO;oBACT;gBAEJ;YACF;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs"],"sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { naturalCompare } from '../../jsutils/naturalCompare.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isAbstractType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selections\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field(node) {\n      const type = context.getParentType();\n\n      if (type) {\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          const schema = context.getSchema();\n          const fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          let suggestion = didYouMean(\n            'to use an inline fragment on',\n            getSuggestedTypeNames(schema, type, fieldName),\n          ); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n          context.reportError(\n            new GraphQLError(\n              `Cannot query field \"${fieldName}\" on type \"${type.name}\".` +\n                suggestion,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  const suggestedTypes = new Set();\n  const usageCount = Object.create(null);\n\n  for (const possibleType of schema.getPossibleTypes(type)) {\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (const possibleInterface of possibleType.getInterfaces()) {\n      var _usageCount$possibleI;\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] =\n        ((_usageCount$possibleI = usageCount[possibleInterface.name]) !==\n          null && _usageCount$possibleI !== void 0\n          ? _usageCount$possibleI\n          : 0) + 1;\n    }\n  }\n\n  return [...suggestedTypes]\n    .sort((typeA, typeB) => {\n      // Suggest both interface and object types based on how common they are.\n      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n      if (usageCountDiff !== 0) {\n        return usageCountDiff;\n      } // Suggest super types first followed by subtypes\n\n      if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n        return -1;\n      }\n\n      if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n        return 1;\n      }\n\n      return naturalCompare(typeA.name, typeB.name);\n    })\n    .map((x) => x.name);\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    const possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n  return [];\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 125, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isCompositeType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-On-Composite-Types\n */\nexport function FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment(node) {\n      const typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        const type = typeFromAST(context.getSchema(), typeCondition);\n\n        if (type && !isCompositeType(type)) {\n          const typeStr = print(typeCondition);\n          context.reportError(\n            new GraphQLError(\n              `Fragment cannot condition on non composite type \"${typeStr}\".`,\n              {\n                nodes: typeCondition,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    FragmentDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.typeCondition);\n\n      if (type && !isCompositeType(type)) {\n        const typeStr = print(node.typeCondition);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${node.name.value}\" cannot condition on non composite type \"${typeStr}\".`,\n            {\n              nodes: node.typeCondition,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AAWO,SAAS,8BAA8B,OAAO;IACnD,OAAO;QACL,gBAAe,IAAI;YACjB,MAAM,gBAAgB,KAAK,aAAa;YAExC,IAAI,eAAe;gBACjB,MAAM,OAAO,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,SAAS,IAAI;gBAE9C,IAAI,QAAQ,CAAC,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD,EAAE,OAAO;oBAClC,MAAM,UAAU,CAAA,GAAA,iJAAA,CAAA,QAAK,AAAD,EAAE;oBACtB,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,iDAAiD,EAAE,QAAQ,EAAE,CAAC,EAC/D;wBACE,OAAO;oBACT;gBAGN;YACF;QACF;QAEA,oBAAmB,IAAI;YACrB,MAAM,OAAO,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,SAAS,IAAI,KAAK,aAAa;YAEhE,IAAI,QAAQ,CAAC,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD,EAAE,OAAO;gBAClC,MAAM,UAAU,CAAA,GAAA,iJAAA,CAAA,QAAK,AAAD,EAAE,KAAK,aAAa;gBACxC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,UAAU,EAAE,KAAK,IAAI,CAAC,KAAK,CAAC,0CAA0C,EAAE,QAAQ,EAAE,CAAC,EACpF;oBACE,OAAO,KAAK,aAAa;gBAC3B;YAGN;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs"],"sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n * See https://spec.graphql.org/draft/#sec-Directives-Are-In-Valid-Locations\n */\nexport function KnownArgumentNamesRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...KnownArgumentNamesOnDirectivesRule(context),\n\n    Argument(argNode) {\n      const argDef = context.getArgument();\n      const fieldDef = context.getFieldDef();\n      const parentType = context.getParentType();\n\n      if (!argDef && fieldDef && parentType) {\n        const argName = argNode.name.value;\n        const knownArgsNames = fieldDef.args.map((arg) => arg.name);\n        const suggestions = suggestionList(argName, knownArgsNames);\n        context.reportError(\n          new GraphQLError(\n            `Unknown argument \"${argName}\" on field \"${parentType.name}.${fieldDef.name}\".` +\n              didYouMean(suggestions),\n            {\n              nodes: argNode,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n/**\n * @internal\n */\n\nexport function KnownArgumentNamesOnDirectivesRule(context) {\n  const directiveArgs = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argsNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);\n    }\n  }\n\n  return {\n    Directive(directiveNode) {\n      const directiveName = directiveNode.name.value;\n      const knownArgs = directiveArgs[directiveName];\n\n      if (directiveNode.arguments && knownArgs) {\n        for (const argNode of directiveNode.arguments) {\n          const argName = argNode.name.value;\n\n          if (!knownArgs.includes(argName)) {\n            const suggestions = suggestionList(argName, knownArgs);\n            context.reportError(\n              new GraphQLError(\n                `Unknown argument \"${argName}\" on directive \"@${directiveName}\".` +\n                  didYouMean(suggestions),\n                {\n                  nodes: argNode,\n                },\n              ),\n            );\n          }\n        }\n      }\n\n      return false;\n    },\n  };\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAWO,SAAS,uBAAuB,OAAO;IAC5C,OAAO;QACL,mCAAmC;QACnC,GAAG,mCAAmC,QAAQ;QAE9C,UAAS,OAAO;YACd,MAAM,SAAS,QAAQ,WAAW;YAClC,MAAM,WAAW,QAAQ,WAAW;YACpC,MAAM,aAAa,QAAQ,aAAa;YAExC,IAAI,CAAC,UAAU,YAAY,YAAY;gBACrC,MAAM,UAAU,QAAQ,IAAI,CAAC,KAAK;gBAClC,MAAM,iBAAiB,SAAS,IAAI,CAAC,GAAG,CAAC,CAAC,MAAQ,IAAI,IAAI;gBAC1D,MAAM,cAAc,CAAA,GAAA,uJAAA,CAAA,iBAAc,AAAD,EAAE,SAAS;gBAC5C,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,kBAAkB,EAAE,QAAQ,YAAY,EAAE,WAAW,IAAI,CAAC,CAAC,EAAE,SAAS,IAAI,CAAC,EAAE,CAAC,GAC7E,CAAA,GAAA,mJAAA,CAAA,aAAU,AAAD,EAAE,cACb;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF;AAKO,SAAS,mCAAmC,OAAO;IACxD,MAAM,gBAAgB,OAAO,MAAM,CAAC;IACpC,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,oBAAoB,SACtB,OAAO,aAAa,KACpB,gJAAA,CAAA,sBAAmB;IAEvB,KAAK,MAAM,aAAa,kBAAmB;QACzC,aAAa,CAAC,UAAU,IAAI,CAAC,GAAG,UAAU,IAAI,CAAC,GAAG,CAAC,CAAC,MAAQ,IAAI,IAAI;IACtE;IAEA,MAAM,iBAAiB,QAAQ,WAAW,GAAG,WAAW;IAExD,KAAK,MAAM,OAAO,eAAgB;QAChC,IAAI,IAAI,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,oBAAoB,EAAE;YAC1C,IAAI;YAEJ,2DAA2D;YAE3D,kBAAkB,GAClB,MAAM,YACJ,CAAC,iBAAiB,IAAI,SAAS,MAAM,QAAQ,mBAAmB,KAAK,IACjE,iBACA,EAAE;YACR,aAAa,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,MAAQ,IAAI,IAAI,CAAC,KAAK;QACvE;IACF;IAEA,OAAO;QACL,WAAU,aAAa;YACrB,MAAM,gBAAgB,cAAc,IAAI,CAAC,KAAK;YAC9C,MAAM,YAAY,aAAa,CAAC,cAAc;YAE9C,IAAI,cAAc,SAAS,IAAI,WAAW;gBACxC,KAAK,MAAM,WAAW,cAAc,SAAS,CAAE;oBAC7C,MAAM,UAAU,QAAQ,IAAI,CAAC,KAAK;oBAElC,IAAI,CAAC,UAAU,QAAQ,CAAC,UAAU;wBAChC,MAAM,cAAc,CAAA,GAAA,uJAAA,CAAA,iBAAc,AAAD,EAAE,SAAS;wBAC5C,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,kBAAkB,EAAE,QAAQ,iBAAiB,EAAE,cAAc,EAAE,CAAC,GAC/D,CAAA,GAAA,mJAAA,CAAA,aAAU,AAAD,EAAE,cACb;4BACE,OAAO;wBACT;oBAGN;gBACF;YACF;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 237, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownDirectivesRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../../language/ast.mjs';\nimport { DirectiveLocation } from '../../language/directiveLocation.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Defined\n */\nexport function KnownDirectivesRule(context) {\n  const locationsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    locationsMap[directive.name] = directive.locations;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map((name) => name.value);\n    }\n  }\n\n  return {\n    Directive(node, _key, _parent, _path, ancestors) {\n      const name = node.name.value;\n      const locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(\n          new GraphQLError(`Unknown directive \"@${name}\".`, {\n            nodes: node,\n          }),\n        );\n        return;\n      }\n\n      const candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && !locations.includes(candidateLocation)) {\n        context.reportError(\n          new GraphQLError(\n            `Directive \"@${name}\" may not be used on ${candidateLocation}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  const appliedTo = ancestors[ancestors.length - 1];\n  'kind' in appliedTo || invariant(false);\n\n  switch (appliedTo.kind) {\n    case Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n\n    case Kind.FIELD:\n      return DirectiveLocation.FIELD;\n\n    case Kind.FRAGMENT_SPREAD:\n      return DirectiveLocation.FRAGMENT_SPREAD;\n\n    case Kind.INLINE_FRAGMENT:\n      return DirectiveLocation.INLINE_FRAGMENT;\n\n    case Kind.FRAGMENT_DEFINITION:\n      return DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case Kind.VARIABLE_DEFINITION:\n      return DirectiveLocation.VARIABLE_DEFINITION;\n\n    case Kind.SCHEMA_DEFINITION:\n    case Kind.SCHEMA_EXTENSION:\n      return DirectiveLocation.SCHEMA;\n\n    case Kind.SCALAR_TYPE_DEFINITION:\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return DirectiveLocation.SCALAR;\n\n    case Kind.OBJECT_TYPE_DEFINITION:\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.OBJECT;\n\n    case Kind.FIELD_DEFINITION:\n      return DirectiveLocation.FIELD_DEFINITION;\n\n    case Kind.INTERFACE_TYPE_DEFINITION:\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return DirectiveLocation.INTERFACE;\n\n    case Kind.UNION_TYPE_DEFINITION:\n    case Kind.UNION_TYPE_EXTENSION:\n      return DirectiveLocation.UNION;\n\n    case Kind.ENUM_TYPE_DEFINITION:\n    case Kind.ENUM_TYPE_EXTENSION:\n      return DirectiveLocation.ENUM;\n\n    case Kind.ENUM_VALUE_DEFINITION:\n      return DirectiveLocation.ENUM_VALUE;\n\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.INPUT_OBJECT;\n\n    case Kind.INPUT_VALUE_DEFINITION: {\n      const parentNode = ancestors[ancestors.length - 3];\n      'kind' in parentNode || invariant(false);\n      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION\n        ? DirectiveLocation.INPUT_FIELD_DEFINITION\n        : DirectiveLocation.ARGUMENT_DEFINITION;\n    }\n    // Not reachable, all possible types have been considered.\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(appliedTo.kind));\n  }\n}\n\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case OperationTypeNode.QUERY:\n      return DirectiveLocation.QUERY;\n\n    case OperationTypeNode.MUTATION:\n      return DirectiveLocation.MUTATION;\n\n    case OperationTypeNode.SUBSCRIPTION:\n      return DirectiveLocation.SUBSCRIPTION;\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 352, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spread-target-defined\n */\nexport function KnownFragmentNamesRule(context) {\n  return {\n    FragmentSpread(node) {\n      const fragmentName = node.name.value;\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        context.reportError(\n          new GraphQLError(`Unknown fragment \"${fragmentName}\".`, {\n            nodes: node.name,\n          }),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAUO,SAAS,uBAAuB,OAAO;IAC5C,OAAO;QACL,gBAAe,IAAI;YACjB,MAAM,eAAe,KAAK,IAAI,CAAC,KAAK;YACpC,MAAM,WAAW,QAAQ,WAAW,CAAC;YAErC,IAAI,CAAC,UAAU;gBACb,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CAAC,CAAC,kBAAkB,EAAE,aAAa,EAAE,CAAC,EAAE;oBACtD,OAAO,KAAK,IAAI;gBAClB;YAEJ;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 374, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs"],"sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeSystemDefinitionNode,\n  isTypeSystemExtensionNode,\n} from '../../language/predicates.mjs';\nimport { introspectionTypes } from '../../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../../type/scalars.mjs';\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Spread-Type-Existence\n */\nexport function KnownTypeNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  const typeNames = [\n    ...Object.keys(existingTypesMap),\n    ...Object.keys(definedTypes),\n  ];\n  return {\n    NamedType(node, _1, parent, _2, ancestors) {\n      const typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        const definitionNode =\n          (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0\n            ? _ancestors$\n            : parent;\n        const isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && standardTypeNames.includes(typeName)) {\n          return;\n        }\n\n        const suggestedTypes = suggestionList(\n          typeName,\n          isSDL ? standardTypeNames.concat(typeNames) : typeNames,\n        );\n        context.reportError(\n          new GraphQLError(\n            `Unknown type \"${typeName}\".` + didYouMean(suggestedTypes),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\nconst standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(\n  (type) => type.name,\n);\n\nfunction isSDLNode(value) {\n  return (\n    'kind' in value &&\n    (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value))\n  );\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AAKA;AACA;;;;;;;AAUO,SAAS,mBAAmB,OAAO;IACxC,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,mBAAmB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACtE,MAAM,eAAe,OAAO,MAAM,CAAC;IAEnC,KAAK,MAAM,OAAO,QAAQ,WAAW,GAAG,WAAW,CAAE;QACnD,IAAI,CAAA,GAAA,oJAAA,CAAA,uBAAoB,AAAD,EAAE,MAAM;YAC7B,YAAY,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG;QACjC;IACF;IAEA,MAAM,YAAY;WACb,OAAO,IAAI,CAAC;WACZ,OAAO,IAAI,CAAC;KAChB;IACD,OAAO;QACL,WAAU,IAAI,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,SAAS;YACvC,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;YAEhC,IAAI,CAAC,gBAAgB,CAAC,SAAS,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE;gBAC1D,IAAI;gBAEJ,MAAM,iBACJ,CAAC,cAAc,SAAS,CAAC,EAAE,MAAM,QAAQ,gBAAgB,KAAK,IAC1D,cACA;gBACN,MAAM,QAAQ,kBAAkB,QAAQ,UAAU;gBAElD,IAAI,SAAS,kBAAkB,QAAQ,CAAC,WAAW;oBACjD;gBACF;gBAEA,MAAM,iBAAiB,CAAA,GAAA,uJAAA,CAAA,iBAAc,AAAD,EAClC,UACA,QAAQ,kBAAkB,MAAM,CAAC,aAAa;gBAEhD,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,cAAc,EAAE,SAAS,EAAE,CAAC,GAAG,CAAA,GAAA,mJAAA,CAAA,aAAU,AAAD,EAAE,iBAC3C;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF;AACA,MAAM,oBAAoB;OAAI,6IAAA,CAAA,uBAAoB;OAAK,mJAAA,CAAA,qBAAkB;CAAC,CAAC,GAAG,CAC5E,CAAC,OAAS,KAAK,IAAI;AAGrB,SAAS,UAAU,KAAK;IACtB,OACE,UAAU,SACV,CAAC,CAAA,GAAA,oJAAA,CAAA,6BAA0B,AAAD,EAAE,UAAU,CAAA,GAAA,oJAAA,CAAA,4BAAyB,AAAD,EAAE,MAAM;AAE1E","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 431, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\n\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n *\n * See https://spec.graphql.org/draft/#sec-Lone-Anonymous-Operation\n */\nexport function LoneAnonymousOperationRule(context) {\n  let operationCount = 0;\n  return {\n    Document(node) {\n      operationCount = node.definitions.filter(\n        (definition) => definition.kind === Kind.OPERATION_DEFINITION,\n      ).length;\n    },\n\n    OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(\n          new GraphQLError(\n            'This anonymous operation must be the only defined operation.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAUO,SAAS,2BAA2B,OAAO;IAChD,IAAI,iBAAiB;IACrB,OAAO;QACL,UAAS,IAAI;YACX,iBAAiB,KAAK,WAAW,CAAC,MAAM,CACtC,CAAC,aAAe,WAAW,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,oBAAoB,EAC7D,MAAM;QACV;QAEA,qBAAoB,IAAI;YACtB,IAAI,CAAC,KAAK,IAAI,IAAI,iBAAiB,GAAG;gBACpC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,gEACA;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 457, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Lone Schema definition\n *\n * A GraphQL document is only valid if it contains only one schema definition.\n */\nexport function LoneSchemaDefinitionRule(context) {\n  var _ref, _ref2, _oldSchema$astNode;\n\n  const oldSchema = context.getSchema();\n  const alreadyDefined =\n    (_ref =\n      (_ref2 =\n        (_oldSchema$astNode =\n          oldSchema === null || oldSchema === void 0\n            ? void 0\n            : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0\n          ? _oldSchema$astNode\n          : oldSchema === null || oldSchema === void 0\n          ? void 0\n          : oldSchema.getQueryType()) !== null && _ref2 !== void 0\n        ? _ref2\n        : oldSchema === null || oldSchema === void 0\n        ? void 0\n        : oldSchema.getMutationType()) !== null && _ref !== void 0\n      ? _ref\n      : oldSchema === null || oldSchema === void 0\n      ? void 0\n      : oldSchema.getSubscriptionType();\n  let schemaDefinitionsCount = 0;\n  return {\n    SchemaDefinition(node) {\n      if (alreadyDefined) {\n        context.reportError(\n          new GraphQLError(\n            'Cannot define a new schema within a schema extension.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (schemaDefinitionsCount > 0) {\n        context.reportError(\n          new GraphQLError('Must provide only one schema definition.', {\n            nodes: node,\n          }),\n        );\n      }\n\n      ++schemaDefinitionsCount;\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,yBAAyB,OAAO;IAC9C,IAAI,MAAM,OAAO;IAEjB,MAAM,YAAY,QAAQ,SAAS;IACnC,MAAM,iBACJ,CAAC,OACC,CAAC,QACC,CAAC,qBACC,cAAc,QAAQ,cAAc,KAAK,IACrC,KAAK,IACL,UAAU,OAAO,MAAM,QAAQ,uBAAuB,KAAK,IAC7D,qBACA,cAAc,QAAQ,cAAc,KAAK,IACzC,KAAK,IACL,UAAU,YAAY,EAAE,MAAM,QAAQ,UAAU,KAAK,IACvD,QACA,cAAc,QAAQ,cAAc,KAAK,IACzC,KAAK,IACL,UAAU,eAAe,EAAE,MAAM,QAAQ,SAAS,KAAK,IACzD,OACA,cAAc,QAAQ,cAAc,KAAK,IACzC,KAAK,IACL,UAAU,mBAAmB;IACnC,IAAI,yBAAyB;IAC7B,OAAO;QACL,kBAAiB,IAAI;YACnB,IAAI,gBAAgB;gBAClB,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,yDACA;oBACE,OAAO;gBACT;gBAGJ;YACF;YAEA,IAAI,yBAAyB,GAAG;gBAC9B,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CAAC,4CAA4C;oBAC3D,OAAO;gBACT;YAEJ;YAEA,EAAE;QACJ;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 488, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nconst MAX_LISTS_DEPTH = 3;\nexport function MaxIntrospectionDepthRule(context) {\n  /**\n   * Counts the depth of list fields in \"__Type\" recursively and\n   * returns `true` if the limit has been reached.\n   */\n  function checkDepth(node, visitedFragments = Object.create(null), depth = 0) {\n    if (node.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = node.name.value;\n\n      if (visitedFragments[fragmentName] === true) {\n        // Fragment cycles are handled by `NoFragmentCyclesRule`.\n        return false;\n      }\n\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        // Missing fragments checks are handled by `KnownFragmentNamesRule`.\n        return false;\n      } // Rather than following an immutable programming pattern which has\n      // significant memory and garbage collection overhead, we've opted to\n      // take a mutable approach for efficiency's sake. Importantly visiting a\n      // fragment twice is fine, so long as you don't do one visit inside the\n      // other.\n\n      try {\n        visitedFragments[fragmentName] = true;\n        return checkDepth(fragment, visitedFragments, depth);\n      } finally {\n        visitedFragments[fragmentName] = undefined;\n      }\n    }\n\n    if (\n      node.kind === Kind.FIELD && // check all introspection lists\n      (node.name.value === 'fields' ||\n        node.name.value === 'interfaces' ||\n        node.name.value === 'possibleTypes' ||\n        node.name.value === 'inputFields')\n    ) {\n      // eslint-disable-next-line no-param-reassign\n      depth++;\n\n      if (depth >= MAX_LISTS_DEPTH) {\n        return true;\n      }\n    } // handles fields and inline fragments\n\n    if ('selectionSet' in node && node.selectionSet) {\n      for (const child of node.selectionSet.selections) {\n        if (checkDepth(child, visitedFragments, depth)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return {\n    Field(node) {\n      if (node.name.value === '__schema' || node.name.value === '__type') {\n        if (checkDepth(node)) {\n          context.reportError(\n            new GraphQLError('Maximum introspection depth exceeded', {\n              nodes: [node],\n            }),\n          );\n          return false;\n        }\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,MAAM,kBAAkB;AACjB,SAAS,0BAA0B,OAAO;IAC/C;;;GAGC,GACD,SAAS,WAAW,IAAI,EAAE,mBAAmB,OAAO,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC;QACzE,IAAI,KAAK,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,eAAe,EAAE;YACtC,MAAM,eAAe,KAAK,IAAI,CAAC,KAAK;YAEpC,IAAI,gBAAgB,CAAC,aAAa,KAAK,MAAM;gBAC3C,yDAAyD;gBACzD,OAAO;YACT;YAEA,MAAM,WAAW,QAAQ,WAAW,CAAC;YAErC,IAAI,CAAC,UAAU;gBACb,oEAAoE;gBACpE,OAAO;YACT,EAAE,mEAAmE;YACrE,qEAAqE;YACrE,wEAAwE;YACxE,uEAAuE;YACvE,SAAS;YAET,IAAI;gBACF,gBAAgB,CAAC,aAAa,GAAG;gBACjC,OAAO,WAAW,UAAU,kBAAkB;YAChD,SAAU;gBACR,gBAAgB,CAAC,aAAa,GAAG;YACnC;QACF;QAEA,IACE,KAAK,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,KAAK,IAAI,gCAAgC;QAC5D,CAAC,KAAK,IAAI,CAAC,KAAK,KAAK,YACnB,KAAK,IAAI,CAAC,KAAK,KAAK,gBACpB,KAAK,IAAI,CAAC,KAAK,KAAK,mBACpB,KAAK,IAAI,CAAC,KAAK,KAAK,aAAa,GACnC;YACA,6CAA6C;YAC7C;YAEA,IAAI,SAAS,iBAAiB;gBAC5B,OAAO;YACT;QACF,EAAE,sCAAsC;QAExC,IAAI,kBAAkB,QAAQ,KAAK,YAAY,EAAE;YAC/C,KAAK,MAAM,SAAS,KAAK,YAAY,CAAC,UAAU,CAAE;gBAChD,IAAI,WAAW,OAAO,kBAAkB,QAAQ;oBAC9C,OAAO;gBACT;YACF;QACF;QAEA,OAAO;IACT;IAEA,OAAO;QACL,OAAM,IAAI;YACR,IAAI,KAAK,IAAI,CAAC,KAAK,KAAK,cAAc,KAAK,IAAI,CAAC,KAAK,KAAK,UAAU;gBAClE,IAAI,WAAW,OAAO;oBACpB,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CAAC,wCAAwC;wBACvD,OAAO;4BAAC;yBAAK;oBACf;oBAEF,OAAO;gBACT;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 559, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No fragment cycles\n *\n * The graph of fragment spreads must not form any cycles including spreading itself.\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\n */\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  const spreadPath = []; // Position in the spread path\n\n  const spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    },\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    const fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (const spreadNode of spreadNodes) {\n      const spreadName = spreadNode.name.value;\n      const cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        const spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        const cyclePath = spreadPath.slice(cycleIndex);\n        const viaPath = cyclePath\n          .slice(0, -1)\n          .map((s) => '\"' + s.name.value + '\"')\n          .join(', ');\n        context.reportError(\n          new GraphQLError(\n            `Cannot spread fragment \"${spreadName}\" within itself` +\n              (viaPath !== '' ? ` via ${viaPath}.` : '.'),\n            {\n              nodes: cyclePath,\n            },\n          ),\n        );\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n"],"names":[],"mappings":";;;AAAA;;AAUO,SAAS,qBAAqB,OAAO;IAC1C,8EAA8E;IAC9E,gCAAgC;IAChC,MAAM,eAAe,OAAO,MAAM,CAAC,OAAO,uDAAuD;IAEjG,MAAM,aAAa,EAAE,EAAE,8BAA8B;IAErD,MAAM,wBAAwB,OAAO,MAAM,CAAC;IAC5C,OAAO;QACL,qBAAqB,IAAM;QAE3B,oBAAmB,IAAI;YACrB,qBAAqB;YACrB,OAAO;QACT;IACF,GAAG,mDAAmD;;;IACtD,wEAAwE;IACxE,yCAAyC;IAEzC,SAAS,qBAAqB,QAAQ;QACpC,IAAI,YAAY,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,EAAE;YACrC;QACF;QAEA,MAAM,eAAe,SAAS,IAAI,CAAC,KAAK;QACxC,YAAY,CAAC,aAAa,GAAG;QAC7B,MAAM,cAAc,QAAQ,kBAAkB,CAAC,SAAS,YAAY;QAEpE,IAAI,YAAY,MAAM,KAAK,GAAG;YAC5B;QACF;QAEA,qBAAqB,CAAC,aAAa,GAAG,WAAW,MAAM;QAEvD,KAAK,MAAM,cAAc,YAAa;YACpC,MAAM,aAAa,WAAW,IAAI,CAAC,KAAK;YACxC,MAAM,aAAa,qBAAqB,CAAC,WAAW;YACpD,WAAW,IAAI,CAAC;YAEhB,IAAI,eAAe,WAAW;gBAC5B,MAAM,iBAAiB,QAAQ,WAAW,CAAC;gBAE3C,IAAI,gBAAgB;oBAClB,qBAAqB;gBACvB;YACF,OAAO;gBACL,MAAM,YAAY,WAAW,KAAK,CAAC;gBACnC,MAAM,UAAU,UACb,KAAK,CAAC,GAAG,CAAC,GACV,GAAG,CAAC,CAAC,IAAM,MAAM,EAAE,IAAI,CAAC,KAAK,GAAG,KAChC,IAAI,CAAC;gBACR,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,wBAAwB,EAAE,WAAW,eAAe,CAAC,GACpD,CAAC,YAAY,KAAK,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,GAAG,GAAG,GAC5C;oBACE,OAAO;gBACT;YAGN;YAEA,WAAW,GAAG;QAChB;QAEA,qBAAqB,CAAC,aAAa,GAAG;IACxC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 617, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Uses-Defined\n */\nexport function NoUndefinedVariablesRule(context) {\n  let variableNameDefined = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        variableNameDefined = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          const varName = node.name.value;\n\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(\n              new GraphQLError(\n                operation.name\n                  ? `Variable \"$${varName}\" is not defined by operation \"${operation.name.value}\".`\n                  : `Variable \"$${varName}\" is not defined.`,\n                {\n                  nodes: [node, operation],\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAUO,SAAS,yBAAyB,OAAO;IAC9C,IAAI,sBAAsB,OAAO,MAAM,CAAC;IACxC,OAAO;QACL,qBAAqB;YACnB;gBACE,sBAAsB,OAAO,MAAM,CAAC;YACtC;YAEA,OAAM,SAAS;gBACb,MAAM,SAAS,QAAQ,0BAA0B,CAAC;gBAElD,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,OAAQ;oBAC7B,MAAM,UAAU,KAAK,IAAI,CAAC,KAAK;oBAE/B,IAAI,mBAAmB,CAAC,QAAQ,KAAK,MAAM;wBACzC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,UAAU,IAAI,GACV,CAAC,WAAW,EAAE,QAAQ,+BAA+B,EAAE,UAAU,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAC/E,CAAC,WAAW,EAAE,QAAQ,iBAAiB,CAAC,EAC5C;4BACE,OAAO;gCAAC;gCAAM;6BAAU;wBAC1B;oBAGN;gBACF;YACF;QACF;QAEA,oBAAmB,IAAI;YACrB,mBAAmB,CAAC,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG;QAClD;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 653, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-Must-Be-Used\n */\nexport function NoUnusedFragmentsRule(context) {\n  const operationDefs = [];\n  const fragmentDefs = [];\n  return {\n    OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n\n    FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n\n    Document: {\n      leave() {\n        const fragmentNameUsed = Object.create(null);\n\n        for (const operation of operationDefs) {\n          for (const fragment of context.getRecursivelyReferencedFragments(\n            operation,\n          )) {\n            fragmentNameUsed[fragment.name.value] = true;\n          }\n        }\n\n        for (const fragmentDef of fragmentDefs) {\n          const fragName = fragmentDef.name.value;\n\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(\n              new GraphQLError(`Fragment \"${fragName}\" is never used.`, {\n                nodes: fragmentDef,\n              }),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAUO,SAAS,sBAAsB,OAAO;IAC3C,MAAM,gBAAgB,EAAE;IACxB,MAAM,eAAe,EAAE;IACvB,OAAO;QACL,qBAAoB,IAAI;YACtB,cAAc,IAAI,CAAC;YACnB,OAAO;QACT;QAEA,oBAAmB,IAAI;YACrB,aAAa,IAAI,CAAC;YAClB,OAAO;QACT;QAEA,UAAU;YACR;gBACE,MAAM,mBAAmB,OAAO,MAAM,CAAC;gBAEvC,KAAK,MAAM,aAAa,cAAe;oBACrC,KAAK,MAAM,YAAY,QAAQ,iCAAiC,CAC9D,WACC;wBACD,gBAAgB,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,GAAG;oBAC1C;gBACF;gBAEA,KAAK,MAAM,eAAe,aAAc;oBACtC,MAAM,WAAW,YAAY,IAAI,CAAC,KAAK;oBAEvC,IAAI,gBAAgB,CAAC,SAAS,KAAK,MAAM;wBACvC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CAAC,CAAC,UAAU,EAAE,SAAS,gBAAgB,CAAC,EAAE;4BACxD,OAAO;wBACT;oBAEJ;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 694, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variables-Used\n */\nexport function NoUnusedVariablesRule(context) {\n  let variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter() {\n        variableDefs = [];\n      },\n\n      leave(operation) {\n        const variableNameUsed = Object.create(null);\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          variableNameUsed[node.name.value] = true;\n        }\n\n        for (const variableDef of variableDefs) {\n          const variableName = variableDef.variable.name.value;\n\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(\n              new GraphQLError(\n                operation.name\n                  ? `Variable \"$${variableName}\" is never used in operation \"${operation.name.value}\".`\n                  : `Variable \"$${variableName}\" is never used.`,\n                {\n                  nodes: variableDef,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(def) {\n      variableDefs.push(def);\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAUO,SAAS,sBAAsB,OAAO;IAC3C,IAAI,eAAe,EAAE;IACrB,OAAO;QACL,qBAAqB;YACnB;gBACE,eAAe,EAAE;YACnB;YAEA,OAAM,SAAS;gBACb,MAAM,mBAAmB,OAAO,MAAM,CAAC;gBACvC,MAAM,SAAS,QAAQ,0BAA0B,CAAC;gBAElD,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,OAAQ;oBAC7B,gBAAgB,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,GAAG;gBACtC;gBAEA,KAAK,MAAM,eAAe,aAAc;oBACtC,MAAM,eAAe,YAAY,QAAQ,CAAC,IAAI,CAAC,KAAK;oBAEpD,IAAI,gBAAgB,CAAC,aAAa,KAAK,MAAM;wBAC3C,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,UAAU,IAAI,GACV,CAAC,WAAW,EAAE,aAAa,8BAA8B,EAAE,UAAU,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GACnF,CAAC,WAAW,EAAE,aAAa,gBAAgB,CAAC,EAChD;4BACE,OAAO;wBACT;oBAGN;gBACF;YACF;QACF;QAEA,oBAAmB,GAAG;YACpB,aAAa,IAAI,CAAC;QACpB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 731, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  isInterfaceType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../../type/definition.mjs';\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason\n      .map(\n        ([responseName, subReason]) =>\n          `subfields \"${responseName}\" conflict because ` +\n          reasonMessage(subReason),\n      )\n      .join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when fields and a fragment or two fragments are compared\n  // \"between\" each other for conflicts. Comparisons made be made many times,\n  // so memoizing this can dramatically improve the performance of this validator.\n  const comparedFieldsAndFragmentPairs = new OrderedPairSet();\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentNames,\n        comparedFieldsAndFragmentPairs,\n        comparedFragmentPairs,\n        context.getParentType(),\n        selectionSet,\n      );\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(\n          new GraphQLError(\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\n            {\n              nodes: fields1.concat(fields2),\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  parentType,\n  selectionSet,\n) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType,\n    selectionSet,\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    fieldMap,\n  );\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFieldsAndFragmentPairs,\n        comparedFragmentPairs,\n        false,\n        fieldMap,\n        fragmentNames[i],\n      ); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(\n          context,\n          conflicts,\n          cachedFieldsAndFragmentNames,\n          comparedFieldsAndFragmentPairs,\n          comparedFragmentPairs,\n          false,\n          fragmentNames[i],\n          fragmentNames[j],\n        );\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fieldMap,\n  fragmentName,\n) {\n  // Memoize so the fields and fragments are not compared for conflicts more\n  // than once.\n  if (\n    comparedFieldsAndFragmentPairs.has(\n      fieldMap,\n      fragmentName,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFieldsAndFragmentPairs.add(\n    fieldMap,\n    fragmentName,\n    areMutuallyExclusive,\n  );\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment,\n    ); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap,\n    fieldMap2,\n  ); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap,\n      referencedFragmentName,\n    );\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fragmentName1,\n  fragmentName2,\n) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (\n    comparedFragmentPairs.has(\n      fragmentName1,\n      fragmentName2,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment1,\n    );\n  const [fieldMap2, referencedFragmentNames2] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment2,\n    ); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fragmentName1,\n      referencedFragmentName2,\n    );\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      referencedFragmentName1,\n      fragmentName2,\n    );\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  parentType1,\n  selectionSet1,\n  parentType2,\n  selectionSet2,\n) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType1,\n    selectionSet1,\n  );\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType2,\n    selectionSet2,\n  ); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentName2,\n    );\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentName1,\n    );\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFieldsAndFragmentPairs,\n        comparedFragmentPairs,\n        areMutuallyExclusive,\n        fragmentName1,\n        fragmentName2,\n      );\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  fieldMap,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFieldsAndFragmentPairs,\n            comparedFragmentPairs,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            fields[j],\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  fieldMap1,\n  fieldMap2,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFieldsAndFragmentPairs,\n            comparedFragmentPairs,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            field1,\n            field2,\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  responseName,\n  field1,\n  field2,\n) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    (parentType1 !== parentType2 &&\n      isObjectType(parentType1) &&\n      isObjectType(parentType2));\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2],\n      ];\n    } // Two field calls must have the same arguments.\n\n    if (!sameArguments(node1, node2)) {\n      return [\n        [responseName, 'they have differing arguments'],\n        [node1],\n        [node2],\n      ];\n    }\n  } // The return type for each field.\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${inspect(type1)}\" and \"${inspect(\n          type2,\n        )}\"`,\n      ],\n      [node1],\n      [node2],\n    ];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      getNamedType(type1),\n      selectionSet1,\n      getNamedType(type2),\n      selectionSet2,\n    );\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(node1, node2) {\n  const args1 = node1.arguments;\n  const args2 = node2.arguments;\n\n  if (args1 === undefined || args1.length === 0) {\n    return args2 === undefined || args2.length === 0;\n  }\n\n  if (args2 === undefined || args2.length === 0) {\n    return false;\n  }\n  /* c8 ignore next */\n\n  if (args1.length !== args2.length) {\n    /* c8 ignore next */\n    return false;\n    /* c8 ignore next */\n  }\n\n  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));\n  return args1.every((arg1) => {\n    const value1 = arg1.value;\n    const value2 = values2.get(arg1.name.value);\n\n    if (value2 === undefined) {\n      return false;\n    }\n\n    return stringifyValue(value1) === stringifyValue(value2);\n  });\n}\n\nfunction stringifyValue(value) {\n  return print(sortValueNode(value));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  parentType,\n  selectionSet,\n) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(\n    context,\n    parentType,\n    selectionSet,\n    nodeAndDefs,\n    fragmentNames,\n  );\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  fragment,\n) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragmentType,\n    fragment.selectionSet,\n  );\n}\n\nfunction _collectFieldsAndFragmentNames(\n  context,\n  parentType,\n  selectionSet,\n  nodeAndDefs,\n  fragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        const responseName = selection.alias\n          ? selection.alias.value\n          : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition\n          ? typeFromAST(context.getSchema(), typeCondition)\n          : parentType;\n\n        _collectFieldsAndFragmentNames(\n          context,\n          inlineFragmentType,\n          selection.selectionSet,\n          nodeAndDefs,\n          fragmentNames,\n        );\n\n        break;\n      }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\n    ];\n  }\n}\n/**\n * A way to keep track of pairs of things where the ordering of the pair\n * matters.\n *\n * Provides a third argument for has/set to allow flagging the pair as\n * weakly or strongly present within the collection.\n */\n\nclass OrderedPairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, weaklyPresent) {\n    var _this$_data$get;\n\n    const result =\n      (_this$_data$get = this._data.get(a)) === null ||\n      _this$_data$get === void 0\n        ? void 0\n        : _this$_data$get.get(b);\n\n    if (result === undefined) {\n      return false;\n    }\n\n    return weaklyPresent ? true : weaklyPresent === result;\n  }\n\n  add(a, b, weaklyPresent) {\n    const map = this._data.get(a);\n\n    if (map === undefined) {\n      this._data.set(a, new Map([[b, weaklyPresent]]));\n    } else {\n      map.set(b, weaklyPresent);\n    }\n  }\n}\n/**\n * A way to keep track of pairs of similar things when the ordering of the pair\n * does not matter.\n */\n\nclass PairSet {\n  constructor() {\n    this._orderedPairSet = new OrderedPairSet();\n  }\n\n  has(a, b, weaklyPresent) {\n    return a < b\n      ? this._orderedPairSet.has(a, b, weaklyPresent)\n      : this._orderedPairSet.has(b, a, weaklyPresent);\n  }\n\n  add(a, b, weaklyPresent) {\n    if (a < b) {\n      this._orderedPairSet.add(a, b, weaklyPresent);\n    } else {\n      this._orderedPairSet.add(b, a, weaklyPresent);\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1223, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { isCompositeType } from '../../type/definition.mjs';\nimport { doTypesOverlap } from '../../utilities/typeComparators.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n\n      if (\n        isCompositeType(fragType) &&\n        isCompositeType(parentType) &&\n        !doTypesOverlap(context.getSchema(), fragType, parentType)\n      ) {\n        const parentTypeStr = inspect(parentType);\n        const fragTypeStr = inspect(fragType);\n        context.reportError(\n          new GraphQLError(\n            `Fragment cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n\n      if (\n        fragType &&\n        parentType &&\n        !doTypesOverlap(context.getSchema(), fragType, parentType)\n      ) {\n        const parentTypeStr = inspect(parentType);\n        const fragTypeStr = inspect(fragType);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${fragName}\" cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getFragmentType(context, name) {\n  const frag = context.getFragment(name);\n\n  if (frag) {\n    const type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;;;;;AASO,SAAS,4BAA4B,OAAO;IACjD,OAAO;QACL,gBAAe,IAAI;YACjB,MAAM,WAAW,QAAQ,OAAO;YAChC,MAAM,aAAa,QAAQ,aAAa;YAExC,IACE,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD,EAAE,aAChB,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD,EAAE,eAChB,CAAC,CAAA,GAAA,0JAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ,SAAS,IAAI,UAAU,aAC/C;gBACA,MAAM,gBAAgB,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;gBAC9B,MAAM,cAAc,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;gBAC5B,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,mDAAmD,EAAE,cAAc,wBAAwB,EAAE,YAAY,EAAE,CAAC,EAC7G;oBACE,OAAO;gBACT;YAGN;QACF;QAEA,gBAAe,IAAI;YACjB,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;YAChC,MAAM,WAAW,gBAAgB,SAAS;YAC1C,MAAM,aAAa,QAAQ,aAAa;YAExC,IACE,YACA,cACA,CAAC,CAAA,GAAA,0JAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ,SAAS,IAAI,UAAU,aAC/C;gBACA,MAAM,gBAAgB,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;gBAC9B,MAAM,cAAc,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;gBAC5B,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,UAAU,EAAE,SAAS,4CAA4C,EAAE,cAAc,wBAAwB,EAAE,YAAY,EAAE,CAAC,EAC3H;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF;AAEA,SAAS,gBAAgB,OAAO,EAAE,IAAI;IACpC,MAAM,OAAO,QAAQ,WAAW,CAAC;IAEjC,IAAI,MAAM;QACR,MAAM,OAAO,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,SAAS,IAAI,KAAK,aAAa;QAEhE,IAAI,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD,EAAE,OAAO;YACzB,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1276, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs"],"sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isTypeDefinitionNode } from '../../language/predicates.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../../type/definition.mjs';\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension,\n  };\n\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType =\n      schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(\n          new GraphQLError(`Cannot extend non-${kindStr} type \"${typeName}\".`, {\n            nodes: defNode ? [defNode, node] : node,\n          }),\n        );\n      }\n    } else {\n      const allTypeNames = Object.keys({\n        ...definedTypes,\n        ...(schema === null || schema === void 0\n          ? void 0\n          : schema.getTypeMap()),\n      });\n      const suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(\n        new GraphQLError(\n          `Cannot extend type \"${typeName}\" because it is not defined.` +\n            didYouMean(suggestedTypes),\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n    }\n  }\n}\nconst defKindToExtKind = {\n  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,\n  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,\n  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,\n  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,\n  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,\n  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n};\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(kind));\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1398, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { keyMap } from '../../jsutils/keyMap.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isRequiredArgument, isType } from '../../type/definition.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null without a\n * default value) field arguments have been provided.\n */\nexport function ProvidedRequiredArgumentsRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...ProvidedRequiredArgumentsOnDirectivesRule(context),\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(fieldNode) {\n        var _fieldNode$arguments;\n\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          return false;\n        }\n\n        const providedArgs = new Set( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n          /* c8 ignore next */\n          (_fieldNode$arguments = fieldNode.arguments) === null ||\n          _fieldNode$arguments === void 0\n            ? void 0\n            : _fieldNode$arguments.map((arg) => arg.name.value),\n        );\n\n        for (const argDef of fieldDef.args) {\n          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {\n            const argTypeStr = inspect(argDef.type);\n            context.reportError(\n              new GraphQLError(\n                `Field \"${fieldDef.name}\" argument \"${argDef.name}\" of type \"${argTypeStr}\" is required, but it was not provided.`,\n                {\n                  nodes: fieldNode,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n/**\n * @internal\n */\n\nexport function ProvidedRequiredArgumentsOnDirectivesRule(context) {\n  var _schema$getDirectives;\n\n  const requiredArgsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives =\n    (_schema$getDirectives =\n      schema === null || schema === void 0\n        ? void 0\n        : schema.getDirectives()) !== null && _schema$getDirectives !== void 0\n      ? _schema$getDirectives\n      : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    requiredArgsMap[directive.name] = keyMap(\n      directive.args.filter(isRequiredArgument),\n      (arg) => arg.name,\n    );\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      requiredArgsMap[def.name.value] = keyMap(\n        argNodes.filter(isRequiredArgumentNode),\n        (arg) => arg.name.value,\n      );\n    }\n  }\n\n  return {\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(directiveNode) {\n        const directiveName = directiveNode.name.value;\n        const requiredArgs = requiredArgsMap[directiveName];\n\n        if (requiredArgs) {\n          var _directiveNode$argume;\n\n          // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n          /* c8 ignore next */\n          const argNodes =\n            (_directiveNode$argume = directiveNode.arguments) !== null &&\n            _directiveNode$argume !== void 0\n              ? _directiveNode$argume\n              : [];\n          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));\n\n          for (const [argName, argDef] of Object.entries(requiredArgs)) {\n            if (!argNodeMap.has(argName)) {\n              const argType = isType(argDef.type)\n                ? inspect(argDef.type)\n                : print(argDef.type);\n              context.reportError(\n                new GraphQLError(\n                  `Directive \"@${directiveName}\" argument \"${argName}\" of type \"${argType}\" is required, but it was not provided.`,\n                  {\n                    nodes: directiveNode,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n  };\n}\n\nfunction isRequiredArgumentNode(arg) {\n  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1489, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ScalarLeafsRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { getNamedType, isLeafType } from '../../type/definition.mjs';\n\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\nexport function ScalarLeafsRule(context) {\n  return {\n    Field(node) {\n      const type = context.getType();\n      const selectionSet = node.selectionSet;\n\n      if (type) {\n        if (isLeafType(getNamedType(type))) {\n          if (selectionSet) {\n            const fieldName = node.name.value;\n            const typeStr = inspect(type);\n            context.reportError(\n              new GraphQLError(\n                `Field \"${fieldName}\" must not have a selection since type \"${typeStr}\" has no subfields.`,\n                {\n                  nodes: selectionSet,\n                },\n              ),\n            );\n          }\n        } else if (!selectionSet) {\n          const fieldName = node.name.value;\n          const typeStr = inspect(type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${fieldName}\" of type \"${typeStr}\" must have a selection of subfields. Did you mean \"${fieldName} { ... }\"?`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        } else if (selectionSet.selections.length === 0) {\n          const fieldName = node.name.value;\n          const typeStr = inspect(type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${fieldName}\" of type \"${typeStr}\" must have at least one field selected.`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAQO,SAAS,gBAAgB,OAAO;IACrC,OAAO;QACL,OAAM,IAAI;YACR,MAAM,OAAO,QAAQ,OAAO;YAC5B,MAAM,eAAe,KAAK,YAAY;YAEtC,IAAI,MAAM;gBACR,IAAI,CAAA,GAAA,gJAAA,CAAA,aAAU,AAAD,EAAE,CAAA,GAAA,gJAAA,CAAA,eAAY,AAAD,EAAE,QAAQ;oBAClC,IAAI,cAAc;wBAChB,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK;wBACjC,MAAM,UAAU,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;wBACxB,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,OAAO,EAAE,UAAU,wCAAwC,EAAE,QAAQ,mBAAmB,CAAC,EAC1F;4BACE,OAAO;wBACT;oBAGN;gBACF,OAAO,IAAI,CAAC,cAAc;oBACxB,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK;oBACjC,MAAM,UAAU,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;oBACxB,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,OAAO,EAAE,UAAU,WAAW,EAAE,QAAQ,oDAAoD,EAAE,UAAU,UAAU,CAAC,EACpH;wBACE,OAAO;oBACT;gBAGN,OAAO,IAAI,aAAa,UAAU,CAAC,MAAM,KAAK,GAAG;oBAC/C,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK;oBACjC,MAAM,UAAU,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;oBACxB,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,OAAO,EAAE,UAAU,WAAW,EAAE,QAAQ,wCAAwC,CAAC,EAClF;wBACE,OAAO;oBACT;gBAGN;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1533, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { collectFields } from '../../execution/collectFields.mjs';\n\n/**\n * Subscriptions must only include a non-introspection field.\n *\n * A GraphQL subscription is valid only if it contains a single root field and\n * that root field is not an introspection field.\n *\n * See https://spec.graphql.org/draft/#sec-Single-root-field\n */\nexport function SingleFieldSubscriptionsRule(context) {\n  return {\n    OperationDefinition(node) {\n      if (node.operation === 'subscription') {\n        const schema = context.getSchema();\n        const subscriptionType = schema.getSubscriptionType();\n\n        if (subscriptionType) {\n          const operationName = node.name ? node.name.value : null;\n          const variableValues = Object.create(null);\n          const document = context.getDocument();\n          const fragments = Object.create(null);\n\n          for (const definition of document.definitions) {\n            if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n              fragments[definition.name.value] = definition;\n            }\n          }\n\n          const fields = collectFields(\n            schema,\n            fragments,\n            variableValues,\n            subscriptionType,\n            node.selectionSet,\n          );\n\n          if (fields.size > 1) {\n            const fieldSelectionLists = [...fields.values()];\n            const extraFieldSelectionLists = fieldSelectionLists.slice(1);\n            const extraFieldSelections = extraFieldSelectionLists.flat();\n            context.reportError(\n              new GraphQLError(\n                operationName != null\n                  ? `Subscription \"${operationName}\" must select only one top level field.`\n                  : 'Anonymous Subscription must select only one top level field.',\n                {\n                  nodes: extraFieldSelections,\n                },\n              ),\n            );\n          }\n\n          for (const fieldNodes of fields.values()) {\n            const field = fieldNodes[0];\n            const fieldName = field.name.value;\n\n            if (fieldName.startsWith('__')) {\n              context.reportError(\n                new GraphQLError(\n                  operationName != null\n                    ? `Subscription \"${operationName}\" must not select an introspection top level field.`\n                    : 'Anonymous Subscription must not select an introspection top level field.',\n                  {\n                    nodes: fieldNodes,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAUO,SAAS,6BAA6B,OAAO;IAClD,OAAO;QACL,qBAAoB,IAAI;YACtB,IAAI,KAAK,SAAS,KAAK,gBAAgB;gBACrC,MAAM,SAAS,QAAQ,SAAS;gBAChC,MAAM,mBAAmB,OAAO,mBAAmB;gBAEnD,IAAI,kBAAkB;oBACpB,MAAM,gBAAgB,KAAK,IAAI,GAAG,KAAK,IAAI,CAAC,KAAK,GAAG;oBACpD,MAAM,iBAAiB,OAAO,MAAM,CAAC;oBACrC,MAAM,WAAW,QAAQ,WAAW;oBACpC,MAAM,YAAY,OAAO,MAAM,CAAC;oBAEhC,KAAK,MAAM,cAAc,SAAS,WAAW,CAAE;wBAC7C,IAAI,WAAW,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,mBAAmB,EAAE;4BAChD,SAAS,CAAC,WAAW,IAAI,CAAC,KAAK,CAAC,GAAG;wBACrC;oBACF;oBAEA,MAAM,SAAS,CAAA,GAAA,wJAAA,CAAA,gBAAa,AAAD,EACzB,QACA,WACA,gBACA,kBACA,KAAK,YAAY;oBAGnB,IAAI,OAAO,IAAI,GAAG,GAAG;wBACnB,MAAM,sBAAsB;+BAAI,OAAO,MAAM;yBAAG;wBAChD,MAAM,2BAA2B,oBAAoB,KAAK,CAAC;wBAC3D,MAAM,uBAAuB,yBAAyB,IAAI;wBAC1D,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,iBAAiB,OACb,CAAC,cAAc,EAAE,cAAc,uCAAuC,CAAC,GACvE,gEACJ;4BACE,OAAO;wBACT;oBAGN;oBAEA,KAAK,MAAM,cAAc,OAAO,MAAM,GAAI;wBACxC,MAAM,QAAQ,UAAU,CAAC,EAAE;wBAC3B,MAAM,YAAY,MAAM,IAAI,CAAC,KAAK;wBAElC,IAAI,UAAU,UAAU,CAAC,OAAO;4BAC9B,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,iBAAiB,OACb,CAAC,cAAc,EAAE,cAAc,mDAAmD,CAAC,GACnF,4EACJ;gCACE,OAAO;4BACT;wBAGN;oBACF;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1587, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs"],"sourcesContent":["import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique argument definition names\n *\n * A GraphQL Object or Interface type is only valid if all its fields have uniquely named arguments.\n * A GraphQL Directive is only valid if all its arguments are uniquely named.\n */\nexport function UniqueArgumentDefinitionNamesRule(context) {\n  return {\n    DirectiveDefinition(directiveNode) {\n      var _directiveNode$argume;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argumentNodes =\n        (_directiveNode$argume = directiveNode.arguments) !== null &&\n        _directiveNode$argume !== void 0\n          ? _directiveNode$argume\n          : [];\n      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);\n    },\n\n    InterfaceTypeDefinition: checkArgUniquenessPerField,\n    InterfaceTypeExtension: checkArgUniquenessPerField,\n    ObjectTypeDefinition: checkArgUniquenessPerField,\n    ObjectTypeExtension: checkArgUniquenessPerField,\n  };\n\n  function checkArgUniquenessPerField(typeNode) {\n    var _typeNode$fields;\n\n    const typeName = typeNode.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_typeNode$fields = typeNode.fields) !== null &&\n      _typeNode$fields !== void 0\n        ? _typeNode$fields\n        : [];\n\n    for (const fieldDef of fieldNodes) {\n      var _fieldDef$arguments;\n\n      const fieldName = fieldDef.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n\n      const argumentNodes =\n        (_fieldDef$arguments = fieldDef.arguments) !== null &&\n        _fieldDef$arguments !== void 0\n          ? _fieldDef$arguments\n          : [];\n      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);\n    }\n\n    return false;\n  }\n\n  function checkArgUniqueness(parentName, argumentNodes) {\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new GraphQLError(\n            `Argument \"${parentName}(${argName}:)\" can only be defined once.`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAQO,SAAS,kCAAkC,OAAO;IACvD,OAAO;QACL,qBAAoB,aAAa;YAC/B,IAAI;YAEJ,2DAA2D;YAE3D,kBAAkB,GAClB,MAAM,gBACJ,CAAC,wBAAwB,cAAc,SAAS,MAAM,QACtD,0BAA0B,KAAK,IAC3B,wBACA,EAAE;YACR,OAAO,mBAAmB,CAAC,CAAC,EAAE,cAAc,IAAI,CAAC,KAAK,EAAE,EAAE;QAC5D;QAEA,yBAAyB;QACzB,wBAAwB;QACxB,sBAAsB;QACtB,qBAAqB;IACvB;;;IAEA,SAAS,2BAA2B,QAAQ;QAC1C,IAAI;QAEJ,MAAM,WAAW,SAAS,IAAI,CAAC,KAAK,EAAE,2DAA2D;QAEjG,kBAAkB,GAElB,MAAM,aACJ,CAAC,mBAAmB,SAAS,MAAM,MAAM,QACzC,qBAAqB,KAAK,IACtB,mBACA,EAAE;QAER,KAAK,MAAM,YAAY,WAAY;YACjC,IAAI;YAEJ,MAAM,YAAY,SAAS,IAAI,CAAC,KAAK,EAAE,2DAA2D;YAElG,kBAAkB,GAElB,MAAM,gBACJ,CAAC,sBAAsB,SAAS,SAAS,MAAM,QAC/C,wBAAwB,KAAK,IACzB,sBACA,EAAE;YACR,mBAAmB,GAAG,SAAS,CAAC,EAAE,WAAW,EAAE;QACjD;QAEA,OAAO;IACT;IAEA,SAAS,mBAAmB,UAAU,EAAE,aAAa;QACnD,MAAM,WAAW,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE,eAAe,CAAC,MAAQ,IAAI,IAAI,CAAC,KAAK;QAE/D,KAAK,MAAM,CAAC,SAAS,SAAS,IAAI,SAAU;YAC1C,IAAI,SAAS,MAAM,GAAG,GAAG;gBACvB,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,UAAU,EAAE,WAAW,CAAC,EAAE,QAAQ,6BAA6B,CAAC,EACjE;oBACE,OAAO,SAAS,GAAG,CAAC,CAAC,OAAS,KAAK,IAAI;gBACzC;YAGN;QACF;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1637, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs"],"sourcesContent":["import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique argument names\n *\n * A GraphQL field or directive is only valid if all supplied arguments are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n */\nexport function UniqueArgumentNamesRule(context) {\n  return {\n    Field: checkArgUniqueness,\n    Directive: checkArgUniqueness,\n  };\n\n  function checkArgUniqueness(parentNode) {\n    var _parentNode$arguments;\n\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const argumentNodes =\n      (_parentNode$arguments = parentNode.arguments) !== null &&\n      _parentNode$arguments !== void 0\n        ? _parentNode$arguments\n        : [];\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one argument named \"${argName}\".`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAUO,SAAS,wBAAwB,OAAO;IAC7C,OAAO;QACL,OAAO;QACP,WAAW;IACb;;;IAEA,SAAS,mBAAmB,UAAU;QACpC,IAAI;QAEJ,2DAA2D;QAE3D,kBAAkB,GAClB,MAAM,gBACJ,CAAC,wBAAwB,WAAW,SAAS,MAAM,QACnD,0BAA0B,KAAK,IAC3B,wBACA,EAAE;QACR,MAAM,WAAW,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE,eAAe,CAAC,MAAQ,IAAI,IAAI,CAAC,KAAK;QAE/D,KAAK,MAAM,CAAC,SAAS,SAAS,IAAI,SAAU;YAC1C,IAAI,SAAS,MAAM,GAAG,GAAG;gBACvB,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,sCAAsC,EAAE,QAAQ,EAAE,CAAC,EACpD;oBACE,OAAO,SAAS,GAAG,CAAC,CAAC,OAAS,KAAK,IAAI;gBACzC;YAGN;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1669, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique directive names\n *\n * A GraphQL document is only valid if all defined directives have unique names.\n */\nexport function UniqueDirectiveNamesRule(context) {\n  const knownDirectiveNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    DirectiveDefinition(node) {\n      const directiveName = node.name.value;\n\n      if (\n        schema !== null &&\n        schema !== void 0 &&\n        schema.getDirective(directiveName)\n      ) {\n        context.reportError(\n          new GraphQLError(\n            `Directive \"@${directiveName}\" already exists in the schema. It cannot be redefined.`,\n            {\n              nodes: node.name,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (knownDirectiveNames[directiveName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one directive named \"@${directiveName}\".`,\n            {\n              nodes: [knownDirectiveNames[directiveName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownDirectiveNames[directiveName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,yBAAyB,OAAO;IAC9C,MAAM,sBAAsB,OAAO,MAAM,CAAC;IAC1C,MAAM,SAAS,QAAQ,SAAS;IAChC,OAAO;QACL,qBAAoB,IAAI;YACtB,MAAM,gBAAgB,KAAK,IAAI,CAAC,KAAK;YAErC,IACE,WAAW,QACX,WAAW,KAAK,KAChB,OAAO,YAAY,CAAC,gBACpB;gBACA,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,YAAY,EAAE,cAAc,uDAAuD,CAAC,EACrF;oBACE,OAAO,KAAK,IAAI;gBAClB;gBAGJ;YACF;YAEA,IAAI,mBAAmB,CAAC,cAAc,EAAE;gBACtC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,wCAAwC,EAAE,cAAc,EAAE,CAAC,EAC5D;oBACE,OAAO;wBAAC,mBAAmB,CAAC,cAAc;wBAAE,KAAK,IAAI;qBAAC;gBACxD;YAGN,OAAO;gBACL,mBAAmB,CAAC,cAAc,GAAG,KAAK,IAAI;YAChD;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1704, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeExtensionNode,\n} from '../../language/predicates.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Unique-Per-Location\n */\nexport function UniqueDirectivesPerLocationRule(context) {\n  const uniqueDirectiveMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  const schemaDirectives = Object.create(null);\n  const typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter(node) {\n      if (!('directives' in node) || !node.directives) {\n        return;\n      }\n\n      let seenDirectives;\n\n      if (\n        node.kind === Kind.SCHEMA_DEFINITION ||\n        node.kind === Kind.SCHEMA_EXTENSION\n      ) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        const typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (const directive of node.directives) {\n        const directiveName = directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(\n              new GraphQLError(\n                `The directive \"@${directiveName}\" can only be used once at this location.`,\n                {\n                  nodes: [seenDirectives[directiveName], directive],\n                },\n              ),\n            );\n          } else {\n            seenDirectives[directiveName] = directive;\n          }\n        }\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AAIA;;;;;AAUO,SAAS,gCAAgC,OAAO;IACrD,MAAM,qBAAqB,OAAO,MAAM,CAAC;IACzC,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,oBAAoB,SACtB,OAAO,aAAa,KACpB,gJAAA,CAAA,sBAAmB;IAEvB,KAAK,MAAM,aAAa,kBAAmB;QACzC,kBAAkB,CAAC,UAAU,IAAI,CAAC,GAAG,CAAC,UAAU,YAAY;IAC9D;IAEA,MAAM,iBAAiB,QAAQ,WAAW,GAAG,WAAW;IAExD,KAAK,MAAM,OAAO,eAAgB;QAChC,IAAI,IAAI,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,oBAAoB,EAAE;YAC1C,kBAAkB,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,UAAU;QACtD;IACF;IAEA,MAAM,mBAAmB,OAAO,MAAM,CAAC;IACvC,MAAM,oBAAoB,OAAO,MAAM,CAAC;IACxC,OAAO;QACL,uEAAuE;QACvE,sEAAsE;QACtE,0BAA0B;QAC1B,OAAM,IAAI;YACR,IAAI,CAAC,CAAC,gBAAgB,IAAI,KAAK,CAAC,KAAK,UAAU,EAAE;gBAC/C;YACF;YAEA,IAAI;YAEJ,IACE,KAAK,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,iBAAiB,IACpC,KAAK,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,gBAAgB,EACnC;gBACA,iBAAiB;YACnB,OAAO,IAAI,CAAA,GAAA,oJAAA,CAAA,uBAAoB,AAAD,EAAE,SAAS,CAAA,GAAA,oJAAA,CAAA,sBAAmB,AAAD,EAAE,OAAO;gBAClE,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;gBAChC,iBAAiB,iBAAiB,CAAC,SAAS;gBAE5C,IAAI,mBAAmB,WAAW;oBAChC,iBAAiB,CAAC,SAAS,GAAG,iBAAiB,OAAO,MAAM,CAAC;gBAC/D;YACF,OAAO;gBACL,iBAAiB,OAAO,MAAM,CAAC;YACjC;YAEA,KAAK,MAAM,aAAa,KAAK,UAAU,CAAE;gBACvC,MAAM,gBAAgB,UAAU,IAAI,CAAC,KAAK;gBAE1C,IAAI,kBAAkB,CAAC,cAAc,EAAE;oBACrC,IAAI,cAAc,CAAC,cAAc,EAAE;wBACjC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,gBAAgB,EAAE,cAAc,yCAAyC,CAAC,EAC3E;4BACE,OAAO;gCAAC,cAAc,CAAC,cAAc;gCAAE;6BAAU;wBACnD;oBAGN,OAAO;wBACL,cAAc,CAAC,cAAc,GAAG;oBAClC;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1772, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { isEnumType } from '../../type/definition.mjs';\n\n/**\n * Unique enum value names\n *\n * A GraphQL enum type is only valid if all its values are uniquely named.\n */\nexport function UniqueEnumValueNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownValueNames = Object.create(null);\n  return {\n    EnumTypeDefinition: checkValueUniqueness,\n    EnumTypeExtension: checkValueUniqueness,\n  };\n\n  function checkValueUniqueness(node) {\n    var _node$values;\n\n    const typeName = node.name.value;\n\n    if (!knownValueNames[typeName]) {\n      knownValueNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const valueNodes =\n      (_node$values = node.values) !== null && _node$values !== void 0\n        ? _node$values\n        : [];\n    const valueNames = knownValueNames[typeName];\n\n    for (const valueDef of valueNodes) {\n      const valueName = valueDef.name.value;\n      const existingType = existingTypeMap[typeName];\n\n      if (isEnumType(existingType) && existingType.getValue(valueName)) {\n        context.reportError(\n          new GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: valueDef.name,\n            },\n          ),\n        );\n      } else if (valueNames[valueName]) {\n        context.reportError(\n          new GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" can only be defined once.`,\n            {\n              nodes: [valueNames[valueName], valueDef.name],\n            },\n          ),\n        );\n      } else {\n        valueNames[valueName] = valueDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAOO,SAAS,yBAAyB,OAAO;IAC9C,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,kBAAkB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACrE,MAAM,kBAAkB,OAAO,MAAM,CAAC;IACtC,OAAO;QACL,oBAAoB;QACpB,mBAAmB;IACrB;;;IAEA,SAAS,qBAAqB,IAAI;QAChC,IAAI;QAEJ,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;QAEhC,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE;YAC9B,eAAe,CAAC,SAAS,GAAG,OAAO,MAAM,CAAC;QAC5C,EAAE,2DAA2D;QAE7D,kBAAkB,GAElB,MAAM,aACJ,CAAC,eAAe,KAAK,MAAM,MAAM,QAAQ,iBAAiB,KAAK,IAC3D,eACA,EAAE;QACR,MAAM,aAAa,eAAe,CAAC,SAAS;QAE5C,KAAK,MAAM,YAAY,WAAY;YACjC,MAAM,YAAY,SAAS,IAAI,CAAC,KAAK;YACrC,MAAM,eAAe,eAAe,CAAC,SAAS;YAE9C,IAAI,CAAA,GAAA,gJAAA,CAAA,aAAU,AAAD,EAAE,iBAAiB,aAAa,QAAQ,CAAC,YAAY;gBAChE,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,YAAY,EAAE,SAAS,CAAC,EAAE,UAAU,iFAAiF,CAAC,EACvH;oBACE,OAAO,SAAS,IAAI;gBACtB;YAGN,OAAO,IAAI,UAAU,CAAC,UAAU,EAAE;gBAChC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,YAAY,EAAE,SAAS,CAAC,EAAE,UAAU,2BAA2B,CAAC,EACjE;oBACE,OAAO;wBAAC,UAAU,CAAC,UAAU;wBAAE,SAAS,IAAI;qBAAC;gBAC/C;YAGN,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,SAAS,IAAI;YACvC;QACF;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1822, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Unique field definition names\n *\n * A GraphQL complex type is only valid if all its fields are uniquely named.\n */\nexport function UniqueFieldDefinitionNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownFieldNames = Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness,\n  };\n\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n\n    const typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_node$fields = node.fields) !== null && _node$fields !== void 0\n        ? _node$fields\n        : [];\n    const fieldNames = knownFieldNames[typeName];\n\n    for (const fieldDef of fieldNodes) {\n      const fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(\n          new GraphQLError(\n            `Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: fieldDef.name,\n            },\n          ),\n        );\n      } else if (fieldNames[fieldName]) {\n        context.reportError(\n          new GraphQLError(\n            `Field \"${typeName}.${fieldName}\" can only be defined once.`,\n            {\n              nodes: [fieldNames[fieldName], fieldDef.name],\n            },\n          ),\n        );\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasField(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    return type.getFields()[fieldName] != null;\n  }\n\n  return false;\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAWO,SAAS,+BAA+B,OAAO;IACpD,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,kBAAkB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACrE,MAAM,kBAAkB,OAAO,MAAM,CAAC;IACtC,OAAO;QACL,2BAA2B;QAC3B,0BAA0B;QAC1B,yBAAyB;QACzB,wBAAwB;QACxB,sBAAsB;QACtB,qBAAqB;IACvB;;;IAEA,SAAS,qBAAqB,IAAI;QAChC,IAAI;QAEJ,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;QAEhC,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE;YAC9B,eAAe,CAAC,SAAS,GAAG,OAAO,MAAM,CAAC;QAC5C,EAAE,2DAA2D;QAE7D,kBAAkB,GAElB,MAAM,aACJ,CAAC,eAAe,KAAK,MAAM,MAAM,QAAQ,iBAAiB,KAAK,IAC3D,eACA,EAAE;QACR,MAAM,aAAa,eAAe,CAAC,SAAS;QAE5C,KAAK,MAAM,YAAY,WAAY;YACjC,MAAM,YAAY,SAAS,IAAI,CAAC,KAAK;YAErC,IAAI,SAAS,eAAe,CAAC,SAAS,EAAE,YAAY;gBAClD,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,UAAU,iFAAiF,CAAC,EAClH;oBACE,OAAO,SAAS,IAAI;gBACtB;YAGN,OAAO,IAAI,UAAU,CAAC,UAAU,EAAE;gBAChC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,UAAU,2BAA2B,CAAC,EAC5D;oBACE,OAAO;wBAAC,UAAU,CAAC,UAAU;wBAAE,SAAS,IAAI;qBAAC;gBAC/C;YAGN,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,SAAS,IAAI;YACvC;QACF;QAEA,OAAO;IACT;AACF;AAEA,SAAS,SAAS,IAAI,EAAE,SAAS;IAC/B,IAAI,CAAA,GAAA,gJAAA,CAAA,eAAY,AAAD,EAAE,SAAS,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD,EAAE,SAAS,CAAA,GAAA,gJAAA,CAAA,oBAAiB,AAAD,EAAE,OAAO;QAC1E,OAAO,KAAK,SAAS,EAAE,CAAC,UAAU,IAAI;IACxC;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1881, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Name-Uniqueness\n */\nexport function UniqueFragmentNamesRule(context) {\n  const knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      const fragmentName = node.name.value;\n\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one fragment named \"${fragmentName}\".`,\n            {\n              nodes: [knownFragmentNames[fragmentName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AASO,SAAS,wBAAwB,OAAO;IAC7C,MAAM,qBAAqB,OAAO,MAAM,CAAC;IACzC,OAAO;QACL,qBAAqB,IAAM;QAE3B,oBAAmB,IAAI;YACrB,MAAM,eAAe,KAAK,IAAI,CAAC,KAAK;YAEpC,IAAI,kBAAkB,CAAC,aAAa,EAAE;gBACpC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,sCAAsC,EAAE,aAAa,EAAE,CAAC,EACzD;oBACE,OAAO;wBAAC,kBAAkB,CAAC,aAAa;wBAAE,KAAK,IAAI;qBAAC;gBACtD;YAGN,OAAO;gBACL,kBAAkB,CAAC,aAAa,GAAG,KAAK,IAAI;YAC9C;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1910, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs"],"sourcesContent":["import { invariant } from '../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique input field names\n *\n * A GraphQL input object value is only valid if all supplied fields are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Input-Object-Field-Uniqueness\n */\nexport function UniqueInputFieldNamesRule(context) {\n  const knownNameStack = [];\n  let knownNames = Object.create(null);\n  return {\n    ObjectValue: {\n      enter() {\n        knownNameStack.push(knownNames);\n        knownNames = Object.create(null);\n      },\n\n      leave() {\n        const prevKnownNames = knownNameStack.pop();\n        prevKnownNames || invariant(false);\n        knownNames = prevKnownNames;\n      },\n    },\n\n    ObjectField(node) {\n      const fieldName = node.name.value;\n\n      if (knownNames[fieldName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one input field named \"${fieldName}\".`,\n            {\n              nodes: [knownNames[fieldName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAUO,SAAS,0BAA0B,OAAO;IAC/C,MAAM,iBAAiB,EAAE;IACzB,IAAI,aAAa,OAAO,MAAM,CAAC;IAC/B,OAAO;QACL,aAAa;YACX;gBACE,eAAe,IAAI,CAAC;gBACpB,aAAa,OAAO,MAAM,CAAC;YAC7B;YAEA;gBACE,MAAM,iBAAiB,eAAe,GAAG;gBACzC,kBAAkB,CAAA,GAAA,kJAAA,CAAA,YAAS,AAAD,EAAE;gBAC5B,aAAa;YACf;QACF;QAEA,aAAY,IAAI;YACd,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK;YAEjC,IAAI,UAAU,CAAC,UAAU,EAAE;gBACzB,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,yCAAyC,EAAE,UAAU,EAAE,CAAC,EACzD;oBACE,OAAO;wBAAC,UAAU,CAAC,UAAU;wBAAE,KAAK,IAAI;qBAAC;gBAC3C;YAGN,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,KAAK,IAAI;YACnC;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1951, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Operation-Name-Uniqueness\n */\nexport function UniqueOperationNamesRule(context) {\n  const knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition(node) {\n      const operationName = node.name;\n\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(\n            new GraphQLError(\n              `There can be only one operation named \"${operationName.value}\".`,\n              {\n                nodes: [\n                  knownOperationNames[operationName.value],\n                  operationName,\n                ],\n              },\n            ),\n          );\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n\n      return false;\n    },\n\n    FragmentDefinition: () => false,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AASO,SAAS,yBAAyB,OAAO;IAC9C,MAAM,sBAAsB,OAAO,MAAM,CAAC;IAC1C,OAAO;QACL,qBAAoB,IAAI;YACtB,MAAM,gBAAgB,KAAK,IAAI;YAE/B,IAAI,eAAe;gBACjB,IAAI,mBAAmB,CAAC,cAAc,KAAK,CAAC,EAAE;oBAC5C,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,uCAAuC,EAAE,cAAc,KAAK,CAAC,EAAE,CAAC,EACjE;wBACE,OAAO;4BACL,mBAAmB,CAAC,cAAc,KAAK,CAAC;4BACxC;yBACD;oBACH;gBAGN,OAAO;oBACL,mBAAmB,CAAC,cAAc,KAAK,CAAC,GAAG;gBAC7C;YACF;YAEA,OAAO;QACT;QAEA,oBAAoB,IAAM;IAC5B;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1982, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique operation types\n *\n * A GraphQL document is only valid if it has only one type per operation.\n */\nexport function UniqueOperationTypesRule(context) {\n  const schema = context.getSchema();\n  const definedOperationTypes = Object.create(null);\n  const existingOperationTypes = schema\n    ? {\n        query: schema.getQueryType(),\n        mutation: schema.getMutationType(),\n        subscription: schema.getSubscriptionType(),\n      }\n    : {};\n  return {\n    SchemaDefinition: checkOperationTypes,\n    SchemaExtension: checkOperationTypes,\n  };\n\n  function checkOperationTypes(node) {\n    var _node$operationTypes;\n\n    // See: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const operationTypesNodes =\n      (_node$operationTypes = node.operationTypes) !== null &&\n      _node$operationTypes !== void 0\n        ? _node$operationTypes\n        : [];\n\n    for (const operationType of operationTypesNodes) {\n      const operation = operationType.operation;\n      const alreadyDefinedOperationType = definedOperationTypes[operation];\n\n      if (existingOperationTypes[operation]) {\n        context.reportError(\n          new GraphQLError(\n            `Type for ${operation} already defined in the schema. It cannot be redefined.`,\n            {\n              nodes: operationType,\n            },\n          ),\n        );\n      } else if (alreadyDefinedOperationType) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one ${operation} type in schema.`,\n            {\n              nodes: [alreadyDefinedOperationType, operationType],\n            },\n          ),\n        );\n      } else {\n        definedOperationTypes[operation] = operationType;\n      }\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,yBAAyB,OAAO;IAC9C,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,wBAAwB,OAAO,MAAM,CAAC;IAC5C,MAAM,yBAAyB,SAC3B;QACE,OAAO,OAAO,YAAY;QAC1B,UAAU,OAAO,eAAe;QAChC,cAAc,OAAO,mBAAmB;IAC1C,IACA,CAAC;IACL,OAAO;QACL,kBAAkB;QAClB,iBAAiB;IACnB;;;IAEA,SAAS,oBAAoB,IAAI;QAC/B,IAAI;QAEJ,yDAAyD;QAEzD,kBAAkB,GAClB,MAAM,sBACJ,CAAC,uBAAuB,KAAK,cAAc,MAAM,QACjD,yBAAyB,KAAK,IAC1B,uBACA,EAAE;QAER,KAAK,MAAM,iBAAiB,oBAAqB;YAC/C,MAAM,YAAY,cAAc,SAAS;YACzC,MAAM,8BAA8B,qBAAqB,CAAC,UAAU;YAEpE,IAAI,sBAAsB,CAAC,UAAU,EAAE;gBACrC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,SAAS,EAAE,UAAU,uDAAuD,CAAC,EAC9E;oBACE,OAAO;gBACT;YAGN,OAAO,IAAI,6BAA6B;gBACtC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,sBAAsB,EAAE,UAAU,gBAAgB,CAAC,EACpD;oBACE,OAAO;wBAAC;wBAA6B;qBAAc;gBACrD;YAGN,OAAO;gBACL,qBAAqB,CAAC,UAAU,GAAG;YACrC;QACF;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2030, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique type names\n *\n * A GraphQL document is only valid if all defined types have unique names.\n */\nexport function UniqueTypeNamesRule(context) {\n  const knownTypeNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName,\n  };\n\n  function checkTypeName(node) {\n    const typeName = node.name.value;\n\n    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {\n      context.reportError(\n        new GraphQLError(\n          `Type \"${typeName}\" already exists in the schema. It cannot also be defined in this type definition.`,\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n      return;\n    }\n\n    if (knownTypeNames[typeName]) {\n      context.reportError(\n        new GraphQLError(`There can be only one type named \"${typeName}\".`, {\n          nodes: [knownTypeNames[typeName], node.name],\n        }),\n      );\n    } else {\n      knownTypeNames[typeName] = node.name;\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,oBAAoB,OAAO;IACzC,MAAM,iBAAiB,OAAO,MAAM,CAAC;IACrC,MAAM,SAAS,QAAQ,SAAS;IAChC,OAAO;QACL,sBAAsB;QACtB,sBAAsB;QACtB,yBAAyB;QACzB,qBAAqB;QACrB,oBAAoB;QACpB,2BAA2B;IAC7B;;;IAEA,SAAS,cAAc,IAAI;QACzB,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;QAEhC,IAAI,WAAW,QAAQ,WAAW,KAAK,KAAK,OAAO,OAAO,CAAC,WAAW;YACpE,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,MAAM,EAAE,SAAS,kFAAkF,CAAC,EACrG;gBACE,OAAO,KAAK,IAAI;YAClB;YAGJ;QACF;QAEA,IAAI,cAAc,CAAC,SAAS,EAAE;YAC5B,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CAAC,CAAC,kCAAkC,EAAE,SAAS,EAAE,CAAC,EAAE;gBAClE,OAAO;oBAAC,cAAc,CAAC,SAAS;oBAAE,KAAK,IAAI;iBAAC;YAC9C;QAEJ,OAAO;YACL,cAAc,CAAC,SAAS,GAAG,KAAK,IAAI;QACtC;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2073, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs"],"sourcesContent":["import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique variable names\n *\n * A GraphQL operation is only valid if all its variables are uniquely named.\n */\nexport function UniqueVariableNamesRule(context) {\n  return {\n    OperationDefinition(operationNode) {\n      var _operationNode$variab;\n\n      // See: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const variableDefinitions =\n        (_operationNode$variab = operationNode.variableDefinitions) !== null &&\n        _operationNode$variab !== void 0\n          ? _operationNode$variab\n          : [];\n      const seenVariableDefinitions = groupBy(\n        variableDefinitions,\n        (node) => node.variable.name.value,\n      );\n\n      for (const [variableName, variableNodes] of seenVariableDefinitions) {\n        if (variableNodes.length > 1) {\n          context.reportError(\n            new GraphQLError(\n              `There can be only one variable named \"$${variableName}\".`,\n              {\n                nodes: variableNodes.map((node) => node.variable.name),\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAOO,SAAS,wBAAwB,OAAO;IAC7C,OAAO;QACL,qBAAoB,aAAa;YAC/B,IAAI;YAEJ,yDAAyD;YAEzD,kBAAkB,GAClB,MAAM,sBACJ,CAAC,wBAAwB,cAAc,mBAAmB,MAAM,QAChE,0BAA0B,KAAK,IAC3B,wBACA,EAAE;YACR,MAAM,0BAA0B,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EACpC,qBACA,CAAC,OAAS,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK;YAGpC,KAAK,MAAM,CAAC,cAAc,cAAc,IAAI,wBAAyB;gBACnE,IAAI,cAAc,MAAM,GAAG,GAAG;oBAC5B,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,uCAAuC,EAAE,aAAa,EAAE,CAAC,EAC1D;wBACE,OAAO,cAAc,GAAG,CAAC,CAAC,OAAS,KAAK,QAAQ,CAAC,IAAI;oBACvD;gBAGN;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2101, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs"],"sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { keyMap } from '../../jsutils/keyMap.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  getNullableType,\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isRequiredInputField,\n} from '../../type/definition.mjs';\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n *\n * See https://spec.graphql.org/draft/#sec-Values-of-Correct-Type\n */\nexport function ValuesOfCorrectTypeRule(context) {\n  let variableDefinitions = {};\n  return {\n    OperationDefinition: {\n      enter() {\n        variableDefinitions = {};\n      },\n    },\n\n    VariableDefinition(definition) {\n      variableDefinitions[definition.variable.name.value] = definition;\n    },\n\n    ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      const type = getNullableType(context.getParentInputType());\n\n      if (!isListType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n\n    ObjectValue(node) {\n      const type = getNamedType(context.getInputType());\n\n      if (!isInputObjectType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);\n\n      for (const fieldDef of Object.values(type.getFields())) {\n        const fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && isRequiredInputField(fieldDef)) {\n          const typeStr = inspect(fieldDef.type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${type.name}.${fieldDef.name}\" of required type \"${typeStr}\" was not provided.`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n\n      if (type.isOneOf) {\n        validateOneOfInputObject(\n          context,\n          node,\n          type,\n          fieldNodeMap,\n          variableDefinitions,\n        );\n      }\n    },\n\n    ObjectField(node) {\n      const parentType = getNamedType(context.getParentInputType());\n      const fieldType = context.getInputType();\n\n      if (!fieldType && isInputObjectType(parentType)) {\n        const suggestions = suggestionList(\n          node.name.value,\n          Object.keys(parentType.getFields()),\n        );\n        context.reportError(\n          new GraphQLError(\n            `Field \"${node.name.value}\" is not defined by type \"${parentType.name}\".` +\n              didYouMean(suggestions),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    NullValue(node) {\n      const type = context.getInputType();\n\n      if (isNonNullType(type)) {\n        context.reportError(\n          new GraphQLError(\n            `Expected value of type \"${inspect(type)}\", found ${print(node)}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    EnumValue: (node) => isValidValueNode(context, node),\n    IntValue: (node) => isValidValueNode(context, node),\n    FloatValue: (node) => isValidValueNode(context, node),\n    StringValue: (node) => isValidValueNode(context, node),\n    BooleanValue: (node) => isValidValueNode(context, node),\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  const locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  const type = getNamedType(locationType);\n\n  if (!isLeafType(type)) {\n    const typeStr = inspect(locationType);\n    context.reportError(\n      new GraphQLError(\n        `Expected value of type \"${typeStr}\", found ${print(node)}.`,\n        {\n          nodes: node,\n        },\n      ),\n    );\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n  try {\n    const parseResult = type.parseLiteral(\n      node,\n      undefined,\n      /* variables */\n    );\n\n    if (parseResult === undefined) {\n      const typeStr = inspect(locationType);\n      context.reportError(\n        new GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${print(node)}.`,\n          {\n            nodes: node,\n          },\n        ),\n      );\n    }\n  } catch (error) {\n    const typeStr = inspect(locationType);\n\n    if (error instanceof GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(\n        new GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${print(node)}; ` +\n            error.message,\n          {\n            nodes: node,\n            originalError: error,\n          },\n        ),\n      );\n    }\n  }\n}\n\nfunction validateOneOfInputObject(\n  context,\n  node,\n  type,\n  fieldNodeMap,\n  variableDefinitions,\n) {\n  var _fieldNodeMap$keys$;\n\n  const keys = Object.keys(fieldNodeMap);\n  const isNotExactlyOneField = keys.length !== 1;\n\n  if (isNotExactlyOneField) {\n    context.reportError(\n      new GraphQLError(\n        `OneOf Input Object \"${type.name}\" must specify exactly one key.`,\n        {\n          nodes: [node],\n        },\n      ),\n    );\n    return;\n  }\n\n  const value =\n    (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null ||\n    _fieldNodeMap$keys$ === void 0\n      ? void 0\n      : _fieldNodeMap$keys$.value;\n  const isNullLiteral = !value || value.kind === Kind.NULL;\n  const isVariable =\n    (value === null || value === void 0 ? void 0 : value.kind) ===\n    Kind.VARIABLE;\n\n  if (isNullLiteral) {\n    context.reportError(\n      new GraphQLError(`Field \"${type.name}.${keys[0]}\" must be non-null.`, {\n        nodes: [node],\n      }),\n    );\n    return;\n  }\n\n  if (isVariable) {\n    const variableName = value.name.value;\n    const definition = variableDefinitions[variableName];\n    const isNullableVariable = definition.type.kind !== Kind.NON_NULL_TYPE;\n\n    if (isNullableVariable) {\n      context.reportError(\n        new GraphQLError(\n          `Variable \"${variableName}\" must be non-nullable to be used for OneOf Input Object \"${type.name}\".`,\n          {\n            nodes: [node],\n          },\n        ),\n      );\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2263, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isInputType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n *\n * See https://spec.graphql.org/draft/#sec-Variables-Are-Input-Types\n */\nexport function VariablesAreInputTypesRule(context) {\n  return {\n    VariableDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.type);\n\n      if (type !== undefined && !isInputType(type)) {\n        const variableName = node.variable.name.value;\n        const typeName = print(node.type);\n        context.reportError(\n          new GraphQLError(\n            `Variable \"$${variableName}\" cannot be non-input type \"${typeName}\".`,\n            {\n              nodes: node.type,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AAUO,SAAS,2BAA2B,OAAO;IAChD,OAAO;QACL,oBAAmB,IAAI;YACrB,MAAM,OAAO,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,SAAS,IAAI,KAAK,IAAI;YAEvD,IAAI,SAAS,aAAa,CAAC,CAAA,GAAA,gJAAA,CAAA,cAAW,AAAD,EAAE,OAAO;gBAC5C,MAAM,eAAe,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK;gBAC7C,MAAM,WAAW,CAAA,GAAA,iJAAA,CAAA,QAAK,AAAD,EAAE,KAAK,IAAI;gBAChC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,WAAW,EAAE,aAAa,4BAA4B,EAAE,SAAS,EAAE,CAAC,EACrE;oBACE,OAAO,KAAK,IAAI;gBAClB;YAGN;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2292, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport {\n  isInputObjectType,\n  isNonNullType,\n  isNullableType,\n} from '../../type/definition.mjs';\nimport { isTypeSubTypeOf } from '../../utilities/typeComparators.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Variables in allowed position\n *\n * Variable usages must be compatible with the arguments they are passed to.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Usages-are-Allowed\n */\nexport function VariablesInAllowedPositionRule(context) {\n  let varDefMap = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        varDefMap = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node, type, defaultValue, parentType } of usages) {\n          const varName = node.name.value;\n          const varDef = varDefMap[varName];\n\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            const schema = context.getSchema();\n            const varType = typeFromAST(schema, varDef.type);\n\n            if (\n              varType &&\n              !allowedVariableUsage(\n                schema,\n                varType,\n                varDef.defaultValue,\n                type,\n                defaultValue,\n              )\n            ) {\n              const varTypeStr = inspect(varType);\n              const typeStr = inspect(type);\n              context.reportError(\n                new GraphQLError(\n                  `Variable \"$${varName}\" of type \"${varTypeStr}\" used in position expecting type \"${typeStr}\".`,\n                  {\n                    nodes: [varDef, node],\n                  },\n                ),\n              );\n            }\n\n            if (\n              isInputObjectType(parentType) &&\n              parentType.isOneOf &&\n              isNullableType(varType)\n            ) {\n              context.reportError(\n                new GraphQLError(\n                  `Variable \"$${varName}\" is of type \"${varType}\" but must be non-nullable to be used for OneOf Input Object \"${parentType}\".`,\n                  {\n                    nodes: [varDef, node],\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    },\n  };\n}\n/**\n * Returns true if the variable is allowed in the location it was found,\n * which includes considering if default values exist for either the variable\n * or the location at which it is located.\n */\n\nfunction allowedVariableUsage(\n  schema,\n  varType,\n  varDefaultValue,\n  locationType,\n  locationDefaultValue,\n) {\n  if (isNonNullType(locationType) && !isNonNullType(varType)) {\n    const hasNonNullVariableDefaultValue =\n      varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;\n    const hasLocationDefaultValue = locationDefaultValue !== undefined;\n\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n\n    const nullableLocationType = locationType.ofType;\n    return isTypeSubTypeOf(schema, varType, nullableLocationType);\n  }\n\n  return isTypeSubTypeOf(schema, varType, locationType);\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AAKA;AACA;;;;;;;AASO,SAAS,+BAA+B,OAAO;IACpD,IAAI,YAAY,OAAO,MAAM,CAAC;IAC9B,OAAO;QACL,qBAAqB;YACnB;gBACE,YAAY,OAAO,MAAM,CAAC;YAC5B;YAEA,OAAM,SAAS;gBACb,MAAM,SAAS,QAAQ,0BAA0B,CAAC;gBAElD,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,EAAE,UAAU,EAAE,IAAI,OAAQ;oBAC7D,MAAM,UAAU,KAAK,IAAI,CAAC,KAAK;oBAC/B,MAAM,SAAS,SAAS,CAAC,QAAQ;oBAEjC,IAAI,UAAU,MAAM;wBAClB,kEAAkE;wBAClE,iEAAiE;wBACjE,oEAAoE;wBACpE,oEAAoE;wBACpE,+CAA+C;wBAC/C,MAAM,SAAS,QAAQ,SAAS;wBAChC,MAAM,UAAU,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE,QAAQ,OAAO,IAAI;wBAE/C,IACE,WACA,CAAC,qBACC,QACA,SACA,OAAO,YAAY,EACnB,MACA,eAEF;4BACA,MAAM,aAAa,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;4BAC3B,MAAM,UAAU,CAAA,GAAA,gJAAA,CAAA,UAAO,AAAD,EAAE;4BACxB,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,WAAW,EAAE,QAAQ,WAAW,EAAE,WAAW,mCAAmC,EAAE,QAAQ,EAAE,CAAC,EAC9F;gCACE,OAAO;oCAAC;oCAAQ;iCAAK;4BACvB;wBAGN;wBAEA,IACE,CAAA,GAAA,gJAAA,CAAA,oBAAiB,AAAD,EAAE,eAClB,WAAW,OAAO,IAClB,CAAA,GAAA,gJAAA,CAAA,iBAAc,AAAD,EAAE,UACf;4BACA,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,WAAW,EAAE,QAAQ,cAAc,EAAE,QAAQ,8DAA8D,EAAE,WAAW,EAAE,CAAC,EAC5H;gCACE,OAAO;oCAAC;oCAAQ;iCAAK;4BACvB;wBAGN;oBACF;gBACF;YACF;QACF;QAEA,oBAAmB,IAAI;YACrB,SAAS,CAAC,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG;QACxC;IACF;AACF;AACA;;;;CAIC,GAED,SAAS,qBACP,MAAM,EACN,OAAO,EACP,eAAe,EACf,YAAY,EACZ,oBAAoB;IAEpB,IAAI,CAAA,GAAA,gJAAA,CAAA,gBAAa,AAAD,EAAE,iBAAiB,CAAC,CAAA,GAAA,gJAAA,CAAA,gBAAa,AAAD,EAAE,UAAU;QAC1D,MAAM,iCACJ,mBAAmB,QAAQ,gBAAgB,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,IAAI;QAC/D,MAAM,0BAA0B,yBAAyB;QAEzD,IAAI,CAAC,kCAAkC,CAAC,yBAAyB;YAC/D,OAAO;QACT;QAEA,MAAM,uBAAuB,aAAa,MAAM;QAChD,OAAO,CAAA,GAAA,0JAAA,CAAA,kBAAe,AAAD,EAAE,QAAQ,SAAS;IAC1C;IAEA,OAAO,CAAA,GAAA,0JAAA,CAAA,kBAAe,AAAD,EAAE,QAAQ,SAAS;AAC1C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2374, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/specifiedRules.mjs"],"sourcesContent":["// Spec Section: \"Executable Definitions\"\nimport { ExecutableDefinitionsRule } from './rules/ExecutableDefinitionsRule.mjs'; // Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n\nimport { FieldsOnCorrectTypeRule } from './rules/FieldsOnCorrectTypeRule.mjs'; // Spec Section: \"Fragments on Composite Types\"\n\nimport { FragmentsOnCompositeTypesRule } from './rules/FragmentsOnCompositeTypesRule.mjs'; // Spec Section: \"Argument Names\"\n\nimport {\n  KnownArgumentNamesOnDirectivesRule,\n  KnownArgumentNamesRule,\n} from './rules/KnownArgumentNamesRule.mjs'; // Spec Section: \"Directives Are Defined\"\n\nimport { KnownDirectivesRule } from './rules/KnownDirectivesRule.mjs'; // Spec Section: \"Fragment spread target defined\"\n\nimport { KnownFragmentNamesRule } from './rules/KnownFragmentNamesRule.mjs'; // Spec Section: \"Fragment Spread Type Existence\"\n\nimport { KnownTypeNamesRule } from './rules/KnownTypeNamesRule.mjs'; // Spec Section: \"Lone Anonymous Operation\"\n\nimport { LoneAnonymousOperationRule } from './rules/LoneAnonymousOperationRule.mjs'; // SDL-specific validation rules\n\nimport { LoneSchemaDefinitionRule } from './rules/LoneSchemaDefinitionRule.mjs'; // TODO: Spec Section\n\nimport { MaxIntrospectionDepthRule } from './rules/MaxIntrospectionDepthRule.mjs'; // Spec Section: \"Fragments must not form cycles\"\n\nimport { NoFragmentCyclesRule } from './rules/NoFragmentCyclesRule.mjs'; // Spec Section: \"All Variable Used Defined\"\n\nimport { NoUndefinedVariablesRule } from './rules/NoUndefinedVariablesRule.mjs'; // Spec Section: \"Fragments must be used\"\n\nimport { NoUnusedFragmentsRule } from './rules/NoUnusedFragmentsRule.mjs'; // Spec Section: \"All Variables Used\"\n\nimport { NoUnusedVariablesRule } from './rules/NoUnusedVariablesRule.mjs'; // Spec Section: \"Field Selection Merging\"\n\nimport { OverlappingFieldsCanBeMergedRule } from './rules/OverlappingFieldsCanBeMergedRule.mjs'; // Spec Section: \"Fragment spread is possible\"\n\nimport { PossibleFragmentSpreadsRule } from './rules/PossibleFragmentSpreadsRule.mjs';\nimport { PossibleTypeExtensionsRule } from './rules/PossibleTypeExtensionsRule.mjs'; // Spec Section: \"Argument Optionality\"\n\nimport {\n  ProvidedRequiredArgumentsOnDirectivesRule,\n  ProvidedRequiredArgumentsRule,\n} from './rules/ProvidedRequiredArgumentsRule.mjs'; // Spec Section: \"Leaf Field Selections\"\n\nimport { ScalarLeafsRule } from './rules/ScalarLeafsRule.mjs'; // Spec Section: \"Subscriptions with Single Root Field\"\n\nimport { SingleFieldSubscriptionsRule } from './rules/SingleFieldSubscriptionsRule.mjs';\nimport { UniqueArgumentDefinitionNamesRule } from './rules/UniqueArgumentDefinitionNamesRule.mjs'; // Spec Section: \"Argument Uniqueness\"\n\nimport { UniqueArgumentNamesRule } from './rules/UniqueArgumentNamesRule.mjs';\nimport { UniqueDirectiveNamesRule } from './rules/UniqueDirectiveNamesRule.mjs'; // Spec Section: \"Directives Are Unique Per Location\"\n\nimport { UniqueDirectivesPerLocationRule } from './rules/UniqueDirectivesPerLocationRule.mjs';\nimport { UniqueEnumValueNamesRule } from './rules/UniqueEnumValueNamesRule.mjs';\nimport { UniqueFieldDefinitionNamesRule } from './rules/UniqueFieldDefinitionNamesRule.mjs'; // Spec Section: \"Fragment Name Uniqueness\"\n\nimport { UniqueFragmentNamesRule } from './rules/UniqueFragmentNamesRule.mjs'; // Spec Section: \"Input Object Field Uniqueness\"\n\nimport { UniqueInputFieldNamesRule } from './rules/UniqueInputFieldNamesRule.mjs'; // Spec Section: \"Operation Name Uniqueness\"\n\nimport { UniqueOperationNamesRule } from './rules/UniqueOperationNamesRule.mjs';\nimport { UniqueOperationTypesRule } from './rules/UniqueOperationTypesRule.mjs';\nimport { UniqueTypeNamesRule } from './rules/UniqueTypeNamesRule.mjs'; // Spec Section: \"Variable Uniqueness\"\n\nimport { UniqueVariableNamesRule } from './rules/UniqueVariableNamesRule.mjs'; // Spec Section: \"Value Type Correctness\"\n\nimport { ValuesOfCorrectTypeRule } from './rules/ValuesOfCorrectTypeRule.mjs'; // Spec Section: \"Variables are Input Types\"\n\nimport { VariablesAreInputTypesRule } from './rules/VariablesAreInputTypesRule.mjs'; // Spec Section: \"All Variable Usages Are Allowed\"\n\nimport { VariablesInAllowedPositionRule } from './rules/VariablesInAllowedPositionRule.mjs';\n\n/**\n * Technically these aren't part of the spec but they are strongly encouraged\n * validation rules.\n */\nexport const recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n *\n * The order of the rules in this list has been adjusted to lead to the\n * most clear output when encountering multiple validation errors.\n */\n\nexport const specifiedRules = Object.freeze([\n  ExecutableDefinitionsRule,\n  UniqueOperationNamesRule,\n  LoneAnonymousOperationRule,\n  SingleFieldSubscriptionsRule,\n  KnownTypeNamesRule,\n  FragmentsOnCompositeTypesRule,\n  VariablesAreInputTypesRule,\n  ScalarLeafsRule,\n  FieldsOnCorrectTypeRule,\n  UniqueFragmentNamesRule,\n  KnownFragmentNamesRule,\n  NoUnusedFragmentsRule,\n  PossibleFragmentSpreadsRule,\n  NoFragmentCyclesRule,\n  UniqueVariableNamesRule,\n  NoUndefinedVariablesRule,\n  NoUnusedVariablesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  KnownArgumentNamesRule,\n  UniqueArgumentNamesRule,\n  ValuesOfCorrectTypeRule,\n  ProvidedRequiredArgumentsRule,\n  VariablesInAllowedPositionRule,\n  OverlappingFieldsCanBeMergedRule,\n  UniqueInputFieldNamesRule,\n  ...recommendedRules,\n]);\n/**\n * @internal\n */\n\nexport const specifiedSDLRules = Object.freeze([\n  LoneSchemaDefinitionRule,\n  UniqueOperationTypesRule,\n  UniqueTypeNamesRule,\n  UniqueEnumValueNamesRule,\n  UniqueFieldDefinitionNamesRule,\n  UniqueArgumentDefinitionNamesRule,\n  UniqueDirectiveNamesRule,\n  KnownTypeNamesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  PossibleTypeExtensionsRule,\n  KnownArgumentNamesOnDirectivesRule,\n  UniqueArgumentNamesRule,\n  UniqueInputFieldNamesRule,\n  ProvidedRequiredArgumentsOnDirectivesRule,\n]);\n"],"names":[],"mappings":"AAAA,yCAAyC;;;;;;AACzC,wTAAmF,4EAA4E;AAE/J,oTAA+E,+CAA+C;AAE9H,gUAA2F,iCAAiC;AAE5H,kTAG6C,yCAAyC;AAEtF,4SAAuE,iDAAiD;AAExH,kTAA6E,iDAAiD;AAE9H,0SAAqE,2CAA2C;AAEhH,0TAAqF,gCAAgC;AAErH,sTAAiF,qBAAqB;AAEtG,wTAAmF,iDAAiD;AAEpI,8SAAyE,4CAA4C;AAErH,sTAAiF,yCAAyC;AAE1H,gTAA2E,qCAAqC;AAEhH,gTAA2E,0CAA0C;AAErH,sUAAiG,8CAA8C;AAE/I;AACA,0TAAqF,uCAAuC;AAE5H,gUAGoD,wCAAwC;AAE5F,oSAA+D,uDAAuD;AAEtH;AACA,wUAAmG,sCAAsC;AAEzI;AACA,sTAAiF,qDAAqD;AAEtI;AACA;AACA,kUAA6F,2CAA2C;AAExI,oTAA+E,gDAAgD;AAE/H,wTAAmF,4CAA4C;AAE/H;AACA;AACA,4SAAuE,sCAAsC;AAE7G,oTAA+E,yCAAyC;AAExH,oTAA+E,4CAA4C;AAE3H,0TAAqF,kDAAkD;AAEvI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMO,MAAM,mBAAmB,OAAO,MAAM,CAAC;IAAC,8KAAA,CAAA,4BAAyB;CAAC;AAQlE,MAAM,iBAAiB,OAAO,MAAM,CAAC;IAC1C,8KAAA,CAAA,4BAAyB;IACzB,6KAAA,CAAA,2BAAwB;IACxB,+KAAA,CAAA,6BAA0B;IAC1B,iLAAA,CAAA,+BAA4B;IAC5B,uKAAA,CAAA,qBAAkB;IAClB,kLAAA,CAAA,gCAA6B;IAC7B,+KAAA,CAAA,6BAA0B;IAC1B,oKAAA,CAAA,kBAAe;IACf,4KAAA,CAAA,0BAAuB;IACvB,4KAAA,CAAA,0BAAuB;IACvB,2KAAA,CAAA,yBAAsB;IACtB,0KAAA,CAAA,wBAAqB;IACrB,gLAAA,CAAA,8BAA2B;IAC3B,yKAAA,CAAA,uBAAoB;IACpB,4KAAA,CAAA,0BAAuB;IACvB,6KAAA,CAAA,2BAAwB;IACxB,0KAAA,CAAA,wBAAqB;IACrB,wKAAA,CAAA,sBAAmB;IACnB,oLAAA,CAAA,kCAA+B;IAC/B,2KAAA,CAAA,yBAAsB;IACtB,4KAAA,CAAA,0BAAuB;IACvB,4KAAA,CAAA,0BAAuB;IACvB,kLAAA,CAAA,gCAA6B;IAC7B,mLAAA,CAAA,iCAA8B;IAC9B,qLAAA,CAAA,mCAAgC;IAChC,8KAAA,CAAA,4BAAyB;OACtB;CACJ;AAKM,MAAM,oBAAoB,OAAO,MAAM,CAAC;IAC7C,6KAAA,CAAA,2BAAwB;IACxB,6KAAA,CAAA,2BAAwB;IACxB,wKAAA,CAAA,sBAAmB;IACnB,6KAAA,CAAA,2BAAwB;IACxB,mLAAA,CAAA,iCAA8B;IAC9B,sLAAA,CAAA,oCAAiC;IACjC,6KAAA,CAAA,2BAAwB;IACxB,uKAAA,CAAA,qBAAkB;IAClB,wKAAA,CAAA,sBAAmB;IACnB,oLAAA,CAAA,kCAA+B;IAC/B,+KAAA,CAAA,6BAA0B;IAC1B,2KAAA,CAAA,qCAAkC;IAClC,4KAAA,CAAA,0BAAuB;IACvB,8KAAA,CAAA,4BAAyB;IACzB,kLAAA,CAAA,4CAAyC;CAC1C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2503, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/ValidationContext.mjs"],"sourcesContent":["import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport class ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while ((set = setsToVisit.pop())) {\n        for (const selection of set.selections) {\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while ((node = nodesToVisit.pop())) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n}\nexport class SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n}\nexport class ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new TypeInfo(this._schema);\n      visit(\n        node,\n        visitWithTypeInfo(typeInfo, {\n          VariableDefinition: () => false,\n\n          Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue(),\n              parentType: typeInfo.getParentInputType(),\n            });\n          },\n        }),\n      );\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2681, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/validate.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { visit, visitInParallel } from '../language/visitor.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules.mjs';\nimport {\n  SDLValidationContext,\n  ValidationContext,\n} from './ValidationContext.mjs';\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Validate will stop validation after a `maxErrors` limit has been reached.\n * Attackers can send pathologically invalid queries to induce a DoS attack,\n * so by default `maxErrors` set to 100 errors.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(\n  schema,\n  documentAST,\n  rules = specifiedRules,\n  options,\n  /** @deprecated will be removed in 17.0.0 */\n  typeInfo = new TypeInfo(schema),\n) {\n  var _options$maxErrors;\n\n  const maxErrors =\n    (_options$maxErrors =\n      options === null || options === void 0 ? void 0 : options.maxErrors) !==\n      null && _options$maxErrors !== void 0\n      ? _options$maxErrors\n      : 100;\n  documentAST || devAssert(false, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  const abortObj = Object.freeze({});\n  const errors = [];\n  const context = new ValidationContext(\n    schema,\n    documentAST,\n    typeInfo,\n    (error) => {\n      if (errors.length >= maxErrors) {\n        errors.push(\n          new GraphQLError(\n            'Too many validation errors, error limit reached. Validation aborted.',\n          ),\n        ); // eslint-disable-next-line @typescript-eslint/no-throw-literal\n\n        throw abortObj;\n      }\n\n      errors.push(error);\n    },\n  ); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  const visitor = visitInParallel(rules.map((rule) => rule(context))); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(\n  documentAST,\n  schemaToExtend,\n  rules = specifiedSDLRules,\n) {\n  const errors = [];\n  const context = new SDLValidationContext(\n    documentAST,\n    schemaToExtend,\n    (error) => {\n      errors.push(error);\n    },\n  );\n  const visitors = rules.map((rule) => rule(context));\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  const errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  const errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAyBO,SAAS,SACd,MAAM,EACN,WAAW,EACX,QAAQ,0JAAA,CAAA,iBAAc,EACtB,OAAO,EACP,0CAA0C,GAC1C,WAAW,IAAI,mJAAA,CAAA,WAAQ,CAAC,OAAO;IAE/B,IAAI;IAEJ,MAAM,YACJ,CAAC,qBACC,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,SAAS,MACnE,QAAQ,uBAAuB,KAAK,IAClC,qBACA;IACN,eAAe,CAAA,GAAA,kJAAA,CAAA,YAAS,AAAD,EAAE,OAAO,2BAA2B,gEAAgE;IAE3H,CAAA,GAAA,8IAAA,CAAA,oBAAiB,AAAD,EAAE;IAClB,MAAM,WAAW,OAAO,MAAM,CAAC,CAAC;IAChC,MAAM,SAAS,EAAE;IACjB,MAAM,UAAU,IAAI,6JAAA,CAAA,oBAAiB,CACnC,QACA,aACA,UACA,CAAC;QACC,IAAI,OAAO,MAAM,IAAI,WAAW;YAC9B,OAAO,IAAI,CACT,IAAI,mJAAA,CAAA,eAAY,CACd,0EAED,+DAA+D;YAElE,MAAM;QACR;QAEA,OAAO,IAAI,CAAC;IACd,IACC,4EAA4E;IAC/E,oDAAoD;IAEpD,MAAM,UAAU,CAAA,GAAA,iJAAA,CAAA,kBAAe,AAAD,EAAE,MAAM,GAAG,CAAC,CAAC,OAAS,KAAK,YAAY,qEAAqE;IAE1I,IAAI;QACF,CAAA,GAAA,iJAAA,CAAA,QAAK,AAAD,EAAE,aAAa,CAAA,GAAA,mJAAA,CAAA,oBAAiB,AAAD,EAAE,UAAU;IACjD,EAAE,OAAO,GAAG;QACV,IAAI,MAAM,UAAU;YAClB,MAAM;QACR;IACF;IAEA,OAAO;AACT;AAKO,SAAS,YACd,WAAW,EACX,cAAc,EACd,QAAQ,0JAAA,CAAA,oBAAiB;IAEzB,MAAM,SAAS,EAAE;IACjB,MAAM,UAAU,IAAI,6JAAA,CAAA,uBAAoB,CACtC,aACA,gBACA,CAAC;QACC,OAAO,IAAI,CAAC;IACd;IAEF,MAAM,WAAW,MAAM,GAAG,CAAC,CAAC,OAAS,KAAK;IAC1C,CAAA,GAAA,iJAAA,CAAA,QAAK,AAAD,EAAE,aAAa,CAAA,GAAA,iJAAA,CAAA,kBAAe,AAAD,EAAE;IACnC,OAAO;AACT;AAQO,SAAS,eAAe,WAAW;IACxC,MAAM,SAAS,YAAY;IAE3B,IAAI,OAAO,MAAM,KAAK,GAAG;QACvB,MAAM,IAAI,MAAM,OAAO,GAAG,CAAC,CAAC,QAAU,MAAM,OAAO,EAAE,IAAI,CAAC;IAC5D;AACF;AAQO,SAAS,wBAAwB,WAAW,EAAE,MAAM;IACzD,MAAM,SAAS,YAAY,aAAa;IAExC,IAAI,OAAO,MAAM,KAAK,GAAG;QACvB,MAAM,IAAI,MAAM,OAAO,GAAG,CAAC,CAAC,QAAU,MAAM,OAAO,EAAE,IAAI,CAAC;IAC5D;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2751, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs"],"sourcesContent":["import { invariant } from '../../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType, isInputObjectType } from '../../../type/definition.mjs';\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field(node) {\n      const fieldDef = context.getFieldDef();\n      const deprecationReason =\n        fieldDef === null || fieldDef === void 0\n          ? void 0\n          : fieldDef.deprecationReason;\n\n      if (fieldDef && deprecationReason != null) {\n        const parentType = context.getParentType();\n        parentType != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    Argument(node) {\n      const argDef = context.getArgument();\n      const deprecationReason =\n        argDef === null || argDef === void 0\n          ? void 0\n          : argDef.deprecationReason;\n\n      if (argDef && deprecationReason != null) {\n        const directiveDef = context.getDirective();\n\n        if (directiveDef != null) {\n          context.reportError(\n            new GraphQLError(\n              `Directive \"@${directiveDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        } else {\n          const parentType = context.getParentType();\n          const fieldDef = context.getFieldDef();\n          (parentType != null && fieldDef != null) || invariant(false);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${parentType.name}.${fieldDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const inputObjectDef = getNamedType(context.getParentInputType());\n\n      if (isInputObjectType(inputObjectDef)) {\n        const inputFieldDef = inputObjectDef.getFields()[node.name.value];\n        const deprecationReason =\n          inputFieldDef === null || inputFieldDef === void 0\n            ? void 0\n            : inputFieldDef.deprecationReason;\n\n        if (deprecationReason != null) {\n          context.reportError(\n            new GraphQLError(\n              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    EnumValue(node) {\n      const enumValueDef = context.getEnumValue();\n      const deprecationReason =\n        enumValueDef === null || enumValueDef === void 0\n          ? void 0\n          : enumValueDef.deprecationReason;\n\n      if (enumValueDef && deprecationReason != null) {\n        const enumTypeDef = getNamedType(context.getInputType());\n        enumTypeDef != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The enum value \"${enumTypeDef.name}.${enumValueDef.name}\" is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAYO,SAAS,uBAAuB,OAAO;IAC5C,OAAO;QACL,OAAM,IAAI;YACR,MAAM,WAAW,QAAQ,WAAW;YACpC,MAAM,oBACJ,aAAa,QAAQ,aAAa,KAAK,IACnC,KAAK,IACL,SAAS,iBAAiB;YAEhC,IAAI,YAAY,qBAAqB,MAAM;gBACzC,MAAM,aAAa,QAAQ,aAAa;gBACxC,cAAc,QAAQ,CAAA,GAAA,kJAAA,CAAA,YAAS,AAAD,EAAE;gBAChC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,UAAU,EAAE,WAAW,IAAI,CAAC,CAAC,EAAE,SAAS,IAAI,CAAC,gBAAgB,EAAE,mBAAmB,EACnF;oBACE,OAAO;gBACT;YAGN;QACF;QAEA,UAAS,IAAI;YACX,MAAM,SAAS,QAAQ,WAAW;YAClC,MAAM,oBACJ,WAAW,QAAQ,WAAW,KAAK,IAC/B,KAAK,IACL,OAAO,iBAAiB;YAE9B,IAAI,UAAU,qBAAqB,MAAM;gBACvC,MAAM,eAAe,QAAQ,YAAY;gBAEzC,IAAI,gBAAgB,MAAM;oBACxB,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,YAAY,EAAE,aAAa,IAAI,CAAC,YAAY,EAAE,OAAO,IAAI,CAAC,iBAAiB,EAAE,mBAAmB,EACjG;wBACE,OAAO;oBACT;gBAGN,OAAO;oBACL,MAAM,aAAa,QAAQ,aAAa;oBACxC,MAAM,WAAW,QAAQ,WAAW;oBACnC,cAAc,QAAQ,YAAY,QAAS,CAAA,GAAA,kJAAA,CAAA,YAAS,AAAD,EAAE;oBACtD,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,OAAO,EAAE,WAAW,IAAI,CAAC,CAAC,EAAE,SAAS,IAAI,CAAC,YAAY,EAAE,OAAO,IAAI,CAAC,iBAAiB,EAAE,mBAAmB,EAC3G;wBACE,OAAO;oBACT;gBAGN;YACF;QACF;QAEA,aAAY,IAAI;YACd,MAAM,iBAAiB,CAAA,GAAA,gJAAA,CAAA,eAAY,AAAD,EAAE,QAAQ,kBAAkB;YAE9D,IAAI,CAAA,GAAA,gJAAA,CAAA,oBAAiB,AAAD,EAAE,iBAAiB;gBACrC,MAAM,gBAAgB,eAAe,SAAS,EAAE,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC;gBACjE,MAAM,oBACJ,kBAAkB,QAAQ,kBAAkB,KAAK,IAC7C,KAAK,IACL,cAAc,iBAAiB;gBAErC,IAAI,qBAAqB,MAAM;oBAC7B,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,gBAAgB,EAAE,eAAe,IAAI,CAAC,CAAC,EAAE,cAAc,IAAI,CAAC,gBAAgB,EAAE,mBAAmB,EAClG;wBACE,OAAO;oBACT;gBAGN;YACF;QACF;QAEA,WAAU,IAAI;YACZ,MAAM,eAAe,QAAQ,YAAY;YACzC,MAAM,oBACJ,iBAAiB,QAAQ,iBAAiB,KAAK,IAC3C,KAAK,IACL,aAAa,iBAAiB;YAEpC,IAAI,gBAAgB,qBAAqB,MAAM;gBAC7C,MAAM,cAAc,CAAA,GAAA,gJAAA,CAAA,eAAY,AAAD,EAAE,QAAQ,YAAY;gBACrD,eAAe,QAAQ,CAAA,GAAA,kJAAA,CAAA,YAAS,AAAD,EAAE;gBACjC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,gBAAgB,EAAE,YAAY,IAAI,CAAC,CAAC,EAAE,aAAa,IAAI,CAAC,iBAAiB,EAAE,mBAAmB,EAC/F;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2821, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType } from '../../../type/definition.mjs';\nimport { isIntrospectionType } from '../../../type/introspection.mjs';\n\n/**\n * Prohibit introspection queries\n *\n * A GraphQL document is only valid if all fields selected are not fields that\n * return an introspection type.\n *\n * Note: This rule is optional and is not part of the Validation section of the\n * GraphQL Specification. This rule effectively disables introspection, which\n * does not reflect best practices and should only be done if absolutely necessary.\n */\nexport function NoSchemaIntrospectionCustomRule(context) {\n  return {\n    Field(node) {\n      const type = getNamedType(context.getType());\n\n      if (type && isIntrospectionType(type)) {\n        context.reportError(\n          new GraphQLError(\n            `GraphQL introspection has been disabled, but the requested query contained the field \"${node.name.value}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAYO,SAAS,gCAAgC,OAAO;IACrD,OAAO;QACL,OAAM,IAAI;YACR,MAAM,OAAO,CAAA,GAAA,gJAAA,CAAA,eAAY,AAAD,EAAE,QAAQ,OAAO;YAEzC,IAAI,QAAQ,CAAA,GAAA,mJAAA,CAAA,sBAAmB,AAAD,EAAE,OAAO;gBACrC,QAAQ,WAAW,CACjB,IAAI,mJAAA,CAAA,eAAY,CACd,CAAC,sFAAsF,EAAE,KAAK,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAC5G;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2848, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.ExecutableDefinitionsRule = ExecutableDefinitionsRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _predicates = require('../../language/predicates.js');\n\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n *\n * See https://spec.graphql.org/draft/#sec-Executable-Definitions\n */\nfunction ExecutableDefinitionsRule(context) {\n  return {\n    Document(node) {\n      for (const definition of node.definitions) {\n        if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {\n          const defName =\n            definition.kind === _kinds.Kind.SCHEMA_DEFINITION ||\n            definition.kind === _kinds.Kind.SCHEMA_EXTENSION\n              ? 'schema'\n              : '\"' + definition.name.value + '\"';\n          context.reportError(\n            new _GraphQLError.GraphQLError(\n              `The ${defName} definition is not executable.`,\n              {\n                nodes: definition,\n              },\n            ),\n          );\n        }\n      }\n\n      return false;\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,yBAAyB,GAAG;AAEpC,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;;;CAOC,GACD,SAAS,0BAA0B,OAAO;IACxC,OAAO;QACL,UAAS,IAAI;YACX,KAAK,MAAM,cAAc,KAAK,WAAW,CAAE;gBACzC,IAAI,CAAC,CAAC,GAAG,YAAY,0BAA0B,EAAE,aAAa;oBAC5D,MAAM,UACJ,WAAW,IAAI,KAAK,OAAO,IAAI,CAAC,iBAAiB,IACjD,WAAW,IAAI,KAAK,OAAO,IAAI,CAAC,gBAAgB,GAC5C,WACA,MAAM,WAAW,IAAI,CAAC,KAAK,GAAG;oBACpC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,IAAI,EAAE,QAAQ,8BAA8B,CAAC,EAC9C;wBACE,OAAO;oBACT;gBAGN;YACF;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2883, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _naturalCompare = require('../../jsutils/naturalCompare.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _definition = require('../../type/definition.js');\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selections\n */\nfunction FieldsOnCorrectTypeRule(context) {\n  return {\n    Field(node) {\n      const type = context.getParentType();\n\n      if (type) {\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          const schema = context.getSchema();\n          const fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          let suggestion = (0, _didYouMean.didYouMean)(\n            'to use an inline fragment on',\n            getSuggestedTypeNames(schema, type, fieldName),\n          ); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = (0, _didYouMean.didYouMean)(\n              getSuggestedFieldNames(type, fieldName),\n            );\n          } // Report an error, including helpful suggestions.\n\n          context.reportError(\n            new _GraphQLError.GraphQLError(\n              `Cannot query field \"${fieldName}\" on type \"${type.name}\".` +\n                suggestion,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!(0, _definition.isAbstractType)(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  const suggestedTypes = new Set();\n  const usageCount = Object.create(null);\n\n  for (const possibleType of schema.getPossibleTypes(type)) {\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (const possibleInterface of possibleType.getInterfaces()) {\n      var _usageCount$possibleI;\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] =\n        ((_usageCount$possibleI = usageCount[possibleInterface.name]) !==\n          null && _usageCount$possibleI !== void 0\n          ? _usageCount$possibleI\n          : 0) + 1;\n    }\n  }\n\n  return [...suggestedTypes]\n    .sort((typeA, typeB) => {\n      // Suggest both interface and object types based on how common they are.\n      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n      if (usageCountDiff !== 0) {\n        return usageCountDiff;\n      } // Suggest super types first followed by subtypes\n\n      if (\n        (0, _definition.isInterfaceType)(typeA) &&\n        schema.isSubType(typeA, typeB)\n      ) {\n        return -1;\n      }\n\n      if (\n        (0, _definition.isInterfaceType)(typeB) &&\n        schema.isSubType(typeB, typeA)\n      ) {\n        return 1;\n      }\n\n      return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);\n    })\n    .map((x) => x.name);\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (\n    (0, _definition.isObjectType)(type) ||\n    (0, _definition.isInterfaceType)(type)\n  ) {\n    const possibleFieldNames = Object.keys(type.getFields());\n    return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n  return [];\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2980, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _printer = require('../../language/printer.js');\n\nvar _definition = require('../../type/definition.js');\n\nvar _typeFromAST = require('../../utilities/typeFromAST.js');\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-On-Composite-Types\n */\nfunction FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment(node) {\n      const typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        const type = (0, _typeFromAST.typeFromAST)(\n          context.getSchema(),\n          typeCondition,\n        );\n\n        if (type && !(0, _definition.isCompositeType)(type)) {\n          const typeStr = (0, _printer.print)(typeCondition);\n          context.reportError(\n            new _GraphQLError.GraphQLError(\n              `Fragment cannot condition on non composite type \"${typeStr}\".`,\n              {\n                nodes: typeCondition,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    FragmentDefinition(node) {\n      const type = (0, _typeFromAST.typeFromAST)(\n        context.getSchema(),\n        node.typeCondition,\n      );\n\n      if (type && !(0, _definition.isCompositeType)(type)) {\n        const typeStr = (0, _printer.print)(node.typeCondition);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Fragment \"${node.name.value}\" cannot condition on non composite type \"${typeStr}\".`,\n            {\n              nodes: node.typeCondition,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,6BAA6B,GAAG;AAExC,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;;;;CAQC,GACD,SAAS,8BAA8B,OAAO;IAC5C,OAAO;QACL,gBAAe,IAAI;YACjB,MAAM,gBAAgB,KAAK,aAAa;YAExC,IAAI,eAAe;gBACjB,MAAM,OAAO,CAAC,GAAG,aAAa,WAAW,EACvC,QAAQ,SAAS,IACjB;gBAGF,IAAI,QAAQ,CAAC,CAAC,GAAG,YAAY,eAAe,EAAE,OAAO;oBACnD,MAAM,UAAU,CAAC,GAAG,SAAS,KAAK,EAAE;oBACpC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,iDAAiD,EAAE,QAAQ,EAAE,CAAC,EAC/D;wBACE,OAAO;oBACT;gBAGN;YACF;QACF;QAEA,oBAAmB,IAAI;YACrB,MAAM,OAAO,CAAC,GAAG,aAAa,WAAW,EACvC,QAAQ,SAAS,IACjB,KAAK,aAAa;YAGpB,IAAI,QAAQ,CAAC,CAAC,GAAG,YAAY,eAAe,EAAE,OAAO;gBACnD,MAAM,UAAU,CAAC,GAAG,SAAS,KAAK,EAAE,KAAK,aAAa;gBACtD,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,UAAU,EAAE,KAAK,IAAI,CAAC,KAAK,CAAC,0CAA0C,EAAE,QAAQ,EAAE,CAAC,EACpF;oBACE,OAAO,KAAK,aAAa;gBAC3B;YAGN;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3027, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownArgumentNamesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;\nexports.KnownArgumentNamesRule = KnownArgumentNamesRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _directives = require('../../type/directives.js');\n\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n * See https://spec.graphql.org/draft/#sec-Directives-Are-In-Valid-Locations\n */\nfunction KnownArgumentNamesRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...KnownArgumentNamesOnDirectivesRule(context),\n\n    Argument(argNode) {\n      const argDef = context.getArgument();\n      const fieldDef = context.getFieldDef();\n      const parentType = context.getParentType();\n\n      if (!argDef && fieldDef && parentType) {\n        const argName = argNode.name.value;\n        const knownArgsNames = fieldDef.args.map((arg) => arg.name);\n        const suggestions = (0, _suggestionList.suggestionList)(\n          argName,\n          knownArgsNames,\n        );\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Unknown argument \"${argName}\" on field \"${parentType.name}.${fieldDef.name}\".` +\n              (0, _didYouMean.didYouMean)(suggestions),\n            {\n              nodes: argNode,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n/**\n * @internal\n */\n\nfunction KnownArgumentNamesOnDirectivesRule(context) {\n  const directiveArgs = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : _directives.specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argsNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);\n    }\n  }\n\n  return {\n    Directive(directiveNode) {\n      const directiveName = directiveNode.name.value;\n      const knownArgs = directiveArgs[directiveName];\n\n      if (directiveNode.arguments && knownArgs) {\n        for (const argNode of directiveNode.arguments) {\n          const argName = argNode.name.value;\n\n          if (!knownArgs.includes(argName)) {\n            const suggestions = (0, _suggestionList.suggestionList)(\n              argName,\n              knownArgs,\n            );\n            context.reportError(\n              new _GraphQLError.GraphQLError(\n                `Unknown argument \"${argName}\" on directive \"@${directiveName}\".` +\n                  (0, _didYouMean.didYouMean)(suggestions),\n                {\n                  nodes: argNode,\n                },\n              ),\n            );\n          }\n        }\n      }\n\n      return false;\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,kCAAkC,GAAG;AAC7C,QAAQ,sBAAsB,GAAG;AAEjC,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;;;;CAQC,GACD,SAAS,uBAAuB,OAAO;IACrC,OAAO;QACL,mCAAmC;QACnC,GAAG,mCAAmC,QAAQ;QAE9C,UAAS,OAAO;YACd,MAAM,SAAS,QAAQ,WAAW;YAClC,MAAM,WAAW,QAAQ,WAAW;YACpC,MAAM,aAAa,QAAQ,aAAa;YAExC,IAAI,CAAC,UAAU,YAAY,YAAY;gBACrC,MAAM,UAAU,QAAQ,IAAI,CAAC,KAAK;gBAClC,MAAM,iBAAiB,SAAS,IAAI,CAAC,GAAG,CAAC,CAAC,MAAQ,IAAI,IAAI;gBAC1D,MAAM,cAAc,CAAC,GAAG,gBAAgB,cAAc,EACpD,SACA;gBAEF,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,kBAAkB,EAAE,QAAQ,YAAY,EAAE,WAAW,IAAI,CAAC,CAAC,EAAE,SAAS,IAAI,CAAC,EAAE,CAAC,GAC7E,CAAC,GAAG,YAAY,UAAU,EAAE,cAC9B;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF;AACA;;CAEC,GAED,SAAS,mCAAmC,OAAO;IACjD,MAAM,gBAAgB,OAAO,MAAM,CAAC;IACpC,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,oBAAoB,SACtB,OAAO,aAAa,KACpB,YAAY,mBAAmB;IAEnC,KAAK,MAAM,aAAa,kBAAmB;QACzC,aAAa,CAAC,UAAU,IAAI,CAAC,GAAG,UAAU,IAAI,CAAC,GAAG,CAAC,CAAC,MAAQ,IAAI,IAAI;IACtE;IAEA,MAAM,iBAAiB,QAAQ,WAAW,GAAG,WAAW;IAExD,KAAK,MAAM,OAAO,eAAgB;QAChC,IAAI,IAAI,IAAI,KAAK,OAAO,IAAI,CAAC,oBAAoB,EAAE;YACjD,IAAI;YAEJ,2DAA2D;YAE3D,kBAAkB,GAClB,MAAM,YACJ,CAAC,iBAAiB,IAAI,SAAS,MAAM,QAAQ,mBAAmB,KAAK,IACjE,iBACA,EAAE;YACR,aAAa,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,MAAQ,IAAI,IAAI,CAAC,KAAK;QACvE;IACF;IAEA,OAAO;QACL,WAAU,aAAa;YACrB,MAAM,gBAAgB,cAAc,IAAI,CAAC,KAAK;YAC9C,MAAM,YAAY,aAAa,CAAC,cAAc;YAE9C,IAAI,cAAc,SAAS,IAAI,WAAW;gBACxC,KAAK,MAAM,WAAW,cAAc,SAAS,CAAE;oBAC7C,MAAM,UAAU,QAAQ,IAAI,CAAC,KAAK;oBAElC,IAAI,CAAC,UAAU,QAAQ,CAAC,UAAU;wBAChC,MAAM,cAAc,CAAC,GAAG,gBAAgB,cAAc,EACpD,SACA;wBAEF,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,kBAAkB,EAAE,QAAQ,iBAAiB,EAAE,cAAc,EAAE,CAAC,GAC/D,CAAC,GAAG,YAAY,UAAU,EAAE,cAC9B;4BACE,OAAO;wBACT;oBAGN;gBACF;YACF;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3107, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownDirectivesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.KnownDirectivesRule = KnownDirectivesRule;\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _invariant = require('../../jsutils/invariant.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _ast = require('../../language/ast.js');\n\nvar _directiveLocation = require('../../language/directiveLocation.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _directives = require('../../type/directives.js');\n\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Defined\n */\nfunction KnownDirectivesRule(context) {\n  const locationsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : _directives.specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    locationsMap[directive.name] = directive.locations;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map((name) => name.value);\n    }\n  }\n\n  return {\n    Directive(node, _key, _parent, _path, ancestors) {\n      const name = node.name.value;\n      const locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(`Unknown directive \"@${name}\".`, {\n            nodes: node,\n          }),\n        );\n        return;\n      }\n\n      const candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && !locations.includes(candidateLocation)) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Directive \"@${name}\" may not be used on ${candidateLocation}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  const appliedTo = ancestors[ancestors.length - 1];\n  'kind' in appliedTo || (0, _invariant.invariant)(false);\n\n  switch (appliedTo.kind) {\n    case _kinds.Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n\n    case _kinds.Kind.FIELD:\n      return _directiveLocation.DirectiveLocation.FIELD;\n\n    case _kinds.Kind.FRAGMENT_SPREAD:\n      return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;\n\n    case _kinds.Kind.INLINE_FRAGMENT:\n      return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;\n\n    case _kinds.Kind.FRAGMENT_DEFINITION:\n      return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case _kinds.Kind.VARIABLE_DEFINITION:\n      return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;\n\n    case _kinds.Kind.SCHEMA_DEFINITION:\n    case _kinds.Kind.SCHEMA_EXTENSION:\n      return _directiveLocation.DirectiveLocation.SCHEMA;\n\n    case _kinds.Kind.SCALAR_TYPE_DEFINITION:\n    case _kinds.Kind.SCALAR_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.SCALAR;\n\n    case _kinds.Kind.OBJECT_TYPE_DEFINITION:\n    case _kinds.Kind.OBJECT_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.OBJECT;\n\n    case _kinds.Kind.FIELD_DEFINITION:\n      return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;\n\n    case _kinds.Kind.INTERFACE_TYPE_DEFINITION:\n    case _kinds.Kind.INTERFACE_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.INTERFACE;\n\n    case _kinds.Kind.UNION_TYPE_DEFINITION:\n    case _kinds.Kind.UNION_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.UNION;\n\n    case _kinds.Kind.ENUM_TYPE_DEFINITION:\n    case _kinds.Kind.ENUM_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.ENUM;\n\n    case _kinds.Kind.ENUM_VALUE_DEFINITION:\n      return _directiveLocation.DirectiveLocation.ENUM_VALUE;\n\n    case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return _directiveLocation.DirectiveLocation.INPUT_OBJECT;\n\n    case _kinds.Kind.INPUT_VALUE_DEFINITION: {\n      const parentNode = ancestors[ancestors.length - 3];\n      'kind' in parentNode || (0, _invariant.invariant)(false);\n      return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION\n        ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION\n        : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;\n    }\n    // Not reachable, all possible types have been considered.\n\n    /* c8 ignore next */\n\n    default:\n      false ||\n        (0, _invariant.invariant)(\n          false,\n          'Unexpected kind: ' + (0, _inspect.inspect)(appliedTo.kind),\n        );\n  }\n}\n\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case _ast.OperationTypeNode.QUERY:\n      return _directiveLocation.DirectiveLocation.QUERY;\n\n    case _ast.OperationTypeNode.MUTATION:\n      return _directiveLocation.DirectiveLocation.MUTATION;\n\n    case _ast.OperationTypeNode.SUBSCRIPTION:\n      return _directiveLocation.DirectiveLocation.SUBSCRIPTION;\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3225, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownFragmentNamesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.KnownFragmentNamesRule = KnownFragmentNamesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spread-target-defined\n */\nfunction KnownFragmentNamesRule(context) {\n  return {\n    FragmentSpread(node) {\n      const fragmentName = node.name.value;\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Unknown fragment \"${fragmentName}\".`,\n            {\n              nodes: node.name,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,sBAAsB,GAAG;AAEjC,IAAI;AAEJ;;;;;;;CAOC,GACD,SAAS,uBAAuB,OAAO;IACrC,OAAO;QACL,gBAAe,IAAI;YACjB,MAAM,eAAe,KAAK,IAAI,CAAC,KAAK;YACpC,MAAM,WAAW,QAAQ,WAAW,CAAC;YAErC,IAAI,CAAC,UAAU;gBACb,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,kBAAkB,EAAE,aAAa,EAAE,CAAC,EACrC;oBACE,OAAO,KAAK,IAAI;gBAClB;YAGN;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3256, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/KnownTypeNamesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.KnownTypeNamesRule = KnownTypeNamesRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _predicates = require('../../language/predicates.js');\n\nvar _introspection = require('../../type/introspection.js');\n\nvar _scalars = require('../../type/scalars.js');\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Spread-Type-Existence\n */\nfunction KnownTypeNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  const typeNames = [\n    ...Object.keys(existingTypesMap),\n    ...Object.keys(definedTypes),\n  ];\n  return {\n    NamedType(node, _1, parent, _2, ancestors) {\n      const typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        const definitionNode =\n          (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0\n            ? _ancestors$\n            : parent;\n        const isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && standardTypeNames.includes(typeName)) {\n          return;\n        }\n\n        const suggestedTypes = (0, _suggestionList.suggestionList)(\n          typeName,\n          isSDL ? standardTypeNames.concat(typeNames) : typeNames,\n        );\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Unknown type \"${typeName}\".` +\n              (0, _didYouMean.didYouMean)(suggestedTypes),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nconst standardTypeNames = [\n  ..._scalars.specifiedScalarTypes,\n  ..._introspection.introspectionTypes,\n].map((type) => type.name);\n\nfunction isSDLNode(value) {\n  return (\n    'kind' in value &&\n    ((0, _predicates.isTypeSystemDefinitionNode)(value) ||\n      (0, _predicates.isTypeSystemExtensionNode)(value))\n  );\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,kBAAkB,GAAG;AAE7B,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;;;CAOC,GACD,SAAS,mBAAmB,OAAO;IACjC,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,mBAAmB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACtE,MAAM,eAAe,OAAO,MAAM,CAAC;IAEnC,KAAK,MAAM,OAAO,QAAQ,WAAW,GAAG,WAAW,CAAE;QACnD,IAAI,CAAC,GAAG,YAAY,oBAAoB,EAAE,MAAM;YAC9C,YAAY,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG;QACjC;IACF;IAEA,MAAM,YAAY;WACb,OAAO,IAAI,CAAC;WACZ,OAAO,IAAI,CAAC;KAChB;IACD,OAAO;QACL,WAAU,IAAI,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,SAAS;YACvC,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;YAEhC,IAAI,CAAC,gBAAgB,CAAC,SAAS,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE;gBAC1D,IAAI;gBAEJ,MAAM,iBACJ,CAAC,cAAc,SAAS,CAAC,EAAE,MAAM,QAAQ,gBAAgB,KAAK,IAC1D,cACA;gBACN,MAAM,QAAQ,kBAAkB,QAAQ,UAAU;gBAElD,IAAI,SAAS,kBAAkB,QAAQ,CAAC,WAAW;oBACjD;gBACF;gBAEA,MAAM,iBAAiB,CAAC,GAAG,gBAAgB,cAAc,EACvD,UACA,QAAQ,kBAAkB,MAAM,CAAC,aAAa;gBAEhD,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,cAAc,EAAE,SAAS,EAAE,CAAC,GAC3B,CAAC,GAAG,YAAY,UAAU,EAAE,iBAC9B;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF;AAEA,MAAM,oBAAoB;OACrB,SAAS,oBAAoB;OAC7B,eAAe,kBAAkB;CACrC,CAAC,GAAG,CAAC,CAAC,OAAS,KAAK,IAAI;AAEzB,SAAS,UAAU,KAAK;IACtB,OACE,UAAU,SACV,CAAC,CAAC,GAAG,YAAY,0BAA0B,EAAE,UAC3C,CAAC,GAAG,YAAY,yBAAyB,EAAE,MAAM;AAEvD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3317, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.LoneAnonymousOperationRule = LoneAnonymousOperationRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _kinds = require('../../language/kinds.js');\n\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n *\n * See https://spec.graphql.org/draft/#sec-Lone-Anonymous-Operation\n */\nfunction LoneAnonymousOperationRule(context) {\n  let operationCount = 0;\n  return {\n    Document(node) {\n      operationCount = node.definitions.filter(\n        (definition) => definition.kind === _kinds.Kind.OPERATION_DEFINITION,\n      ).length;\n    },\n\n    OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            'This anonymous operation must be the only defined operation.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,0BAA0B,GAAG;AAErC,IAAI;AAEJ,IAAI;AAEJ;;;;;;;CAOC,GACD,SAAS,2BAA2B,OAAO;IACzC,IAAI,iBAAiB;IACrB,OAAO;QACL,UAAS,IAAI;YACX,iBAAiB,KAAK,WAAW,CAAC,MAAM,CACtC,CAAC,aAAe,WAAW,IAAI,KAAK,OAAO,IAAI,CAAC,oBAAoB,EACpE,MAAM;QACV;QAEA,qBAAoB,IAAI;YACtB,IAAI,CAAC,KAAK,IAAI,IAAI,iBAAiB,GAAG;gBACpC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,gEACA;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3351, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * Lone Schema definition\n *\n * A GraphQL document is only valid if it contains only one schema definition.\n */\nfunction LoneSchemaDefinitionRule(context) {\n  var _ref, _ref2, _oldSchema$astNode;\n\n  const oldSchema = context.getSchema();\n  const alreadyDefined =\n    (_ref =\n      (_ref2 =\n        (_oldSchema$astNode =\n          oldSchema === null || oldSchema === void 0\n            ? void 0\n            : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0\n          ? _oldSchema$astNode\n          : oldSchema === null || oldSchema === void 0\n          ? void 0\n          : oldSchema.getQueryType()) !== null && _ref2 !== void 0\n        ? _ref2\n        : oldSchema === null || oldSchema === void 0\n        ? void 0\n        : oldSchema.getMutationType()) !== null && _ref !== void 0\n      ? _ref\n      : oldSchema === null || oldSchema === void 0\n      ? void 0\n      : oldSchema.getSubscriptionType();\n  let schemaDefinitionsCount = 0;\n  return {\n    SchemaDefinition(node) {\n      if (alreadyDefined) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            'Cannot define a new schema within a schema extension.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (schemaDefinitionsCount > 0) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            'Must provide only one schema definition.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n\n      ++schemaDefinitionsCount;\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,wBAAwB,GAAG;AAEnC,IAAI;AAEJ;;;;CAIC,GACD,SAAS,yBAAyB,OAAO;IACvC,IAAI,MAAM,OAAO;IAEjB,MAAM,YAAY,QAAQ,SAAS;IACnC,MAAM,iBACJ,CAAC,OACC,CAAC,QACC,CAAC,qBACC,cAAc,QAAQ,cAAc,KAAK,IACrC,KAAK,IACL,UAAU,OAAO,MAAM,QAAQ,uBAAuB,KAAK,IAC7D,qBACA,cAAc,QAAQ,cAAc,KAAK,IACzC,KAAK,IACL,UAAU,YAAY,EAAE,MAAM,QAAQ,UAAU,KAAK,IACvD,QACA,cAAc,QAAQ,cAAc,KAAK,IACzC,KAAK,IACL,UAAU,eAAe,EAAE,MAAM,QAAQ,SAAS,KAAK,IACzD,OACA,cAAc,QAAQ,cAAc,KAAK,IACzC,KAAK,IACL,UAAU,mBAAmB;IACnC,IAAI,yBAAyB;IAC7B,OAAO;QACL,kBAAiB,IAAI;YACnB,IAAI,gBAAgB;gBAClB,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,yDACA;oBACE,OAAO;gBACT;gBAGJ;YACF;YAEA,IAAI,yBAAyB,GAAG;gBAC9B,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,4CACA;oBACE,OAAO;gBACT;YAGN;YAEA,EAAE;QACJ;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3388, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.MaxIntrospectionDepthRule = MaxIntrospectionDepthRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nconst MAX_LISTS_DEPTH = 3;\n\nfunction MaxIntrospectionDepthRule(context) {\n  /**\n   * Counts the depth of list fields in \"__Type\" recursively and\n   * returns `true` if the limit has been reached.\n   */\n  function checkDepth(node, visitedFragments = Object.create(null), depth = 0) {\n    if (node.kind === _kinds.Kind.FRAGMENT_SPREAD) {\n      const fragmentName = node.name.value;\n\n      if (visitedFragments[fragmentName] === true) {\n        // Fragment cycles are handled by `NoFragmentCyclesRule`.\n        return false;\n      }\n\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        // Missing fragments checks are handled by `KnownFragmentNamesRule`.\n        return false;\n      } // Rather than following an immutable programming pattern which has\n      // significant memory and garbage collection overhead, we've opted to\n      // take a mutable approach for efficiency's sake. Importantly visiting a\n      // fragment twice is fine, so long as you don't do one visit inside the\n      // other.\n\n      try {\n        visitedFragments[fragmentName] = true;\n        return checkDepth(fragment, visitedFragments, depth);\n      } finally {\n        visitedFragments[fragmentName] = undefined;\n      }\n    }\n\n    if (\n      node.kind === _kinds.Kind.FIELD && // check all introspection lists\n      (node.name.value === 'fields' ||\n        node.name.value === 'interfaces' ||\n        node.name.value === 'possibleTypes' ||\n        node.name.value === 'inputFields')\n    ) {\n      // eslint-disable-next-line no-param-reassign\n      depth++;\n\n      if (depth >= MAX_LISTS_DEPTH) {\n        return true;\n      }\n    } // handles fields and inline fragments\n\n    if ('selectionSet' in node && node.selectionSet) {\n      for (const child of node.selectionSet.selections) {\n        if (checkDepth(child, visitedFragments, depth)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return {\n    Field(node) {\n      if (node.name.value === '__schema' || node.name.value === '__type') {\n        if (checkDepth(node)) {\n          context.reportError(\n            new _GraphQLError.GraphQLError(\n              'Maximum introspection depth exceeded',\n              {\n                nodes: [node],\n              },\n            ),\n          );\n          return false;\n        }\n      }\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,yBAAyB,GAAG;AAEpC,IAAI;AAEJ,IAAI;AAEJ,MAAM,kBAAkB;AAExB,SAAS,0BAA0B,OAAO;IACxC;;;GAGC,GACD,SAAS,WAAW,IAAI,EAAE,mBAAmB,OAAO,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC;QACzE,IAAI,KAAK,IAAI,KAAK,OAAO,IAAI,CAAC,eAAe,EAAE;YAC7C,MAAM,eAAe,KAAK,IAAI,CAAC,KAAK;YAEpC,IAAI,gBAAgB,CAAC,aAAa,KAAK,MAAM;gBAC3C,yDAAyD;gBACzD,OAAO;YACT;YAEA,MAAM,WAAW,QAAQ,WAAW,CAAC;YAErC,IAAI,CAAC,UAAU;gBACb,oEAAoE;gBACpE,OAAO;YACT,EAAE,mEAAmE;YACrE,qEAAqE;YACrE,wEAAwE;YACxE,uEAAuE;YACvE,SAAS;YAET,IAAI;gBACF,gBAAgB,CAAC,aAAa,GAAG;gBACjC,OAAO,WAAW,UAAU,kBAAkB;YAChD,SAAU;gBACR,gBAAgB,CAAC,aAAa,GAAG;YACnC;QACF;QAEA,IACE,KAAK,IAAI,KAAK,OAAO,IAAI,CAAC,KAAK,IAAI,gCAAgC;QACnE,CAAC,KAAK,IAAI,CAAC,KAAK,KAAK,YACnB,KAAK,IAAI,CAAC,KAAK,KAAK,gBACpB,KAAK,IAAI,CAAC,KAAK,KAAK,mBACpB,KAAK,IAAI,CAAC,KAAK,KAAK,aAAa,GACnC;YACA,6CAA6C;YAC7C;YAEA,IAAI,SAAS,iBAAiB;gBAC5B,OAAO;YACT;QACF,EAAE,sCAAsC;QAExC,IAAI,kBAAkB,QAAQ,KAAK,YAAY,EAAE;YAC/C,KAAK,MAAM,SAAS,KAAK,YAAY,CAAC,UAAU,CAAE;gBAChD,IAAI,WAAW,OAAO,kBAAkB,QAAQ;oBAC9C,OAAO;gBACT;YACF;QACF;QAEA,OAAO;IACT;IAEA,OAAO;QACL,OAAM,IAAI;YACR,IAAI,KAAK,IAAI,CAAC,KAAK,KAAK,cAAc,KAAK,IAAI,CAAC,KAAK,KAAK,UAAU;gBAClE,IAAI,WAAW,OAAO;oBACpB,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,wCACA;wBACE,OAAO;4BAAC;yBAAK;oBACf;oBAGJ,OAAO;gBACT;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3460, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.NoFragmentCyclesRule = NoFragmentCyclesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * No fragment cycles\n *\n * The graph of fragment spreads must not form any cycles including spreading itself.\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\n */\nfunction NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  const spreadPath = []; // Position in the spread path\n\n  const spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    },\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    const fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (const spreadNode of spreadNodes) {\n      const spreadName = spreadNode.name.value;\n      const cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        const spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        const cyclePath = spreadPath.slice(cycleIndex);\n        const viaPath = cyclePath\n          .slice(0, -1)\n          .map((s) => '\"' + s.name.value + '\"')\n          .join(', ');\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Cannot spread fragment \"${spreadName}\" within itself` +\n              (viaPath !== '' ? ` via ${viaPath}.` : '.'),\n            {\n              nodes: cyclePath,\n            },\n          ),\n        );\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,oBAAoB,GAAG;AAE/B,IAAI;AAEJ;;;;;;;CAOC,GACD,SAAS,qBAAqB,OAAO;IACnC,8EAA8E;IAC9E,gCAAgC;IAChC,MAAM,eAAe,OAAO,MAAM,CAAC,OAAO,uDAAuD;IAEjG,MAAM,aAAa,EAAE,EAAE,8BAA8B;IAErD,MAAM,wBAAwB,OAAO,MAAM,CAAC;IAC5C,OAAO;QACL,qBAAqB,IAAM;QAE3B,oBAAmB,IAAI;YACrB,qBAAqB;YACrB,OAAO;QACT;IACF,GAAG,mDAAmD;;;IACtD,wEAAwE;IACxE,yCAAyC;IAEzC,SAAS,qBAAqB,QAAQ;QACpC,IAAI,YAAY,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,EAAE;YACrC;QACF;QAEA,MAAM,eAAe,SAAS,IAAI,CAAC,KAAK;QACxC,YAAY,CAAC,aAAa,GAAG;QAC7B,MAAM,cAAc,QAAQ,kBAAkB,CAAC,SAAS,YAAY;QAEpE,IAAI,YAAY,MAAM,KAAK,GAAG;YAC5B;QACF;QAEA,qBAAqB,CAAC,aAAa,GAAG,WAAW,MAAM;QAEvD,KAAK,MAAM,cAAc,YAAa;YACpC,MAAM,aAAa,WAAW,IAAI,CAAC,KAAK;YACxC,MAAM,aAAa,qBAAqB,CAAC,WAAW;YACpD,WAAW,IAAI,CAAC;YAEhB,IAAI,eAAe,WAAW;gBAC5B,MAAM,iBAAiB,QAAQ,WAAW,CAAC;gBAE3C,IAAI,gBAAgB;oBAClB,qBAAqB;gBACvB;YACF,OAAO;gBACL,MAAM,YAAY,WAAW,KAAK,CAAC;gBACnC,MAAM,UAAU,UACb,KAAK,CAAC,GAAG,CAAC,GACV,GAAG,CAAC,CAAC,IAAM,MAAM,EAAE,IAAI,CAAC,KAAK,GAAG,KAChC,IAAI,CAAC;gBACR,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,wBAAwB,EAAE,WAAW,eAAe,CAAC,GACpD,CAAC,YAAY,KAAK,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,GAAG,GAAG,GAC5C;oBACE,OAAO;gBACT;YAGN;YAEA,WAAW,GAAG;QAChB;QAEA,qBAAqB,CAAC,aAAa,GAAG;IACxC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3527, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.NoUndefinedVariablesRule = NoUndefinedVariablesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Uses-Defined\n */\nfunction NoUndefinedVariablesRule(context) {\n  let variableNameDefined = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        variableNameDefined = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          const varName = node.name.value;\n\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(\n              new _GraphQLError.GraphQLError(\n                operation.name\n                  ? `Variable \"$${varName}\" is not defined by operation \"${operation.name.value}\".`\n                  : `Variable \"$${varName}\" is not defined.`,\n                {\n                  nodes: [node, operation],\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,wBAAwB,GAAG;AAEnC,IAAI;AAEJ;;;;;;;CAOC,GACD,SAAS,yBAAyB,OAAO;IACvC,IAAI,sBAAsB,OAAO,MAAM,CAAC;IACxC,OAAO;QACL,qBAAqB;YACnB;gBACE,sBAAsB,OAAO,MAAM,CAAC;YACtC;YAEA,OAAM,SAAS;gBACb,MAAM,SAAS,QAAQ,0BAA0B,CAAC;gBAElD,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,OAAQ;oBAC7B,MAAM,UAAU,KAAK,IAAI,CAAC,KAAK;oBAE/B,IAAI,mBAAmB,CAAC,QAAQ,KAAK,MAAM;wBACzC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,UAAU,IAAI,GACV,CAAC,WAAW,EAAE,QAAQ,+BAA+B,EAAE,UAAU,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAC/E,CAAC,WAAW,EAAE,QAAQ,iBAAiB,CAAC,EAC5C;4BACE,OAAO;gCAAC;gCAAM;6BAAU;wBAC1B;oBAGN;gBACF;YACF;QACF;QAEA,oBAAmB,IAAI;YACrB,mBAAmB,CAAC,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG;QAClD;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3572, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.NoUnusedFragmentsRule = NoUnusedFragmentsRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-Must-Be-Used\n */\nfunction NoUnusedFragmentsRule(context) {\n  const operationDefs = [];\n  const fragmentDefs = [];\n  return {\n    OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n\n    FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n\n    Document: {\n      leave() {\n        const fragmentNameUsed = Object.create(null);\n\n        for (const operation of operationDefs) {\n          for (const fragment of context.getRecursivelyReferencedFragments(\n            operation,\n          )) {\n            fragmentNameUsed[fragment.name.value] = true;\n          }\n        }\n\n        for (const fragmentDef of fragmentDefs) {\n          const fragName = fragmentDef.name.value;\n\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(\n              new _GraphQLError.GraphQLError(\n                `Fragment \"${fragName}\" is never used.`,\n                {\n                  nodes: fragmentDef,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,qBAAqB,GAAG;AAEhC,IAAI;AAEJ;;;;;;;CAOC,GACD,SAAS,sBAAsB,OAAO;IACpC,MAAM,gBAAgB,EAAE;IACxB,MAAM,eAAe,EAAE;IACvB,OAAO;QACL,qBAAoB,IAAI;YACtB,cAAc,IAAI,CAAC;YACnB,OAAO;QACT;QAEA,oBAAmB,IAAI;YACrB,aAAa,IAAI,CAAC;YAClB,OAAO;QACT;QAEA,UAAU;YACR;gBACE,MAAM,mBAAmB,OAAO,MAAM,CAAC;gBAEvC,KAAK,MAAM,aAAa,cAAe;oBACrC,KAAK,MAAM,YAAY,QAAQ,iCAAiC,CAC9D,WACC;wBACD,gBAAgB,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,GAAG;oBAC1C;gBACF;gBAEA,KAAK,MAAM,eAAe,aAAc;oBACtC,MAAM,WAAW,YAAY,IAAI,CAAC,KAAK;oBAEvC,IAAI,gBAAgB,CAAC,SAAS,KAAK,MAAM;wBACvC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,UAAU,EAAE,SAAS,gBAAgB,CAAC,EACvC;4BACE,OAAO;wBACT;oBAGN;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3622, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/NoUnusedVariablesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.NoUnusedVariablesRule = NoUnusedVariablesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variables-Used\n */\nfunction NoUnusedVariablesRule(context) {\n  let variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter() {\n        variableDefs = [];\n      },\n\n      leave(operation) {\n        const variableNameUsed = Object.create(null);\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          variableNameUsed[node.name.value] = true;\n        }\n\n        for (const variableDef of variableDefs) {\n          const variableName = variableDef.variable.name.value;\n\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(\n              new _GraphQLError.GraphQLError(\n                operation.name\n                  ? `Variable \"$${variableName}\" is never used in operation \"${operation.name.value}\".`\n                  : `Variable \"$${variableName}\" is never used.`,\n                {\n                  nodes: variableDef,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(def) {\n      variableDefs.push(def);\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,qBAAqB,GAAG;AAEhC,IAAI;AAEJ;;;;;;;CAOC,GACD,SAAS,sBAAsB,OAAO;IACpC,IAAI,eAAe,EAAE;IACrB,OAAO;QACL,qBAAqB;YACnB;gBACE,eAAe,EAAE;YACnB;YAEA,OAAM,SAAS;gBACb,MAAM,mBAAmB,OAAO,MAAM,CAAC;gBACvC,MAAM,SAAS,QAAQ,0BAA0B,CAAC;gBAElD,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,OAAQ;oBAC7B,gBAAgB,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,GAAG;gBACtC;gBAEA,KAAK,MAAM,eAAe,aAAc;oBACtC,MAAM,eAAe,YAAY,QAAQ,CAAC,IAAI,CAAC,KAAK;oBAEpD,IAAI,gBAAgB,CAAC,aAAa,KAAK,MAAM;wBAC3C,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,UAAU,IAAI,GACV,CAAC,WAAW,EAAE,aAAa,8BAA8B,EAAE,UAAU,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GACnF,CAAC,WAAW,EAAE,aAAa,gBAAgB,CAAC,EAChD;4BACE,OAAO;wBACT;oBAGN;gBACF;YACF;QACF;QAEA,oBAAmB,GAAG;YACpB,aAAa,IAAI,CAAC;QACpB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3668, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _printer = require('../../language/printer.js');\n\nvar _definition = require('../../type/definition.js');\n\nvar _sortValueNode = require('../../utilities/sortValueNode.js');\n\nvar _typeFromAST = require('../../utilities/typeFromAST.js');\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason\n      .map(\n        ([responseName, subReason]) =>\n          `subfields \"${responseName}\" conflict because ` +\n          reasonMessage(subReason),\n      )\n      .join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\nfunction OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when fields and a fragment or two fragments are compared\n  // \"between\" each other for conflicts. Comparisons made be made many times,\n  // so memoizing this can dramatically improve the performance of this validator.\n  const comparedFieldsAndFragmentPairs = new OrderedPairSet();\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentNames,\n        comparedFieldsAndFragmentPairs,\n        comparedFragmentPairs,\n        context.getParentType(),\n        selectionSet,\n      );\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\n            {\n              nodes: fields1.concat(fields2),\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  parentType,\n  selectionSet,\n) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType,\n    selectionSet,\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    fieldMap,\n  );\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFieldsAndFragmentPairs,\n        comparedFragmentPairs,\n        false,\n        fieldMap,\n        fragmentNames[i],\n      ); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(\n          context,\n          conflicts,\n          cachedFieldsAndFragmentNames,\n          comparedFieldsAndFragmentPairs,\n          comparedFragmentPairs,\n          false,\n          fragmentNames[i],\n          fragmentNames[j],\n        );\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fieldMap,\n  fragmentName,\n) {\n  // Memoize so the fields and fragments are not compared for conflicts more\n  // than once.\n  if (\n    comparedFieldsAndFragmentPairs.has(\n      fieldMap,\n      fragmentName,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFieldsAndFragmentPairs.add(\n    fieldMap,\n    fragmentName,\n    areMutuallyExclusive,\n  );\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment,\n    ); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap,\n    fieldMap2,\n  ); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap,\n      referencedFragmentName,\n    );\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fragmentName1,\n  fragmentName2,\n) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (\n    comparedFragmentPairs.has(\n      fragmentName1,\n      fragmentName2,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment1,\n    );\n  const [fieldMap2, referencedFragmentNames2] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment2,\n    ); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fragmentName1,\n      referencedFragmentName2,\n    );\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      referencedFragmentName1,\n      fragmentName2,\n    );\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  parentType1,\n  selectionSet1,\n  parentType2,\n  selectionSet2,\n) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType1,\n    selectionSet1,\n  );\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType2,\n    selectionSet2,\n  ); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentName2,\n    );\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentName1,\n    );\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFieldsAndFragmentPairs,\n        comparedFragmentPairs,\n        areMutuallyExclusive,\n        fragmentName1,\n        fragmentName2,\n      );\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  fieldMap,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFieldsAndFragmentPairs,\n            comparedFragmentPairs,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            fields[j],\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  fieldMap1,\n  fieldMap2,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFieldsAndFragmentPairs,\n            comparedFragmentPairs,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            field1,\n            field2,\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFieldsAndFragmentPairs,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  responseName,\n  field1,\n  field2,\n) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    (parentType1 !== parentType2 &&\n      (0, _definition.isObjectType)(parentType1) &&\n      (0, _definition.isObjectType)(parentType2));\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2],\n      ];\n    } // Two field calls must have the same arguments.\n\n    if (!sameArguments(node1, node2)) {\n      return [\n        [responseName, 'they have differing arguments'],\n        [node1],\n        [node2],\n      ];\n    }\n  } // The return type for each field.\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${(0, _inspect.inspect)(\n          type1,\n        )}\" and \"${(0, _inspect.inspect)(type2)}\"`,\n      ],\n      [node1],\n      [node2],\n    ];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentNames,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      (0, _definition.getNamedType)(type1),\n      selectionSet1,\n      (0, _definition.getNamedType)(type2),\n      selectionSet2,\n    );\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(node1, node2) {\n  const args1 = node1.arguments;\n  const args2 = node2.arguments;\n\n  if (args1 === undefined || args1.length === 0) {\n    return args2 === undefined || args2.length === 0;\n  }\n\n  if (args2 === undefined || args2.length === 0) {\n    return false;\n  }\n  /* c8 ignore next */\n\n  if (args1.length !== args2.length) {\n    /* c8 ignore next */\n    return false;\n    /* c8 ignore next */\n  }\n\n  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));\n  return args1.every((arg1) => {\n    const value1 = arg1.value;\n    const value2 = values2.get(arg1.name.value);\n\n    if (value2 === undefined) {\n      return false;\n    }\n\n    return stringifyValue(value1) === stringifyValue(value2);\n  });\n}\n\nfunction stringifyValue(value) {\n  return (0, _printer.print)((0, _sortValueNode.sortValueNode)(value));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if ((0, _definition.isListType)(type1)) {\n    return (0, _definition.isListType)(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if ((0, _definition.isListType)(type2)) {\n    return true;\n  }\n\n  if ((0, _definition.isNonNullType)(type1)) {\n    return (0, _definition.isNonNullType)(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if ((0, _definition.isNonNullType)(type2)) {\n    return true;\n  }\n\n  if (\n    (0, _definition.isLeafType)(type1) ||\n    (0, _definition.isLeafType)(type2)\n  ) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  parentType,\n  selectionSet,\n) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(\n    context,\n    parentType,\n    selectionSet,\n    nodeAndDefs,\n    fragmentNames,\n  );\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  fragment,\n) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = (0, _typeFromAST.typeFromAST)(\n    context.getSchema(),\n    fragment.typeCondition,\n  );\n  return getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragmentType,\n    fragment.selectionSet,\n  );\n}\n\nfunction _collectFieldsAndFragmentNames(\n  context,\n  parentType,\n  selectionSet,\n  nodeAndDefs,\n  fragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case _kinds.Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n\n        if (\n          (0, _definition.isObjectType)(parentType) ||\n          (0, _definition.isInterfaceType)(parentType)\n        ) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        const responseName = selection.alias\n          ? selection.alias.value\n          : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      }\n\n      case _kinds.Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case _kinds.Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition\n          ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition)\n          : parentType;\n\n        _collectFieldsAndFragmentNames(\n          context,\n          inlineFragmentType,\n          selection.selectionSet,\n          nodeAndDefs,\n          fragmentNames,\n        );\n\n        break;\n      }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\n    ];\n  }\n}\n/**\n * A way to keep track of pairs of things where the ordering of the pair\n * matters.\n *\n * Provides a third argument for has/set to allow flagging the pair as\n * weakly or strongly present within the collection.\n */\n\nclass OrderedPairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, weaklyPresent) {\n    var _this$_data$get;\n\n    const result =\n      (_this$_data$get = this._data.get(a)) === null ||\n      _this$_data$get === void 0\n        ? void 0\n        : _this$_data$get.get(b);\n\n    if (result === undefined) {\n      return false;\n    }\n\n    return weaklyPresent ? true : weaklyPresent === result;\n  }\n\n  add(a, b, weaklyPresent) {\n    const map = this._data.get(a);\n\n    if (map === undefined) {\n      this._data.set(a, new Map([[b, weaklyPresent]]));\n    } else {\n      map.set(b, weaklyPresent);\n    }\n  }\n}\n/**\n * A way to keep track of pairs of similar things when the ordering of the pair\n * does not matter.\n */\n\nclass PairSet {\n  constructor() {\n    this._orderedPairSet = new OrderedPairSet();\n  }\n\n  has(a, b, weaklyPresent) {\n    return a < b\n      ? this._orderedPairSet.has(a, b, weaklyPresent)\n      : this._orderedPairSet.has(b, a, weaklyPresent);\n  }\n\n  add(a, b, weaklyPresent) {\n    if (a < b) {\n      this._orderedPairSet.add(a, b, weaklyPresent);\n    } else {\n      this._orderedPairSet.add(b, a, weaklyPresent);\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4164, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _definition = require('../../type/definition.js');\n\nvar _typeComparators = require('../../utilities/typeComparators.js');\n\nvar _typeFromAST = require('../../utilities/typeFromAST.js');\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nfunction PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n\n      if (\n        (0, _definition.isCompositeType)(fragType) &&\n        (0, _definition.isCompositeType)(parentType) &&\n        !(0, _typeComparators.doTypesOverlap)(\n          context.getSchema(),\n          fragType,\n          parentType,\n        )\n      ) {\n        const parentTypeStr = (0, _inspect.inspect)(parentType);\n        const fragTypeStr = (0, _inspect.inspect)(fragType);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Fragment cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n\n      if (\n        fragType &&\n        parentType &&\n        !(0, _typeComparators.doTypesOverlap)(\n          context.getSchema(),\n          fragType,\n          parentType,\n        )\n      ) {\n        const parentTypeStr = (0, _inspect.inspect)(parentType);\n        const fragTypeStr = (0, _inspect.inspect)(fragType);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Fragment \"${fragName}\" cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getFragmentType(context, name) {\n  const frag = context.getFragment(name);\n\n  if (frag) {\n    const type = (0, _typeFromAST.typeFromAST)(\n      context.getSchema(),\n      frag.typeCondition,\n    );\n\n    if ((0, _definition.isCompositeType)(type)) {\n      return type;\n    }\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,2BAA2B,GAAG;AAEtC,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;;CAMC,GACD,SAAS,4BAA4B,OAAO;IAC1C,OAAO;QACL,gBAAe,IAAI;YACjB,MAAM,WAAW,QAAQ,OAAO;YAChC,MAAM,aAAa,QAAQ,aAAa;YAExC,IACE,CAAC,GAAG,YAAY,eAAe,EAAE,aACjC,CAAC,GAAG,YAAY,eAAe,EAAE,eACjC,CAAC,CAAC,GAAG,iBAAiB,cAAc,EAClC,QAAQ,SAAS,IACjB,UACA,aAEF;gBACA,MAAM,gBAAgB,CAAC,GAAG,SAAS,OAAO,EAAE;gBAC5C,MAAM,cAAc,CAAC,GAAG,SAAS,OAAO,EAAE;gBAC1C,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,mDAAmD,EAAE,cAAc,wBAAwB,EAAE,YAAY,EAAE,CAAC,EAC7G;oBACE,OAAO;gBACT;YAGN;QACF;QAEA,gBAAe,IAAI;YACjB,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;YAChC,MAAM,WAAW,gBAAgB,SAAS;YAC1C,MAAM,aAAa,QAAQ,aAAa;YAExC,IACE,YACA,cACA,CAAC,CAAC,GAAG,iBAAiB,cAAc,EAClC,QAAQ,SAAS,IACjB,UACA,aAEF;gBACA,MAAM,gBAAgB,CAAC,GAAG,SAAS,OAAO,EAAE;gBAC5C,MAAM,cAAc,CAAC,GAAG,SAAS,OAAO,EAAE;gBAC1C,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,UAAU,EAAE,SAAS,4CAA4C,EAAE,cAAc,wBAAwB,EAAE,YAAY,EAAE,CAAC,EAC3H;oBACE,OAAO;gBACT;YAGN;QACF;IACF;AACF;AAEA,SAAS,gBAAgB,OAAO,EAAE,IAAI;IACpC,MAAM,OAAO,QAAQ,WAAW,CAAC;IAEjC,IAAI,MAAM;QACR,MAAM,OAAO,CAAC,GAAG,aAAa,WAAW,EACvC,QAAQ,SAAS,IACjB,KAAK,aAAa;QAGpB,IAAI,CAAC,GAAG,YAAY,eAAe,EAAE,OAAO;YAC1C,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4221, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _invariant = require('../../jsutils/invariant.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _predicates = require('../../language/predicates.js');\n\nvar _definition = require('../../type/definition.js');\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nfunction PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension,\n  };\n\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType =\n      schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Cannot extend non-${kindStr} type \"${typeName}\".`,\n            {\n              nodes: defNode ? [defNode, node] : node,\n            },\n          ),\n        );\n      }\n    } else {\n      const allTypeNames = Object.keys({\n        ...definedTypes,\n        ...(schema === null || schema === void 0\n          ? void 0\n          : schema.getTypeMap()),\n      });\n      const suggestedTypes = (0, _suggestionList.suggestionList)(\n        typeName,\n        allTypeNames,\n      );\n      context.reportError(\n        new _GraphQLError.GraphQLError(\n          `Cannot extend type \"${typeName}\" because it is not defined.` +\n            (0, _didYouMean.didYouMean)(suggestedTypes),\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n    }\n  }\n}\n\nconst defKindToExtKind = {\n  [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,\n  [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,\n  [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,\n  [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,\n  [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,\n  [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]:\n    _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n};\n\nfunction typeToExtKind(type) {\n  if ((0, _definition.isScalarType)(type)) {\n    return _kinds.Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isObjectType)(type)) {\n    return _kinds.Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isInterfaceType)(type)) {\n    return _kinds.Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isUnionType)(type)) {\n    return _kinds.Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isEnumType)(type)) {\n    return _kinds.Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n  false ||\n    (0, _invariant.invariant)(\n      false,\n      'Unexpected type: ' + (0, _inspect.inspect)(type),\n    );\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case _kinds.Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case _kinds.Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case _kinds.Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case _kinds.Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case _kinds.Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false ||\n        (0, _invariant.invariant)(\n          false,\n          'Unexpected kind: ' + (0, _inspect.inspect)(kind),\n        );\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,0BAA0B,GAAG;AAErC,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;CAIC,GACD,SAAS,2BAA2B,OAAO;IACzC,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,eAAe,OAAO,MAAM,CAAC;IAEnC,KAAK,MAAM,OAAO,QAAQ,WAAW,GAAG,WAAW,CAAE;QACnD,IAAI,CAAC,GAAG,YAAY,oBAAoB,EAAE,MAAM;YAC9C,YAAY,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG;QACjC;IACF;IAEA,OAAO;QACL,qBAAqB;QACrB,qBAAqB;QACrB,wBAAwB;QACxB,oBAAoB;QACpB,mBAAmB;QACnB,0BAA0B;IAC5B;;;IAEA,SAAS,eAAe,IAAI;QAC1B,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;QAChC,MAAM,UAAU,YAAY,CAAC,SAAS;QACtC,MAAM,eACJ,WAAW,QAAQ,WAAW,KAAK,IAAI,KAAK,IAAI,OAAO,OAAO,CAAC;QACjE,IAAI;QAEJ,IAAI,SAAS;YACX,eAAe,gBAAgB,CAAC,QAAQ,IAAI,CAAC;QAC/C,OAAO,IAAI,cAAc;YACvB,eAAe,cAAc;QAC/B;QAEA,IAAI,cAAc;YAChB,IAAI,iBAAiB,KAAK,IAAI,EAAE;gBAC9B,MAAM,UAAU,wBAAwB,KAAK,IAAI;gBACjD,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,kBAAkB,EAAE,QAAQ,OAAO,EAAE,SAAS,EAAE,CAAC,EAClD;oBACE,OAAO,UAAU;wBAAC;wBAAS;qBAAK,GAAG;gBACrC;YAGN;QACF,OAAO;YACL,MAAM,eAAe,OAAO,IAAI,CAAC;gBAC/B,GAAG,YAAY;gBACf,GAAI,WAAW,QAAQ,WAAW,KAAK,IACnC,KAAK,IACL,OAAO,UAAU,EAAE;YACzB;YACA,MAAM,iBAAiB,CAAC,GAAG,gBAAgB,cAAc,EACvD,UACA;YAEF,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,oBAAoB,EAAE,SAAS,4BAA4B,CAAC,GAC3D,CAAC,GAAG,YAAY,UAAU,EAAE,iBAC9B;gBACE,OAAO,KAAK,IAAI;YAClB;QAGN;IACF;AACF;AAEA,MAAM,mBAAmB;IACvB,CAAC,OAAO,IAAI,CAAC,sBAAsB,CAAC,EAAE,OAAO,IAAI,CAAC,qBAAqB;IACvE,CAAC,OAAO,IAAI,CAAC,sBAAsB,CAAC,EAAE,OAAO,IAAI,CAAC,qBAAqB;IACvE,CAAC,OAAO,IAAI,CAAC,yBAAyB,CAAC,EAAE,OAAO,IAAI,CAAC,wBAAwB;IAC7E,CAAC,OAAO,IAAI,CAAC,qBAAqB,CAAC,EAAE,OAAO,IAAI,CAAC,oBAAoB;IACrE,CAAC,OAAO,IAAI,CAAC,oBAAoB,CAAC,EAAE,OAAO,IAAI,CAAC,mBAAmB;IACnE,CAAC,OAAO,IAAI,CAAC,4BAA4B,CAAC,EACxC,OAAO,IAAI,CAAC,2BAA2B;AAC3C;AAEA,SAAS,cAAc,IAAI;IACzB,IAAI,CAAC,GAAG,YAAY,YAAY,EAAE,OAAO;QACvC,OAAO,OAAO,IAAI,CAAC,qBAAqB;IAC1C;IAEA,IAAI,CAAC,GAAG,YAAY,YAAY,EAAE,OAAO;QACvC,OAAO,OAAO,IAAI,CAAC,qBAAqB;IAC1C;IAEA,IAAI,CAAC,GAAG,YAAY,eAAe,EAAE,OAAO;QAC1C,OAAO,OAAO,IAAI,CAAC,wBAAwB;IAC7C;IAEA,IAAI,CAAC,GAAG,YAAY,WAAW,EAAE,OAAO;QACtC,OAAO,OAAO,IAAI,CAAC,oBAAoB;IACzC;IAEA,IAAI,CAAC,GAAG,YAAY,UAAU,EAAE,OAAO;QACrC,OAAO,OAAO,IAAI,CAAC,mBAAmB;IACxC;IAEA,IAAI,CAAC,GAAG,YAAY,iBAAiB,EAAE,OAAO;QAC5C,OAAO,OAAO,IAAI,CAAC,2BAA2B;IAChD;IACA,oBAAoB,GACpB,yDAAyD;IAEzD,SACE,CAAC,GAAG,WAAW,SAAS,EACtB,OACA,sBAAsB,CAAC,GAAG,SAAS,OAAO,EAAE;AAElD;AAEA,SAAS,wBAAwB,IAAI;IACnC,OAAQ;QACN,KAAK,OAAO,IAAI,CAAC,qBAAqB;YACpC,OAAO;QAET,KAAK,OAAO,IAAI,CAAC,qBAAqB;YACpC,OAAO;QAET,KAAK,OAAO,IAAI,CAAC,wBAAwB;YACvC,OAAO;QAET,KAAK,OAAO,IAAI,CAAC,oBAAoB;YACnC,OAAO;QAET,KAAK,OAAO,IAAI,CAAC,mBAAmB;YAClC,OAAO;QAET,KAAK,OAAO,IAAI,CAAC,2BAA2B;YAC1C,OAAO;QACT,yDAAyD;QAEzD,kBAAkB,GAElB;YACE,SACE,CAAC,GAAG,WAAW,SAAS,EACtB,OACA,sBAAsB,CAAC,GAAG,SAAS,OAAO,EAAE;IAEpD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4342, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.ProvidedRequiredArgumentsOnDirectivesRule =\n  ProvidedRequiredArgumentsOnDirectivesRule;\nexports.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _keyMap = require('../../jsutils/keyMap.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _printer = require('../../language/printer.js');\n\nvar _definition = require('../../type/definition.js');\n\nvar _directives = require('../../type/directives.js');\n\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null without a\n * default value) field arguments have been provided.\n */\nfunction ProvidedRequiredArgumentsRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...ProvidedRequiredArgumentsOnDirectivesRule(context),\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(fieldNode) {\n        var _fieldNode$arguments;\n\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          return false;\n        }\n\n        const providedArgs = new Set( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n          /* c8 ignore next */\n          (_fieldNode$arguments = fieldNode.arguments) === null ||\n          _fieldNode$arguments === void 0\n            ? void 0\n            : _fieldNode$arguments.map((arg) => arg.name.value),\n        );\n\n        for (const argDef of fieldDef.args) {\n          if (\n            !providedArgs.has(argDef.name) &&\n            (0, _definition.isRequiredArgument)(argDef)\n          ) {\n            const argTypeStr = (0, _inspect.inspect)(argDef.type);\n            context.reportError(\n              new _GraphQLError.GraphQLError(\n                `Field \"${fieldDef.name}\" argument \"${argDef.name}\" of type \"${argTypeStr}\" is required, but it was not provided.`,\n                {\n                  nodes: fieldNode,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n/**\n * @internal\n */\n\nfunction ProvidedRequiredArgumentsOnDirectivesRule(context) {\n  var _schema$getDirectives;\n\n  const requiredArgsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives =\n    (_schema$getDirectives =\n      schema === null || schema === void 0\n        ? void 0\n        : schema.getDirectives()) !== null && _schema$getDirectives !== void 0\n      ? _schema$getDirectives\n      : _directives.specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    requiredArgsMap[directive.name] = (0, _keyMap.keyMap)(\n      directive.args.filter(_definition.isRequiredArgument),\n      (arg) => arg.name,\n    );\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      requiredArgsMap[def.name.value] = (0, _keyMap.keyMap)(\n        argNodes.filter(isRequiredArgumentNode),\n        (arg) => arg.name.value,\n      );\n    }\n  }\n\n  return {\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(directiveNode) {\n        const directiveName = directiveNode.name.value;\n        const requiredArgs = requiredArgsMap[directiveName];\n\n        if (requiredArgs) {\n          var _directiveNode$argume;\n\n          // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n          /* c8 ignore next */\n          const argNodes =\n            (_directiveNode$argume = directiveNode.arguments) !== null &&\n            _directiveNode$argume !== void 0\n              ? _directiveNode$argume\n              : [];\n          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));\n\n          for (const [argName, argDef] of Object.entries(requiredArgs)) {\n            if (!argNodeMap.has(argName)) {\n              const argType = (0, _definition.isType)(argDef.type)\n                ? (0, _inspect.inspect)(argDef.type)\n                : (0, _printer.print)(argDef.type);\n              context.reportError(\n                new _GraphQLError.GraphQLError(\n                  `Directive \"@${directiveName}\" argument \"${argName}\" of type \"${argType}\" is required, but it was not provided.`,\n                  {\n                    nodes: directiveNode,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n  };\n}\n\nfunction isRequiredArgumentNode(arg) {\n  return (\n    arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null\n  );\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4436, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ScalarLeafsRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.ScalarLeafsRule = ScalarLeafsRule;\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _definition = require('../../type/definition.js');\n\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\nfunction ScalarLeafsRule(context) {\n  return {\n    Field(node) {\n      const type = context.getType();\n      const selectionSet = node.selectionSet;\n\n      if (type) {\n        if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {\n          if (selectionSet) {\n            const fieldName = node.name.value;\n            const typeStr = (0, _inspect.inspect)(type);\n            context.reportError(\n              new _GraphQLError.GraphQLError(\n                `Field \"${fieldName}\" must not have a selection since type \"${typeStr}\" has no subfields.`,\n                {\n                  nodes: selectionSet,\n                },\n              ),\n            );\n          }\n        } else if (!selectionSet) {\n          const fieldName = node.name.value;\n          const typeStr = (0, _inspect.inspect)(type);\n          context.reportError(\n            new _GraphQLError.GraphQLError(\n              `Field \"${fieldName}\" of type \"${typeStr}\" must have a selection of subfields. Did you mean \"${fieldName} { ... }\"?`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        } else if (selectionSet.selections.length === 0) {\n          const fieldName = node.name.value;\n          const typeStr = (0, _inspect.inspect)(type);\n          context.reportError(\n            new _GraphQLError.GraphQLError(\n              `Field \"${fieldName}\" of type \"${typeStr}\" must have at least one field selected.`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,eAAe,GAAG;AAE1B,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;CAKC,GACD,SAAS,gBAAgB,OAAO;IAC9B,OAAO;QACL,OAAM,IAAI;YACR,MAAM,OAAO,QAAQ,OAAO;YAC5B,MAAM,eAAe,KAAK,YAAY;YAEtC,IAAI,MAAM;gBACR,IAAI,CAAC,GAAG,YAAY,UAAU,EAAE,CAAC,GAAG,YAAY,YAAY,EAAE,QAAQ;oBACpE,IAAI,cAAc;wBAChB,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK;wBACjC,MAAM,UAAU,CAAC,GAAG,SAAS,OAAO,EAAE;wBACtC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,OAAO,EAAE,UAAU,wCAAwC,EAAE,QAAQ,mBAAmB,CAAC,EAC1F;4BACE,OAAO;wBACT;oBAGN;gBACF,OAAO,IAAI,CAAC,cAAc;oBACxB,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK;oBACjC,MAAM,UAAU,CAAC,GAAG,SAAS,OAAO,EAAE;oBACtC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,OAAO,EAAE,UAAU,WAAW,EAAE,QAAQ,oDAAoD,EAAE,UAAU,UAAU,CAAC,EACpH;wBACE,OAAO;oBACT;gBAGN,OAAO,IAAI,aAAa,UAAU,CAAC,MAAM,KAAK,GAAG;oBAC/C,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK;oBACjC,MAAM,UAAU,CAAC,GAAG,SAAS,OAAO,EAAE;oBACtC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,OAAO,EAAE,UAAU,WAAW,EAAE,QAAQ,wCAAwC,CAAC,EAClF;wBACE,OAAO;oBACT;gBAGN;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4485, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _collectFields = require('../../execution/collectFields.js');\n\n/**\n * Subscriptions must only include a non-introspection field.\n *\n * A GraphQL subscription is valid only if it contains a single root field and\n * that root field is not an introspection field.\n *\n * See https://spec.graphql.org/draft/#sec-Single-root-field\n */\nfunction SingleFieldSubscriptionsRule(context) {\n  return {\n    OperationDefinition(node) {\n      if (node.operation === 'subscription') {\n        const schema = context.getSchema();\n        const subscriptionType = schema.getSubscriptionType();\n\n        if (subscriptionType) {\n          const operationName = node.name ? node.name.value : null;\n          const variableValues = Object.create(null);\n          const document = context.getDocument();\n          const fragments = Object.create(null);\n\n          for (const definition of document.definitions) {\n            if (definition.kind === _kinds.Kind.FRAGMENT_DEFINITION) {\n              fragments[definition.name.value] = definition;\n            }\n          }\n\n          const fields = (0, _collectFields.collectFields)(\n            schema,\n            fragments,\n            variableValues,\n            subscriptionType,\n            node.selectionSet,\n          );\n\n          if (fields.size > 1) {\n            const fieldSelectionLists = [...fields.values()];\n            const extraFieldSelectionLists = fieldSelectionLists.slice(1);\n            const extraFieldSelections = extraFieldSelectionLists.flat();\n            context.reportError(\n              new _GraphQLError.GraphQLError(\n                operationName != null\n                  ? `Subscription \"${operationName}\" must select only one top level field.`\n                  : 'Anonymous Subscription must select only one top level field.',\n                {\n                  nodes: extraFieldSelections,\n                },\n              ),\n            );\n          }\n\n          for (const fieldNodes of fields.values()) {\n            const field = fieldNodes[0];\n            const fieldName = field.name.value;\n\n            if (fieldName.startsWith('__')) {\n              context.reportError(\n                new _GraphQLError.GraphQLError(\n                  operationName != null\n                    ? `Subscription \"${operationName}\" must not select an introspection top level field.`\n                    : 'Anonymous Subscription must not select an introspection top level field.',\n                  {\n                    nodes: fieldNodes,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      }\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,4BAA4B,GAAG;AAEvC,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;;;CAOC,GACD,SAAS,6BAA6B,OAAO;IAC3C,OAAO;QACL,qBAAoB,IAAI;YACtB,IAAI,KAAK,SAAS,KAAK,gBAAgB;gBACrC,MAAM,SAAS,QAAQ,SAAS;gBAChC,MAAM,mBAAmB,OAAO,mBAAmB;gBAEnD,IAAI,kBAAkB;oBACpB,MAAM,gBAAgB,KAAK,IAAI,GAAG,KAAK,IAAI,CAAC,KAAK,GAAG;oBACpD,MAAM,iBAAiB,OAAO,MAAM,CAAC;oBACrC,MAAM,WAAW,QAAQ,WAAW;oBACpC,MAAM,YAAY,OAAO,MAAM,CAAC;oBAEhC,KAAK,MAAM,cAAc,SAAS,WAAW,CAAE;wBAC7C,IAAI,WAAW,IAAI,KAAK,OAAO,IAAI,CAAC,mBAAmB,EAAE;4BACvD,SAAS,CAAC,WAAW,IAAI,CAAC,KAAK,CAAC,GAAG;wBACrC;oBACF;oBAEA,MAAM,SAAS,CAAC,GAAG,eAAe,aAAa,EAC7C,QACA,WACA,gBACA,kBACA,KAAK,YAAY;oBAGnB,IAAI,OAAO,IAAI,GAAG,GAAG;wBACnB,MAAM,sBAAsB;+BAAI,OAAO,MAAM;yBAAG;wBAChD,MAAM,2BAA2B,oBAAoB,KAAK,CAAC;wBAC3D,MAAM,uBAAuB,yBAAyB,IAAI;wBAC1D,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,iBAAiB,OACb,CAAC,cAAc,EAAE,cAAc,uCAAuC,CAAC,GACvE,gEACJ;4BACE,OAAO;wBACT;oBAGN;oBAEA,KAAK,MAAM,cAAc,OAAO,MAAM,GAAI;wBACxC,MAAM,QAAQ,UAAU,CAAC,EAAE;wBAC3B,MAAM,YAAY,MAAM,IAAI,CAAC,KAAK;wBAElC,IAAI,UAAU,UAAU,CAAC,OAAO;4BAC9B,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,iBAAiB,OACb,CAAC,cAAc,EAAE,cAAc,mDAAmD,CAAC,GACnF,4EACJ;gCACE,OAAO;4BACT;wBAGN;oBACF;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4546, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule;\n\nvar _groupBy = require('../../jsutils/groupBy.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * Unique argument definition names\n *\n * A GraphQL Object or Interface type is only valid if all its fields have uniquely named arguments.\n * A GraphQL Directive is only valid if all its arguments are uniquely named.\n */\nfunction UniqueArgumentDefinitionNamesRule(context) {\n  return {\n    DirectiveDefinition(directiveNode) {\n      var _directiveNode$argume;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argumentNodes =\n        (_directiveNode$argume = directiveNode.arguments) !== null &&\n        _directiveNode$argume !== void 0\n          ? _directiveNode$argume\n          : [];\n      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);\n    },\n\n    InterfaceTypeDefinition: checkArgUniquenessPerField,\n    InterfaceTypeExtension: checkArgUniquenessPerField,\n    ObjectTypeDefinition: checkArgUniquenessPerField,\n    ObjectTypeExtension: checkArgUniquenessPerField,\n  };\n\n  function checkArgUniquenessPerField(typeNode) {\n    var _typeNode$fields;\n\n    const typeName = typeNode.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_typeNode$fields = typeNode.fields) !== null &&\n      _typeNode$fields !== void 0\n        ? _typeNode$fields\n        : [];\n\n    for (const fieldDef of fieldNodes) {\n      var _fieldDef$arguments;\n\n      const fieldName = fieldDef.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n\n      const argumentNodes =\n        (_fieldDef$arguments = fieldDef.arguments) !== null &&\n        _fieldDef$arguments !== void 0\n          ? _fieldDef$arguments\n          : [];\n      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);\n    }\n\n    return false;\n  }\n\n  function checkArgUniqueness(parentName, argumentNodes) {\n    const seenArgs = (0, _groupBy.groupBy)(\n      argumentNodes,\n      (arg) => arg.name.value,\n    );\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Argument \"${parentName}(${argName}:)\" can only be defined once.`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,iCAAiC,GAAG;AAE5C,IAAI;AAEJ,IAAI;AAEJ;;;;;CAKC,GACD,SAAS,kCAAkC,OAAO;IAChD,OAAO;QACL,qBAAoB,aAAa;YAC/B,IAAI;YAEJ,2DAA2D;YAE3D,kBAAkB,GAClB,MAAM,gBACJ,CAAC,wBAAwB,cAAc,SAAS,MAAM,QACtD,0BAA0B,KAAK,IAC3B,wBACA,EAAE;YACR,OAAO,mBAAmB,CAAC,CAAC,EAAE,cAAc,IAAI,CAAC,KAAK,EAAE,EAAE;QAC5D;QAEA,yBAAyB;QACzB,wBAAwB;QACxB,sBAAsB;QACtB,qBAAqB;IACvB;;;IAEA,SAAS,2BAA2B,QAAQ;QAC1C,IAAI;QAEJ,MAAM,WAAW,SAAS,IAAI,CAAC,KAAK,EAAE,2DAA2D;QAEjG,kBAAkB,GAElB,MAAM,aACJ,CAAC,mBAAmB,SAAS,MAAM,MAAM,QACzC,qBAAqB,KAAK,IACtB,mBACA,EAAE;QAER,KAAK,MAAM,YAAY,WAAY;YACjC,IAAI;YAEJ,MAAM,YAAY,SAAS,IAAI,CAAC,KAAK,EAAE,2DAA2D;YAElG,kBAAkB,GAElB,MAAM,gBACJ,CAAC,sBAAsB,SAAS,SAAS,MAAM,QAC/C,wBAAwB,KAAK,IACzB,sBACA,EAAE;YACR,mBAAmB,GAAG,SAAS,CAAC,EAAE,WAAW,EAAE;QACjD;QAEA,OAAO;IACT;IAEA,SAAS,mBAAmB,UAAU,EAAE,aAAa;QACnD,MAAM,WAAW,CAAC,GAAG,SAAS,OAAO,EACnC,eACA,CAAC,MAAQ,IAAI,IAAI,CAAC,KAAK;QAGzB,KAAK,MAAM,CAAC,SAAS,SAAS,IAAI,SAAU;YAC1C,IAAI,SAAS,MAAM,GAAG,GAAG;gBACvB,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,UAAU,EAAE,WAAW,CAAC,EAAE,QAAQ,6BAA6B,CAAC,EACjE;oBACE,OAAO,SAAS,GAAG,CAAC,CAAC,OAAS,KAAK,IAAI;gBACzC;YAGN;QACF;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4602, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.UniqueArgumentNamesRule = UniqueArgumentNamesRule;\n\nvar _groupBy = require('../../jsutils/groupBy.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * Unique argument names\n *\n * A GraphQL field or directive is only valid if all supplied arguments are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n */\nfunction UniqueArgumentNamesRule(context) {\n  return {\n    Field: checkArgUniqueness,\n    Directive: checkArgUniqueness,\n  };\n\n  function checkArgUniqueness(parentNode) {\n    var _parentNode$arguments;\n\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const argumentNodes =\n      (_parentNode$arguments = parentNode.arguments) !== null &&\n      _parentNode$arguments !== void 0\n        ? _parentNode$arguments\n        : [];\n    const seenArgs = (0, _groupBy.groupBy)(\n      argumentNodes,\n      (arg) => arg.name.value,\n    );\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `There can be only one argument named \"${argName}\".`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,uBAAuB,GAAG;AAElC,IAAI;AAEJ,IAAI;AAEJ;;;;;;;CAOC,GACD,SAAS,wBAAwB,OAAO;IACtC,OAAO;QACL,OAAO;QACP,WAAW;IACb;;;IAEA,SAAS,mBAAmB,UAAU;QACpC,IAAI;QAEJ,2DAA2D;QAE3D,kBAAkB,GAClB,MAAM,gBACJ,CAAC,wBAAwB,WAAW,SAAS,MAAM,QACnD,0BAA0B,KAAK,IAC3B,wBACA,EAAE;QACR,MAAM,WAAW,CAAC,GAAG,SAAS,OAAO,EACnC,eACA,CAAC,MAAQ,IAAI,IAAI,CAAC,KAAK;QAGzB,KAAK,MAAM,CAAC,SAAS,SAAS,IAAI,SAAU;YAC1C,IAAI,SAAS,MAAM,GAAG,GAAG;gBACvB,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,sCAAsC,EAAE,QAAQ,EAAE,CAAC,EACpD;oBACE,OAAO,SAAS,GAAG,CAAC,CAAC,OAAS,KAAK,IAAI;gBACzC;YAGN;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4642, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * Unique directive names\n *\n * A GraphQL document is only valid if all defined directives have unique names.\n */\nfunction UniqueDirectiveNamesRule(context) {\n  const knownDirectiveNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    DirectiveDefinition(node) {\n      const directiveName = node.name.value;\n\n      if (\n        schema !== null &&\n        schema !== void 0 &&\n        schema.getDirective(directiveName)\n      ) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Directive \"@${directiveName}\" already exists in the schema. It cannot be redefined.`,\n            {\n              nodes: node.name,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (knownDirectiveNames[directiveName]) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `There can be only one directive named \"@${directiveName}\".`,\n            {\n              nodes: [knownDirectiveNames[directiveName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownDirectiveNames[directiveName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,wBAAwB,GAAG;AAEnC,IAAI;AAEJ;;;;CAIC,GACD,SAAS,yBAAyB,OAAO;IACvC,MAAM,sBAAsB,OAAO,MAAM,CAAC;IAC1C,MAAM,SAAS,QAAQ,SAAS;IAChC,OAAO;QACL,qBAAoB,IAAI;YACtB,MAAM,gBAAgB,KAAK,IAAI,CAAC,KAAK;YAErC,IACE,WAAW,QACX,WAAW,KAAK,KAChB,OAAO,YAAY,CAAC,gBACpB;gBACA,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,YAAY,EAAE,cAAc,uDAAuD,CAAC,EACrF;oBACE,OAAO,KAAK,IAAI;gBAClB;gBAGJ;YACF;YAEA,IAAI,mBAAmB,CAAC,cAAc,EAAE;gBACtC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,wCAAwC,EAAE,cAAc,EAAE,CAAC,EAC5D;oBACE,OAAO;wBAAC,mBAAmB,CAAC,cAAc;wBAAE,KAAK,IAAI;qBAAC;gBACxD;YAGN,OAAO;gBACL,mBAAmB,CAAC,cAAc,GAAG,KAAK,IAAI;YAChD;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4683, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _predicates = require('../../language/predicates.js');\n\nvar _directives = require('../../type/directives.js');\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Unique-Per-Location\n */\nfunction UniqueDirectivesPerLocationRule(context) {\n  const uniqueDirectiveMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : _directives.specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  const schemaDirectives = Object.create(null);\n  const typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter(node) {\n      if (!('directives' in node) || !node.directives) {\n        return;\n      }\n\n      let seenDirectives;\n\n      if (\n        node.kind === _kinds.Kind.SCHEMA_DEFINITION ||\n        node.kind === _kinds.Kind.SCHEMA_EXTENSION\n      ) {\n        seenDirectives = schemaDirectives;\n      } else if (\n        (0, _predicates.isTypeDefinitionNode)(node) ||\n        (0, _predicates.isTypeExtensionNode)(node)\n      ) {\n        const typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (const directive of node.directives) {\n        const directiveName = directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(\n              new _GraphQLError.GraphQLError(\n                `The directive \"@${directiveName}\" can only be used once at this location.`,\n                {\n                  nodes: [seenDirectives[directiveName], directive],\n                },\n              ),\n            );\n          } else {\n            seenDirectives[directiveName] = directive;\n          }\n        }\n      }\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,+BAA+B,GAAG;AAE1C,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;;;CAOC,GACD,SAAS,gCAAgC,OAAO;IAC9C,MAAM,qBAAqB,OAAO,MAAM,CAAC;IACzC,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,oBAAoB,SACtB,OAAO,aAAa,KACpB,YAAY,mBAAmB;IAEnC,KAAK,MAAM,aAAa,kBAAmB;QACzC,kBAAkB,CAAC,UAAU,IAAI,CAAC,GAAG,CAAC,UAAU,YAAY;IAC9D;IAEA,MAAM,iBAAiB,QAAQ,WAAW,GAAG,WAAW;IAExD,KAAK,MAAM,OAAO,eAAgB;QAChC,IAAI,IAAI,IAAI,KAAK,OAAO,IAAI,CAAC,oBAAoB,EAAE;YACjD,kBAAkB,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,UAAU;QACtD;IACF;IAEA,MAAM,mBAAmB,OAAO,MAAM,CAAC;IACvC,MAAM,oBAAoB,OAAO,MAAM,CAAC;IACxC,OAAO;QACL,uEAAuE;QACvE,sEAAsE;QACtE,0BAA0B;QAC1B,OAAM,IAAI;YACR,IAAI,CAAC,CAAC,gBAAgB,IAAI,KAAK,CAAC,KAAK,UAAU,EAAE;gBAC/C;YACF;YAEA,IAAI;YAEJ,IACE,KAAK,IAAI,KAAK,OAAO,IAAI,CAAC,iBAAiB,IAC3C,KAAK,IAAI,KAAK,OAAO,IAAI,CAAC,gBAAgB,EAC1C;gBACA,iBAAiB;YACnB,OAAO,IACL,CAAC,GAAG,YAAY,oBAAoB,EAAE,SACtC,CAAC,GAAG,YAAY,mBAAmB,EAAE,OACrC;gBACA,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;gBAChC,iBAAiB,iBAAiB,CAAC,SAAS;gBAE5C,IAAI,mBAAmB,WAAW;oBAChC,iBAAiB,CAAC,SAAS,GAAG,iBAAiB,OAAO,MAAM,CAAC;gBAC/D;YACF,OAAO;gBACL,iBAAiB,OAAO,MAAM,CAAC;YACjC;YAEA,KAAK,MAAM,aAAa,KAAK,UAAU,CAAE;gBACvC,MAAM,gBAAgB,UAAU,IAAI,CAAC,KAAK;gBAE1C,IAAI,kBAAkB,CAAC,cAAc,EAAE;oBACrC,IAAI,cAAc,CAAC,cAAc,EAAE;wBACjC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,gBAAgB,EAAE,cAAc,yCAAyC,CAAC,EAC3E;4BACE,OAAO;gCAAC,cAAc,CAAC,cAAc;gCAAE;6BAAU;wBACnD;oBAGN,OAAO;wBACL,cAAc,CAAC,cAAc,GAAG;oBAClC;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4757, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _definition = require('../../type/definition.js');\n\n/**\n * Unique enum value names\n *\n * A GraphQL enum type is only valid if all its values are uniquely named.\n */\nfunction UniqueEnumValueNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownValueNames = Object.create(null);\n  return {\n    EnumTypeDefinition: checkValueUniqueness,\n    EnumTypeExtension: checkValueUniqueness,\n  };\n\n  function checkValueUniqueness(node) {\n    var _node$values;\n\n    const typeName = node.name.value;\n\n    if (!knownValueNames[typeName]) {\n      knownValueNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const valueNodes =\n      (_node$values = node.values) !== null && _node$values !== void 0\n        ? _node$values\n        : [];\n    const valueNames = knownValueNames[typeName];\n\n    for (const valueDef of valueNodes) {\n      const valueName = valueDef.name.value;\n      const existingType = existingTypeMap[typeName];\n\n      if (\n        (0, _definition.isEnumType)(existingType) &&\n        existingType.getValue(valueName)\n      ) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: valueDef.name,\n            },\n          ),\n        );\n      } else if (valueNames[valueName]) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" can only be defined once.`,\n            {\n              nodes: [valueNames[valueName], valueDef.name],\n            },\n          ),\n        );\n      } else {\n        valueNames[valueName] = valueDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,wBAAwB,GAAG;AAEnC,IAAI;AAEJ,IAAI;AAEJ;;;;CAIC,GACD,SAAS,yBAAyB,OAAO;IACvC,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,kBAAkB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACrE,MAAM,kBAAkB,OAAO,MAAM,CAAC;IACtC,OAAO;QACL,oBAAoB;QACpB,mBAAmB;IACrB;;;IAEA,SAAS,qBAAqB,IAAI;QAChC,IAAI;QAEJ,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;QAEhC,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE;YAC9B,eAAe,CAAC,SAAS,GAAG,OAAO,MAAM,CAAC;QAC5C,EAAE,2DAA2D;QAE7D,kBAAkB,GAElB,MAAM,aACJ,CAAC,eAAe,KAAK,MAAM,MAAM,QAAQ,iBAAiB,KAAK,IAC3D,eACA,EAAE;QACR,MAAM,aAAa,eAAe,CAAC,SAAS;QAE5C,KAAK,MAAM,YAAY,WAAY;YACjC,MAAM,YAAY,SAAS,IAAI,CAAC,KAAK;YACrC,MAAM,eAAe,eAAe,CAAC,SAAS;YAE9C,IACE,CAAC,GAAG,YAAY,UAAU,EAAE,iBAC5B,aAAa,QAAQ,CAAC,YACtB;gBACA,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,YAAY,EAAE,SAAS,CAAC,EAAE,UAAU,iFAAiF,CAAC,EACvH;oBACE,OAAO,SAAS,IAAI;gBACtB;YAGN,OAAO,IAAI,UAAU,CAAC,UAAU,EAAE;gBAChC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,YAAY,EAAE,SAAS,CAAC,EAAE,UAAU,2BAA2B,CAAC,EACjE;oBACE,OAAO;wBAAC,UAAU,CAAC,UAAU;wBAAE,SAAS,IAAI;qBAAC;gBAC/C;YAGN,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,SAAS,IAAI;YACvC;QACF;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4812, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _definition = require('../../type/definition.js');\n\n/**\n * Unique field definition names\n *\n * A GraphQL complex type is only valid if all its fields are uniquely named.\n */\nfunction UniqueFieldDefinitionNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownFieldNames = Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness,\n  };\n\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n\n    const typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_node$fields = node.fields) !== null && _node$fields !== void 0\n        ? _node$fields\n        : [];\n    const fieldNames = knownFieldNames[typeName];\n\n    for (const fieldDef of fieldNodes) {\n      const fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: fieldDef.name,\n            },\n          ),\n        );\n      } else if (fieldNames[fieldName]) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Field \"${typeName}.${fieldName}\" can only be defined once.`,\n            {\n              nodes: [fieldNames[fieldName], fieldDef.name],\n            },\n          ),\n        );\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasField(type, fieldName) {\n  if (\n    (0, _definition.isObjectType)(type) ||\n    (0, _definition.isInterfaceType)(type) ||\n    (0, _definition.isInputObjectType)(type)\n  ) {\n    return type.getFields()[fieldName] != null;\n  }\n\n  return false;\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,8BAA8B,GAAG;AAEzC,IAAI;AAEJ,IAAI;AAEJ;;;;CAIC,GACD,SAAS,+BAA+B,OAAO;IAC7C,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,kBAAkB,SAAS,OAAO,UAAU,KAAK,OAAO,MAAM,CAAC;IACrE,MAAM,kBAAkB,OAAO,MAAM,CAAC;IACtC,OAAO;QACL,2BAA2B;QAC3B,0BAA0B;QAC1B,yBAAyB;QACzB,wBAAwB;QACxB,sBAAsB;QACtB,qBAAqB;IACvB;;;IAEA,SAAS,qBAAqB,IAAI;QAChC,IAAI;QAEJ,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;QAEhC,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE;YAC9B,eAAe,CAAC,SAAS,GAAG,OAAO,MAAM,CAAC;QAC5C,EAAE,2DAA2D;QAE7D,kBAAkB,GAElB,MAAM,aACJ,CAAC,eAAe,KAAK,MAAM,MAAM,QAAQ,iBAAiB,KAAK,IAC3D,eACA,EAAE;QACR,MAAM,aAAa,eAAe,CAAC,SAAS;QAE5C,KAAK,MAAM,YAAY,WAAY;YACjC,MAAM,YAAY,SAAS,IAAI,CAAC,KAAK;YAErC,IAAI,SAAS,eAAe,CAAC,SAAS,EAAE,YAAY;gBAClD,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,UAAU,iFAAiF,CAAC,EAClH;oBACE,OAAO,SAAS,IAAI;gBACtB;YAGN,OAAO,IAAI,UAAU,CAAC,UAAU,EAAE;gBAChC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,OAAO,EAAE,SAAS,CAAC,EAAE,UAAU,2BAA2B,CAAC,EAC5D;oBACE,OAAO;wBAAC,UAAU,CAAC,UAAU;wBAAE,SAAS,IAAI;qBAAC;gBAC/C;YAGN,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,SAAS,IAAI;YACvC;QACF;QAEA,OAAO;IACT;AACF;AAEA,SAAS,SAAS,IAAI,EAAE,SAAS;IAC/B,IACE,CAAC,GAAG,YAAY,YAAY,EAAE,SAC9B,CAAC,GAAG,YAAY,eAAe,EAAE,SACjC,CAAC,GAAG,YAAY,iBAAiB,EAAE,OACnC;QACA,OAAO,KAAK,SAAS,EAAE,CAAC,UAAU,IAAI;IACxC;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4876, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.UniqueFragmentNamesRule = UniqueFragmentNamesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Name-Uniqueness\n */\nfunction UniqueFragmentNamesRule(context) {\n  const knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      const fragmentName = node.name.value;\n\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `There can be only one fragment named \"${fragmentName}\".`,\n            {\n              nodes: [knownFragmentNames[fragmentName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,uBAAuB,GAAG;AAElC,IAAI;AAEJ;;;;;;CAMC,GACD,SAAS,wBAAwB,OAAO;IACtC,MAAM,qBAAqB,OAAO,MAAM,CAAC;IACzC,OAAO;QACL,qBAAqB,IAAM;QAE3B,oBAAmB,IAAI;YACrB,MAAM,eAAe,KAAK,IAAI,CAAC,KAAK;YAEpC,IAAI,kBAAkB,CAAC,aAAa,EAAE;gBACpC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,sCAAsC,EAAE,aAAa,EAAE,CAAC,EACzD;oBACE,OAAO;wBAAC,kBAAkB,CAAC,aAAa;wBAAE,KAAK,IAAI;qBAAC;gBACtD;YAGN,OAAO;gBACL,kBAAkB,CAAC,aAAa,GAAG,KAAK,IAAI;YAC9C;YAEA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4913, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;\n\nvar _invariant = require('../../jsutils/invariant.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * Unique input field names\n *\n * A GraphQL input object value is only valid if all supplied fields are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Input-Object-Field-Uniqueness\n */\nfunction UniqueInputFieldNamesRule(context) {\n  const knownNameStack = [];\n  let knownNames = Object.create(null);\n  return {\n    ObjectValue: {\n      enter() {\n        knownNameStack.push(knownNames);\n        knownNames = Object.create(null);\n      },\n\n      leave() {\n        const prevKnownNames = knownNameStack.pop();\n        prevKnownNames || (0, _invariant.invariant)(false);\n        knownNames = prevKnownNames;\n      },\n    },\n\n    ObjectField(node) {\n      const fieldName = node.name.value;\n\n      if (knownNames[fieldName]) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `There can be only one input field named \"${fieldName}\".`,\n            {\n              nodes: [knownNames[fieldName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,yBAAyB,GAAG;AAEpC,IAAI;AAEJ,IAAI;AAEJ;;;;;;;CAOC,GACD,SAAS,0BAA0B,OAAO;IACxC,MAAM,iBAAiB,EAAE;IACzB,IAAI,aAAa,OAAO,MAAM,CAAC;IAC/B,OAAO;QACL,aAAa;YACX;gBACE,eAAe,IAAI,CAAC;gBACpB,aAAa,OAAO,MAAM,CAAC;YAC7B;YAEA;gBACE,MAAM,iBAAiB,eAAe,GAAG;gBACzC,kBAAkB,CAAC,GAAG,WAAW,SAAS,EAAE;gBAC5C,aAAa;YACf;QACF;QAEA,aAAY,IAAI;YACd,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK;YAEjC,IAAI,UAAU,CAAC,UAAU,EAAE;gBACzB,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,yCAAyC,EAAE,UAAU,EAAE,CAAC,EACzD;oBACE,OAAO;wBAAC,UAAU,CAAC,UAAU;wBAAE,KAAK,IAAI;qBAAC;gBAC3C;YAGN,OAAO;gBACL,UAAU,CAAC,UAAU,GAAG,KAAK,IAAI;YACnC;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4962, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueOperationNamesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.UniqueOperationNamesRule = UniqueOperationNamesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Operation-Name-Uniqueness\n */\nfunction UniqueOperationNamesRule(context) {\n  const knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition(node) {\n      const operationName = node.name;\n\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(\n            new _GraphQLError.GraphQLError(\n              `There can be only one operation named \"${operationName.value}\".`,\n              {\n                nodes: [\n                  knownOperationNames[operationName.value],\n                  operationName,\n                ],\n              },\n            ),\n          );\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n\n      return false;\n    },\n\n    FragmentDefinition: () => false,\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,wBAAwB,GAAG;AAEnC,IAAI;AAEJ;;;;;;CAMC,GACD,SAAS,yBAAyB,OAAO;IACvC,MAAM,sBAAsB,OAAO,MAAM,CAAC;IAC1C,OAAO;QACL,qBAAoB,IAAI;YACtB,MAAM,gBAAgB,KAAK,IAAI;YAE/B,IAAI,eAAe;gBACjB,IAAI,mBAAmB,CAAC,cAAc,KAAK,CAAC,EAAE;oBAC5C,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,uCAAuC,EAAE,cAAc,KAAK,CAAC,EAAE,CAAC,EACjE;wBACE,OAAO;4BACL,mBAAmB,CAAC,cAAc,KAAK,CAAC;4BACxC;yBACD;oBACH;gBAGN,OAAO;oBACL,mBAAmB,CAAC,cAAc,KAAK,CAAC,GAAG;gBAC7C;YACF;YAEA,OAAO;QACT;QAEA,oBAAoB,IAAM;IAC5B;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5001, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueOperationTypesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.UniqueOperationTypesRule = UniqueOperationTypesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * Unique operation types\n *\n * A GraphQL document is only valid if it has only one type per operation.\n */\nfunction UniqueOperationTypesRule(context) {\n  const schema = context.getSchema();\n  const definedOperationTypes = Object.create(null);\n  const existingOperationTypes = schema\n    ? {\n        query: schema.getQueryType(),\n        mutation: schema.getMutationType(),\n        subscription: schema.getSubscriptionType(),\n      }\n    : {};\n  return {\n    SchemaDefinition: checkOperationTypes,\n    SchemaExtension: checkOperationTypes,\n  };\n\n  function checkOperationTypes(node) {\n    var _node$operationTypes;\n\n    // See: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const operationTypesNodes =\n      (_node$operationTypes = node.operationTypes) !== null &&\n      _node$operationTypes !== void 0\n        ? _node$operationTypes\n        : [];\n\n    for (const operationType of operationTypesNodes) {\n      const operation = operationType.operation;\n      const alreadyDefinedOperationType = definedOperationTypes[operation];\n\n      if (existingOperationTypes[operation]) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Type for ${operation} already defined in the schema. It cannot be redefined.`,\n            {\n              nodes: operationType,\n            },\n          ),\n        );\n      } else if (alreadyDefinedOperationType) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `There can be only one ${operation} type in schema.`,\n            {\n              nodes: [alreadyDefinedOperationType, operationType],\n            },\n          ),\n        );\n      } else {\n        definedOperationTypes[operation] = operationType;\n      }\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,wBAAwB,GAAG;AAEnC,IAAI;AAEJ;;;;CAIC,GACD,SAAS,yBAAyB,OAAO;IACvC,MAAM,SAAS,QAAQ,SAAS;IAChC,MAAM,wBAAwB,OAAO,MAAM,CAAC;IAC5C,MAAM,yBAAyB,SAC3B;QACE,OAAO,OAAO,YAAY;QAC1B,UAAU,OAAO,eAAe;QAChC,cAAc,OAAO,mBAAmB;IAC1C,IACA,CAAC;IACL,OAAO;QACL,kBAAkB;QAClB,iBAAiB;IACnB;;;IAEA,SAAS,oBAAoB,IAAI;QAC/B,IAAI;QAEJ,yDAAyD;QAEzD,kBAAkB,GAClB,MAAM,sBACJ,CAAC,uBAAuB,KAAK,cAAc,MAAM,QACjD,yBAAyB,KAAK,IAC1B,uBACA,EAAE;QAER,KAAK,MAAM,iBAAiB,oBAAqB;YAC/C,MAAM,YAAY,cAAc,SAAS;YACzC,MAAM,8BAA8B,qBAAqB,CAAC,UAAU;YAEpE,IAAI,sBAAsB,CAAC,UAAU,EAAE;gBACrC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,SAAS,EAAE,UAAU,uDAAuD,CAAC,EAC9E;oBACE,OAAO;gBACT;YAGN,OAAO,IAAI,6BAA6B;gBACtC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,sBAAsB,EAAE,UAAU,gBAAgB,CAAC,EACpD;oBACE,OAAO;wBAAC;wBAA6B;qBAAc;gBACrD;YAGN,OAAO;gBACL,qBAAqB,CAAC,UAAU,GAAG;YACrC;QACF;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5055, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.UniqueTypeNamesRule = UniqueTypeNamesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * Unique type names\n *\n * A GraphQL document is only valid if all defined types have unique names.\n */\nfunction UniqueTypeNamesRule(context) {\n  const knownTypeNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName,\n  };\n\n  function checkTypeName(node) {\n    const typeName = node.name.value;\n\n    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {\n      context.reportError(\n        new _GraphQLError.GraphQLError(\n          `Type \"${typeName}\" already exists in the schema. It cannot also be defined in this type definition.`,\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n      return;\n    }\n\n    if (knownTypeNames[typeName]) {\n      context.reportError(\n        new _GraphQLError.GraphQLError(\n          `There can be only one type named \"${typeName}\".`,\n          {\n            nodes: [knownTypeNames[typeName], node.name],\n          },\n        ),\n      );\n    } else {\n      knownTypeNames[typeName] = node.name;\n    }\n\n    return false;\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,mBAAmB,GAAG;AAE9B,IAAI;AAEJ;;;;CAIC,GACD,SAAS,oBAAoB,OAAO;IAClC,MAAM,iBAAiB,OAAO,MAAM,CAAC;IACrC,MAAM,SAAS,QAAQ,SAAS;IAChC,OAAO;QACL,sBAAsB;QACtB,sBAAsB;QACtB,yBAAyB;QACzB,qBAAqB;QACrB,oBAAoB;QACpB,2BAA2B;IAC7B;;;IAEA,SAAS,cAAc,IAAI;QACzB,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK;QAEhC,IAAI,WAAW,QAAQ,WAAW,KAAK,KAAK,OAAO,OAAO,CAAC,WAAW;YACpE,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,MAAM,EAAE,SAAS,kFAAkF,CAAC,EACrG;gBACE,OAAO,KAAK,IAAI;YAClB;YAGJ;QACF;QAEA,IAAI,cAAc,CAAC,SAAS,EAAE;YAC5B,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,kCAAkC,EAAE,SAAS,EAAE,CAAC,EACjD;gBACE,OAAO;oBAAC,cAAc,CAAC,SAAS;oBAAE,KAAK,IAAI;iBAAC;YAC9C;QAGN,OAAO;YACL,cAAc,CAAC,SAAS,GAAG,KAAK,IAAI;QACtC;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5104, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/UniqueVariableNamesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.UniqueVariableNamesRule = UniqueVariableNamesRule;\n\nvar _groupBy = require('../../jsutils/groupBy.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\n/**\n * Unique variable names\n *\n * A GraphQL operation is only valid if all its variables are uniquely named.\n */\nfunction UniqueVariableNamesRule(context) {\n  return {\n    OperationDefinition(operationNode) {\n      var _operationNode$variab;\n\n      // See: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const variableDefinitions =\n        (_operationNode$variab = operationNode.variableDefinitions) !== null &&\n        _operationNode$variab !== void 0\n          ? _operationNode$variab\n          : [];\n      const seenVariableDefinitions = (0, _groupBy.groupBy)(\n        variableDefinitions,\n        (node) => node.variable.name.value,\n      );\n\n      for (const [variableName, variableNodes] of seenVariableDefinitions) {\n        if (variableNodes.length > 1) {\n          context.reportError(\n            new _GraphQLError.GraphQLError(\n              `There can be only one variable named \"$${variableName}\".`,\n              {\n                nodes: variableNodes.map((node) => node.variable.name),\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,uBAAuB,GAAG;AAElC,IAAI;AAEJ,IAAI;AAEJ;;;;CAIC,GACD,SAAS,wBAAwB,OAAO;IACtC,OAAO;QACL,qBAAoB,aAAa;YAC/B,IAAI;YAEJ,yDAAyD;YAEzD,kBAAkB,GAClB,MAAM,sBACJ,CAAC,wBAAwB,cAAc,mBAAmB,MAAM,QAChE,0BAA0B,KAAK,IAC3B,wBACA,EAAE;YACR,MAAM,0BAA0B,CAAC,GAAG,SAAS,OAAO,EAClD,qBACA,CAAC,OAAS,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK;YAGpC,KAAK,MAAM,CAAC,cAAc,cAAc,IAAI,wBAAyB;gBACnE,IAAI,cAAc,MAAM,GAAG,GAAG;oBAC5B,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,uCAAuC,EAAE,aAAa,EAAE,CAAC,EAC1D;wBACE,OAAO,cAAc,GAAG,CAAC,CAAC,OAAS,KAAK,QAAQ,CAAC,IAAI;oBACvD;gBAGN;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5137, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _keyMap = require('../../jsutils/keyMap.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _printer = require('../../language/printer.js');\n\nvar _definition = require('../../type/definition.js');\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n *\n * See https://spec.graphql.org/draft/#sec-Values-of-Correct-Type\n */\nfunction ValuesOfCorrectTypeRule(context) {\n  let variableDefinitions = {};\n  return {\n    OperationDefinition: {\n      enter() {\n        variableDefinitions = {};\n      },\n    },\n\n    VariableDefinition(definition) {\n      variableDefinitions[definition.variable.name.value] = definition;\n    },\n\n    ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      const type = (0, _definition.getNullableType)(\n        context.getParentInputType(),\n      );\n\n      if (!(0, _definition.isListType)(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n\n    ObjectValue(node) {\n      const type = (0, _definition.getNamedType)(context.getInputType());\n\n      if (!(0, _definition.isInputObjectType)(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n      const fieldNodeMap = (0, _keyMap.keyMap)(\n        node.fields,\n        (field) => field.name.value,\n      );\n\n      for (const fieldDef of Object.values(type.getFields())) {\n        const fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {\n          const typeStr = (0, _inspect.inspect)(fieldDef.type);\n          context.reportError(\n            new _GraphQLError.GraphQLError(\n              `Field \"${type.name}.${fieldDef.name}\" of required type \"${typeStr}\" was not provided.`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n\n      if (type.isOneOf) {\n        validateOneOfInputObject(\n          context,\n          node,\n          type,\n          fieldNodeMap,\n          variableDefinitions,\n        );\n      }\n    },\n\n    ObjectField(node) {\n      const parentType = (0, _definition.getNamedType)(\n        context.getParentInputType(),\n      );\n      const fieldType = context.getInputType();\n\n      if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {\n        const suggestions = (0, _suggestionList.suggestionList)(\n          node.name.value,\n          Object.keys(parentType.getFields()),\n        );\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Field \"${node.name.value}\" is not defined by type \"${parentType.name}\".` +\n              (0, _didYouMean.didYouMean)(suggestions),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    NullValue(node) {\n      const type = context.getInputType();\n\n      if ((0, _definition.isNonNullType)(type)) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Expected value of type \"${(0, _inspect.inspect)(\n              type,\n            )}\", found ${(0, _printer.print)(node)}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    EnumValue: (node) => isValidValueNode(context, node),\n    IntValue: (node) => isValidValueNode(context, node),\n    FloatValue: (node) => isValidValueNode(context, node),\n    StringValue: (node) => isValidValueNode(context, node),\n    BooleanValue: (node) => isValidValueNode(context, node),\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  const locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  const type = (0, _definition.getNamedType)(locationType);\n\n  if (!(0, _definition.isLeafType)(type)) {\n    const typeStr = (0, _inspect.inspect)(locationType);\n    context.reportError(\n      new _GraphQLError.GraphQLError(\n        `Expected value of type \"${typeStr}\", found ${(0, _printer.print)(\n          node,\n        )}.`,\n        {\n          nodes: node,\n        },\n      ),\n    );\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n  try {\n    const parseResult = type.parseLiteral(\n      node,\n      undefined,\n      /* variables */\n    );\n\n    if (parseResult === undefined) {\n      const typeStr = (0, _inspect.inspect)(locationType);\n      context.reportError(\n        new _GraphQLError.GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${(0, _printer.print)(\n            node,\n          )}.`,\n          {\n            nodes: node,\n          },\n        ),\n      );\n    }\n  } catch (error) {\n    const typeStr = (0, _inspect.inspect)(locationType);\n\n    if (error instanceof _GraphQLError.GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(\n        new _GraphQLError.GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${(0, _printer.print)(\n            node,\n          )}; ` + error.message,\n          {\n            nodes: node,\n            originalError: error,\n          },\n        ),\n      );\n    }\n  }\n}\n\nfunction validateOneOfInputObject(\n  context,\n  node,\n  type,\n  fieldNodeMap,\n  variableDefinitions,\n) {\n  var _fieldNodeMap$keys$;\n\n  const keys = Object.keys(fieldNodeMap);\n  const isNotExactlyOneField = keys.length !== 1;\n\n  if (isNotExactlyOneField) {\n    context.reportError(\n      new _GraphQLError.GraphQLError(\n        `OneOf Input Object \"${type.name}\" must specify exactly one key.`,\n        {\n          nodes: [node],\n        },\n      ),\n    );\n    return;\n  }\n\n  const value =\n    (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null ||\n    _fieldNodeMap$keys$ === void 0\n      ? void 0\n      : _fieldNodeMap$keys$.value;\n  const isNullLiteral = !value || value.kind === _kinds.Kind.NULL;\n  const isVariable =\n    (value === null || value === void 0 ? void 0 : value.kind) ===\n    _kinds.Kind.VARIABLE;\n\n  if (isNullLiteral) {\n    context.reportError(\n      new _GraphQLError.GraphQLError(\n        `Field \"${type.name}.${keys[0]}\" must be non-null.`,\n        {\n          nodes: [node],\n        },\n      ),\n    );\n    return;\n  }\n\n  if (isVariable) {\n    const variableName = value.name.value;\n    const definition = variableDefinitions[variableName];\n    const isNullableVariable =\n      definition.type.kind !== _kinds.Kind.NON_NULL_TYPE;\n\n    if (isNullableVariable) {\n      context.reportError(\n        new _GraphQLError.GraphQLError(\n          `Variable \"${variableName}\" must be non-nullable to be used for OneOf Input Object \"${type.name}\".`,\n          {\n            nodes: [node],\n          },\n        ),\n      );\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5301, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.VariablesAreInputTypesRule = VariablesAreInputTypesRule;\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _printer = require('../../language/printer.js');\n\nvar _definition = require('../../type/definition.js');\n\nvar _typeFromAST = require('../../utilities/typeFromAST.js');\n\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n *\n * See https://spec.graphql.org/draft/#sec-Variables-Are-Input-Types\n */\nfunction VariablesAreInputTypesRule(context) {\n  return {\n    VariableDefinition(node) {\n      const type = (0, _typeFromAST.typeFromAST)(\n        context.getSchema(),\n        node.type,\n      );\n\n      if (type !== undefined && !(0, _definition.isInputType)(type)) {\n        const variableName = node.variable.name.value;\n        const typeName = (0, _printer.print)(node.type);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Variable \"$${variableName}\" cannot be non-input type \"${typeName}\".`,\n            {\n              nodes: node.type,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,0BAA0B,GAAG;AAErC,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;;;CAOC,GACD,SAAS,2BAA2B,OAAO;IACzC,OAAO;QACL,oBAAmB,IAAI;YACrB,MAAM,OAAO,CAAC,GAAG,aAAa,WAAW,EACvC,QAAQ,SAAS,IACjB,KAAK,IAAI;YAGX,IAAI,SAAS,aAAa,CAAC,CAAC,GAAG,YAAY,WAAW,EAAE,OAAO;gBAC7D,MAAM,eAAe,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK;gBAC7C,MAAM,WAAW,CAAC,GAAG,SAAS,KAAK,EAAE,KAAK,IAAI;gBAC9C,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,WAAW,EAAE,aAAa,4BAA4B,EAAE,SAAS,EAAE,CAAC,EACrE;oBACE,OAAO,KAAK,IAAI;gBAClB;YAGN;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5336, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _kinds = require('../../language/kinds.js');\n\nvar _definition = require('../../type/definition.js');\n\nvar _typeComparators = require('../../utilities/typeComparators.js');\n\nvar _typeFromAST = require('../../utilities/typeFromAST.js');\n\n/**\n * Variables in allowed position\n *\n * Variable usages must be compatible with the arguments they are passed to.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Usages-are-Allowed\n */\nfunction VariablesInAllowedPositionRule(context) {\n  let varDefMap = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        varDefMap = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node, type, defaultValue, parentType } of usages) {\n          const varName = node.name.value;\n          const varDef = varDefMap[varName];\n\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            const schema = context.getSchema();\n            const varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);\n\n            if (\n              varType &&\n              !allowedVariableUsage(\n                schema,\n                varType,\n                varDef.defaultValue,\n                type,\n                defaultValue,\n              )\n            ) {\n              const varTypeStr = (0, _inspect.inspect)(varType);\n              const typeStr = (0, _inspect.inspect)(type);\n              context.reportError(\n                new _GraphQLError.GraphQLError(\n                  `Variable \"$${varName}\" of type \"${varTypeStr}\" used in position expecting type \"${typeStr}\".`,\n                  {\n                    nodes: [varDef, node],\n                  },\n                ),\n              );\n            }\n\n            if (\n              (0, _definition.isInputObjectType)(parentType) &&\n              parentType.isOneOf &&\n              (0, _definition.isNullableType)(varType)\n            ) {\n              context.reportError(\n                new _GraphQLError.GraphQLError(\n                  `Variable \"$${varName}\" is of type \"${varType}\" but must be non-nullable to be used for OneOf Input Object \"${parentType}\".`,\n                  {\n                    nodes: [varDef, node],\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    },\n  };\n}\n/**\n * Returns true if the variable is allowed in the location it was found,\n * which includes considering if default values exist for either the variable\n * or the location at which it is located.\n */\n\nfunction allowedVariableUsage(\n  schema,\n  varType,\n  varDefaultValue,\n  locationType,\n  locationDefaultValue,\n) {\n  if (\n    (0, _definition.isNonNullType)(locationType) &&\n    !(0, _definition.isNonNullType)(varType)\n  ) {\n    const hasNonNullVariableDefaultValue =\n      varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;\n    const hasLocationDefaultValue = locationDefaultValue !== undefined;\n\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n\n    const nullableLocationType = locationType.ofType;\n    return (0, _typeComparators.isTypeSubTypeOf)(\n      schema,\n      varType,\n      nullableLocationType,\n    );\n  }\n\n  return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,8BAA8B,GAAG;AAEzC,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;;CAMC,GACD,SAAS,+BAA+B,OAAO;IAC7C,IAAI,YAAY,OAAO,MAAM,CAAC;IAC9B,OAAO;QACL,qBAAqB;YACnB;gBACE,YAAY,OAAO,MAAM,CAAC;YAC5B;YAEA,OAAM,SAAS;gBACb,MAAM,SAAS,QAAQ,0BAA0B,CAAC;gBAElD,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,EAAE,UAAU,EAAE,IAAI,OAAQ;oBAC7D,MAAM,UAAU,KAAK,IAAI,CAAC,KAAK;oBAC/B,MAAM,SAAS,SAAS,CAAC,QAAQ;oBAEjC,IAAI,UAAU,MAAM;wBAClB,kEAAkE;wBAClE,iEAAiE;wBACjE,oEAAoE;wBACpE,oEAAoE;wBACpE,+CAA+C;wBAC/C,MAAM,SAAS,QAAQ,SAAS;wBAChC,MAAM,UAAU,CAAC,GAAG,aAAa,WAAW,EAAE,QAAQ,OAAO,IAAI;wBAEjE,IACE,WACA,CAAC,qBACC,QACA,SACA,OAAO,YAAY,EACnB,MACA,eAEF;4BACA,MAAM,aAAa,CAAC,GAAG,SAAS,OAAO,EAAE;4BACzC,MAAM,UAAU,CAAC,GAAG,SAAS,OAAO,EAAE;4BACtC,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,WAAW,EAAE,QAAQ,WAAW,EAAE,WAAW,mCAAmC,EAAE,QAAQ,EAAE,CAAC,EAC9F;gCACE,OAAO;oCAAC;oCAAQ;iCAAK;4BACvB;wBAGN;wBAEA,IACE,CAAC,GAAG,YAAY,iBAAiB,EAAE,eACnC,WAAW,OAAO,IAClB,CAAC,GAAG,YAAY,cAAc,EAAE,UAChC;4BACA,QAAQ,WAAW,CACjB,IAAI,cAAc,YAAY,CAC5B,CAAC,WAAW,EAAE,QAAQ,cAAc,EAAE,QAAQ,8DAA8D,EAAE,WAAW,EAAE,CAAC,EAC5H;gCACE,OAAO;oCAAC;oCAAQ;iCAAK;4BACvB;wBAGN;oBACF;gBACF;YACF;QACF;QAEA,oBAAmB,IAAI;YACrB,SAAS,CAAC,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG;QACxC;IACF;AACF;AACA;;;;CAIC,GAED,SAAS,qBACP,MAAM,EACN,OAAO,EACP,eAAe,EACf,YAAY,EACZ,oBAAoB;IAEpB,IACE,CAAC,GAAG,YAAY,aAAa,EAAE,iBAC/B,CAAC,CAAC,GAAG,YAAY,aAAa,EAAE,UAChC;QACA,MAAM,iCACJ,mBAAmB,QAAQ,gBAAgB,IAAI,KAAK,OAAO,IAAI,CAAC,IAAI;QACtE,MAAM,0BAA0B,yBAAyB;QAEzD,IAAI,CAAC,kCAAkC,CAAC,yBAAyB;YAC/D,OAAO;QACT;QAEA,MAAM,uBAAuB,aAAa,MAAM;QAChD,OAAO,CAAC,GAAG,iBAAiB,eAAe,EACzC,QACA,SACA;IAEJ;IAEA,OAAO,CAAC,GAAG,iBAAiB,eAAe,EAAE,QAAQ,SAAS;AAChE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5421, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/specifiedRules.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.specifiedSDLRules =\n  exports.specifiedRules =\n  exports.recommendedRules =\n    void 0;\n\nvar _ExecutableDefinitionsRule = require('./rules/ExecutableDefinitionsRule.js');\n\nvar _FieldsOnCorrectTypeRule = require('./rules/FieldsOnCorrectTypeRule.js');\n\nvar _FragmentsOnCompositeTypesRule = require('./rules/FragmentsOnCompositeTypesRule.js');\n\nvar _KnownArgumentNamesRule = require('./rules/KnownArgumentNamesRule.js');\n\nvar _KnownDirectivesRule = require('./rules/KnownDirectivesRule.js');\n\nvar _KnownFragmentNamesRule = require('./rules/KnownFragmentNamesRule.js');\n\nvar _KnownTypeNamesRule = require('./rules/KnownTypeNamesRule.js');\n\nvar _LoneAnonymousOperationRule = require('./rules/LoneAnonymousOperationRule.js');\n\nvar _LoneSchemaDefinitionRule = require('./rules/LoneSchemaDefinitionRule.js');\n\nvar _MaxIntrospectionDepthRule = require('./rules/MaxIntrospectionDepthRule.js');\n\nvar _NoFragmentCyclesRule = require('./rules/NoFragmentCyclesRule.js');\n\nvar _NoUndefinedVariablesRule = require('./rules/NoUndefinedVariablesRule.js');\n\nvar _NoUnusedFragmentsRule = require('./rules/NoUnusedFragmentsRule.js');\n\nvar _NoUnusedVariablesRule = require('./rules/NoUnusedVariablesRule.js');\n\nvar _OverlappingFieldsCanBeMergedRule = require('./rules/OverlappingFieldsCanBeMergedRule.js');\n\nvar _PossibleFragmentSpreadsRule = require('./rules/PossibleFragmentSpreadsRule.js');\n\nvar _PossibleTypeExtensionsRule = require('./rules/PossibleTypeExtensionsRule.js');\n\nvar _ProvidedRequiredArgumentsRule = require('./rules/ProvidedRequiredArgumentsRule.js');\n\nvar _ScalarLeafsRule = require('./rules/ScalarLeafsRule.js');\n\nvar _SingleFieldSubscriptionsRule = require('./rules/SingleFieldSubscriptionsRule.js');\n\nvar _UniqueArgumentDefinitionNamesRule = require('./rules/UniqueArgumentDefinitionNamesRule.js');\n\nvar _UniqueArgumentNamesRule = require('./rules/UniqueArgumentNamesRule.js');\n\nvar _UniqueDirectiveNamesRule = require('./rules/UniqueDirectiveNamesRule.js');\n\nvar _UniqueDirectivesPerLocationRule = require('./rules/UniqueDirectivesPerLocationRule.js');\n\nvar _UniqueEnumValueNamesRule = require('./rules/UniqueEnumValueNamesRule.js');\n\nvar _UniqueFieldDefinitionNamesRule = require('./rules/UniqueFieldDefinitionNamesRule.js');\n\nvar _UniqueFragmentNamesRule = require('./rules/UniqueFragmentNamesRule.js');\n\nvar _UniqueInputFieldNamesRule = require('./rules/UniqueInputFieldNamesRule.js');\n\nvar _UniqueOperationNamesRule = require('./rules/UniqueOperationNamesRule.js');\n\nvar _UniqueOperationTypesRule = require('./rules/UniqueOperationTypesRule.js');\n\nvar _UniqueTypeNamesRule = require('./rules/UniqueTypeNamesRule.js');\n\nvar _UniqueVariableNamesRule = require('./rules/UniqueVariableNamesRule.js');\n\nvar _ValuesOfCorrectTypeRule = require('./rules/ValuesOfCorrectTypeRule.js');\n\nvar _VariablesAreInputTypesRule = require('./rules/VariablesAreInputTypesRule.js');\n\nvar _VariablesInAllowedPositionRule = require('./rules/VariablesInAllowedPositionRule.js');\n\n// Spec Section: \"Executable Definitions\"\n// Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n// Spec Section: \"Fragments on Composite Types\"\n// Spec Section: \"Argument Names\"\n// Spec Section: \"Directives Are Defined\"\n// Spec Section: \"Fragment spread target defined\"\n// Spec Section: \"Fragment Spread Type Existence\"\n// Spec Section: \"Lone Anonymous Operation\"\n// SDL-specific validation rules\n// TODO: Spec Section\n// Spec Section: \"Fragments must not form cycles\"\n// Spec Section: \"All Variable Used Defined\"\n// Spec Section: \"Fragments must be used\"\n// Spec Section: \"All Variables Used\"\n// Spec Section: \"Field Selection Merging\"\n// Spec Section: \"Fragment spread is possible\"\n// Spec Section: \"Argument Optionality\"\n// Spec Section: \"Leaf Field Selections\"\n// Spec Section: \"Subscriptions with Single Root Field\"\n// Spec Section: \"Argument Uniqueness\"\n// Spec Section: \"Directives Are Unique Per Location\"\n// Spec Section: \"Fragment Name Uniqueness\"\n// Spec Section: \"Input Object Field Uniqueness\"\n// Spec Section: \"Operation Name Uniqueness\"\n// Spec Section: \"Variable Uniqueness\"\n// Spec Section: \"Value Type Correctness\"\n// Spec Section: \"Variables are Input Types\"\n// Spec Section: \"All Variable Usages Are Allowed\"\n\n/**\n * Technically these aren't part of the spec but they are strongly encouraged\n * validation rules.\n */\nconst recommendedRules = Object.freeze([\n  _MaxIntrospectionDepthRule.MaxIntrospectionDepthRule,\n]);\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n *\n * The order of the rules in this list has been adjusted to lead to the\n * most clear output when encountering multiple validation errors.\n */\n\nexports.recommendedRules = recommendedRules;\nconst specifiedRules = Object.freeze([\n  _ExecutableDefinitionsRule.ExecutableDefinitionsRule,\n  _UniqueOperationNamesRule.UniqueOperationNamesRule,\n  _LoneAnonymousOperationRule.LoneAnonymousOperationRule,\n  _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,\n  _KnownTypeNamesRule.KnownTypeNamesRule,\n  _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,\n  _VariablesAreInputTypesRule.VariablesAreInputTypesRule,\n  _ScalarLeafsRule.ScalarLeafsRule,\n  _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,\n  _UniqueFragmentNamesRule.UniqueFragmentNamesRule,\n  _KnownFragmentNamesRule.KnownFragmentNamesRule,\n  _NoUnusedFragmentsRule.NoUnusedFragmentsRule,\n  _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,\n  _NoFragmentCyclesRule.NoFragmentCyclesRule,\n  _UniqueVariableNamesRule.UniqueVariableNamesRule,\n  _NoUndefinedVariablesRule.NoUndefinedVariablesRule,\n  _NoUnusedVariablesRule.NoUnusedVariablesRule,\n  _KnownDirectivesRule.KnownDirectivesRule,\n  _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,\n  _KnownArgumentNamesRule.KnownArgumentNamesRule,\n  _UniqueArgumentNamesRule.UniqueArgumentNamesRule,\n  _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,\n  _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,\n  _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,\n  _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,\n  _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,\n  ...recommendedRules,\n]);\n/**\n * @internal\n */\n\nexports.specifiedRules = specifiedRules;\nconst specifiedSDLRules = Object.freeze([\n  _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,\n  _UniqueOperationTypesRule.UniqueOperationTypesRule,\n  _UniqueTypeNamesRule.UniqueTypeNamesRule,\n  _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,\n  _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,\n  _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule,\n  _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,\n  _KnownTypeNamesRule.KnownTypeNamesRule,\n  _KnownDirectivesRule.KnownDirectivesRule,\n  _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,\n  _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,\n  _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,\n  _UniqueArgumentNamesRule.UniqueArgumentNamesRule,\n  _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,\n  _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule,\n]);\nexports.specifiedSDLRules = specifiedSDLRules;\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,iBAAiB,GACvB,QAAQ,cAAc,GACtB,QAAQ,gBAAgB,GACtB,KAAK;AAET,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,yCAAyC;AACzC,4EAA4E;AAC5E,+CAA+C;AAC/C,iCAAiC;AACjC,yCAAyC;AACzC,iDAAiD;AACjD,iDAAiD;AACjD,2CAA2C;AAC3C,gCAAgC;AAChC,qBAAqB;AACrB,iDAAiD;AACjD,4CAA4C;AAC5C,yCAAyC;AACzC,qCAAqC;AACrC,0CAA0C;AAC1C,8CAA8C;AAC9C,uCAAuC;AACvC,wCAAwC;AACxC,uDAAuD;AACvD,sCAAsC;AACtC,qDAAqD;AACrD,2CAA2C;AAC3C,gDAAgD;AAChD,4CAA4C;AAC5C,sCAAsC;AACtC,yCAAyC;AACzC,4CAA4C;AAC5C,kDAAkD;AAElD;;;CAGC,GACD,MAAM,mBAAmB,OAAO,MAAM,CAAC;IACrC,2BAA2B,yBAAyB;CACrD;AACD;;;;;CAKC,GAED,QAAQ,gBAAgB,GAAG;AAC3B,MAAM,iBAAiB,OAAO,MAAM,CAAC;IACnC,2BAA2B,yBAAyB;IACpD,0BAA0B,wBAAwB;IAClD,4BAA4B,0BAA0B;IACtD,8BAA8B,4BAA4B;IAC1D,oBAAoB,kBAAkB;IACtC,+BAA+B,6BAA6B;IAC5D,4BAA4B,0BAA0B;IACtD,iBAAiB,eAAe;IAChC,yBAAyB,uBAAuB;IAChD,yBAAyB,uBAAuB;IAChD,wBAAwB,sBAAsB;IAC9C,uBAAuB,qBAAqB;IAC5C,6BAA6B,2BAA2B;IACxD,sBAAsB,oBAAoB;IAC1C,yBAAyB,uBAAuB;IAChD,0BAA0B,wBAAwB;IAClD,uBAAuB,qBAAqB;IAC5C,qBAAqB,mBAAmB;IACxC,iCAAiC,+BAA+B;IAChE,wBAAwB,sBAAsB;IAC9C,yBAAyB,uBAAuB;IAChD,yBAAyB,uBAAuB;IAChD,+BAA+B,6BAA6B;IAC5D,gCAAgC,8BAA8B;IAC9D,kCAAkC,gCAAgC;IAClE,2BAA2B,yBAAyB;OACjD;CACJ;AACD;;CAEC,GAED,QAAQ,cAAc,GAAG;AACzB,MAAM,oBAAoB,OAAO,MAAM,CAAC;IACtC,0BAA0B,wBAAwB;IAClD,0BAA0B,wBAAwB;IAClD,qBAAqB,mBAAmB;IACxC,0BAA0B,wBAAwB;IAClD,gCAAgC,8BAA8B;IAC9D,mCAAmC,iCAAiC;IACpE,0BAA0B,wBAAwB;IAClD,oBAAoB,kBAAkB;IACtC,qBAAqB,mBAAmB;IACxC,iCAAiC,+BAA+B;IAChE,4BAA4B,0BAA0B;IACtD,wBAAwB,kCAAkC;IAC1D,yBAAyB,uBAAuB;IAChD,2BAA2B,yBAAyB;IACpD,+BAA+B,yCAAyC;CACzE;AACD,QAAQ,iBAAiB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5556, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/ValidationContext.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.ValidationContext =\n  exports.SDLValidationContext =\n  exports.ASTValidationContext =\n    void 0;\n\nvar _kinds = require('../language/kinds.js');\n\nvar _visitor = require('../language/visitor.js');\n\nvar _TypeInfo = require('../utilities/TypeInfo.js');\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nclass ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while ((set = setsToVisit.pop())) {\n        for (const selection of set.selections) {\n          if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while ((node = nodesToVisit.pop())) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n}\n\nexports.ASTValidationContext = ASTValidationContext;\n\nclass SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n}\n\nexports.SDLValidationContext = SDLValidationContext;\n\nclass ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new _TypeInfo.TypeInfo(this._schema);\n      (0, _visitor.visit)(\n        node,\n        (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {\n          VariableDefinition: () => false,\n\n          Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue(),\n              parentType: typeInfo.getParentInputType(),\n            });\n          },\n        }),\n      );\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\n\nexports.ValidationContext = ValidationContext;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5739, "column": 0}, "map": {"version":3,"sources":["file:///home/s/Documents/Programmazione/GitHub/MyRepositories/eC/ec/node_modules/graphql/validation/validate.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.assertValidSDL = assertValidSDL;\nexports.assertValidSDLExtension = assertValidSDLExtension;\nexports.validate = validate;\nexports.validateSDL = validateSDL;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _visitor = require('../language/visitor.js');\n\nvar _validate = require('../type/validate.js');\n\nvar _TypeInfo = require('../utilities/TypeInfo.js');\n\nvar _specifiedRules = require('./specifiedRules.js');\n\nvar _ValidationContext = require('./ValidationContext.js');\n\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Validate will stop validation after a `maxErrors` limit has been reached.\n * Attackers can send pathologically invalid queries to induce a DoS attack,\n * so by default `maxErrors` set to 100 errors.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\nfunction validate(\n  schema,\n  documentAST,\n  rules = _specifiedRules.specifiedRules,\n  options,\n  /** @deprecated will be removed in 17.0.0 */\n  typeInfo = new _TypeInfo.TypeInfo(schema),\n) {\n  var _options$maxErrors;\n\n  const maxErrors =\n    (_options$maxErrors =\n      options === null || options === void 0 ? void 0 : options.maxErrors) !==\n      null && _options$maxErrors !== void 0\n      ? _options$maxErrors\n      : 100;\n  documentAST || (0, _devAssert.devAssert)(false, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  (0, _validate.assertValidSchema)(schema);\n  const abortObj = Object.freeze({});\n  const errors = [];\n  const context = new _ValidationContext.ValidationContext(\n    schema,\n    documentAST,\n    typeInfo,\n    (error) => {\n      if (errors.length >= maxErrors) {\n        errors.push(\n          new _GraphQLError.GraphQLError(\n            'Too many validation errors, error limit reached. Validation aborted.',\n          ),\n        ); // eslint-disable-next-line @typescript-eslint/no-throw-literal\n\n        throw abortObj;\n      }\n\n      errors.push(error);\n    },\n  ); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  const visitor = (0, _visitor.visitInParallel)(\n    rules.map((rule) => rule(context)),\n  ); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    (0, _visitor.visit)(\n      documentAST,\n      (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor),\n    );\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nfunction validateSDL(\n  documentAST,\n  schemaToExtend,\n  rules = _specifiedRules.specifiedSDLRules,\n) {\n  const errors = [];\n  const context = new _ValidationContext.SDLValidationContext(\n    documentAST,\n    schemaToExtend,\n    (error) => {\n      errors.push(error);\n    },\n  );\n  const visitors = rules.map((rule) => rule(context));\n  (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nfunction assertValidSDL(documentAST) {\n  const errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nfunction assertValidSDLExtension(documentAST, schema) {\n  const errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,cAAc,GAAG;AACzB,QAAQ,uBAAuB,GAAG;AAClC,QAAQ,QAAQ,GAAG;AACnB,QAAQ,WAAW,GAAG;AAEtB,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ;;;;;;;;;;;;;;;;;;;CAmBC,GACD,SAAS,SACP,MAAM,EACN,WAAW,EACX,QAAQ,gBAAgB,cAAc,EACtC,OAAO,EACP,0CAA0C,GAC1C,WAAW,IAAI,UAAU,QAAQ,CAAC,OAAO;IAEzC,IAAI;IAEJ,MAAM,YACJ,CAAC,qBACC,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,SAAS,MACnE,QAAQ,uBAAuB,KAAK,IAClC,qBACA;IACN,eAAe,CAAC,GAAG,WAAW,SAAS,EAAE,OAAO,2BAA2B,gEAAgE;IAE3I,CAAC,GAAG,UAAU,iBAAiB,EAAE;IACjC,MAAM,WAAW,OAAO,MAAM,CAAC,CAAC;IAChC,MAAM,SAAS,EAAE;IACjB,MAAM,UAAU,IAAI,mBAAmB,iBAAiB,CACtD,QACA,aACA,UACA,CAAC;QACC,IAAI,OAAO,MAAM,IAAI,WAAW;YAC9B,OAAO,IAAI,CACT,IAAI,cAAc,YAAY,CAC5B,0EAED,+DAA+D;YAElE,MAAM;QACR;QAEA,OAAO,IAAI,CAAC;IACd,IACC,4EAA4E;IAC/E,oDAAoD;IAEpD,MAAM,UAAU,CAAC,GAAG,SAAS,eAAe,EAC1C,MAAM,GAAG,CAAC,CAAC,OAAS,KAAK,YACxB,qEAAqE;IAExE,IAAI;QACF,CAAC,GAAG,SAAS,KAAK,EAChB,aACA,CAAC,GAAG,UAAU,iBAAiB,EAAE,UAAU;IAE/C,EAAE,OAAO,GAAG;QACV,IAAI,MAAM,UAAU;YAClB,MAAM;QACR;IACF;IAEA,OAAO;AACT;AACA;;CAEC,GAED,SAAS,YACP,WAAW,EACX,cAAc,EACd,QAAQ,gBAAgB,iBAAiB;IAEzC,MAAM,SAAS,EAAE;IACjB,MAAM,UAAU,IAAI,mBAAmB,oBAAoB,CACzD,aACA,gBACA,CAAC;QACC,OAAO,IAAI,CAAC;IACd;IAEF,MAAM,WAAW,MAAM,GAAG,CAAC,CAAC,OAAS,KAAK;IAC1C,CAAC,GAAG,SAAS,KAAK,EAAE,aAAa,CAAC,GAAG,SAAS,eAAe,EAAE;IAC/D,OAAO;AACT;AACA;;;;;CAKC,GAED,SAAS,eAAe,WAAW;IACjC,MAAM,SAAS,YAAY;IAE3B,IAAI,OAAO,MAAM,KAAK,GAAG;QACvB,MAAM,IAAI,MAAM,OAAO,GAAG,CAAC,CAAC,QAAU,MAAM,OAAO,EAAE,IAAI,CAAC;IAC5D;AACF;AACA;;;;;CAKC,GAED,SAAS,wBAAwB,WAAW,EAAE,MAAM;IAClD,MAAM,SAAS,YAAY,aAAa;IAExC,IAAI,OAAO,MAAM,KAAK,GAAG;QACvB,MAAM,IAAI,MAAM,OAAO,GAAG,CAAC,CAAC,QAAU,MAAM,OAAO,EAAE,IAAI,CAAC;IAC5D;AACF","ignoreList":[0],"debugId":null}}]
}